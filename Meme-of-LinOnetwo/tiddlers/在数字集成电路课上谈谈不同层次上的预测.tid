created: 20200609122825537
creator: 林一二
modified: 20200609142742398
modifier: 林一二
tags: 说好要做的事情
title: 在数字集成电路课上谈谈不同层次上的预测
tmap.id: 8eb1efa3-7946-4bba-9504-345e04e1a459
type: text/vnd.tiddlywiki

[[寇老师|寇熙丰]]本来让我简单讲一讲「不同指令实际运行的步骤」，不过我好久没看指令那部分了，怕讲得磕磕绊绊，于是我打算讲讲不同层次上的预测和浪费。

!! 浏览器应用层

Google I/O 2019 提出，越来越多的网站开始做代码分块，延迟加载暂时用不到的块，因为

# 单页面应用（Single Page App）越来越大
# 加载同样大小的 JS 和图片，JS 消耗的时间更多（因为需要 gzip、unzip、解析等）

[img[加载同样大小的 JS 和图片，JS 消耗的时间更多.png]]

代码分割（Code Splitting）可以在你使用「创建新文章」表单时仅加载渲染这个表单所需的 JS：

[img[仅加载渲染表单所需的JS.png]]

但是在地铁里打开这样的 SPA 时，加载下一个页面就要加载下一个块，这会很卡：

[img[代码分割后，加载下一个模块很慢.png]]

我们习惯了打开一个 SPA 后就应该有丝滑体验，切换 route 不应该会卡。所以预加载。

风险：

# 消耗大量网络资源来预加载用户并不会去访问的页面的 JS
# 折腾了半天预测错了，该加载的 JS 却没有加载

[img[预测维基页面上下一个访问的链接.png]]

降低风险：

# 通过 Google Analytics 统计路由跳转概率，训练一个预测模型
# 用户访问页面时，用马尔科夫链或训练好的 RNN 预测下几个要加载的 JS

[img[GuessJS如何预测要预加载哪些JS.png]]


!! JS JIT 层

JS 是一个很快的语言，金主 Google 将其速度提升到了 C++ 的二十分之一到二分之一。

到底是几分之一取决于 Just In Time 引擎有没有预测到下一个操作。

例如运行 for 循环时：

```js
function arraySum(arrayToSum: Array<number>) {
  let sum: number = 0;
  for (let index = 0; index < arrayToSum.length; index++) {
    sum += arrayToSum[index];
  }
	return sum;
}
```

一开始是解释执行，解释结果跑完一次就丢掉

[img[解释执行代码.jpg]]

然后 JS 引擎中有一个 Monitor 会监控

# 每段代码运行的次数
# 代码中的变量的类型

如果相加这段代码运行次数足够多就会被标记为 Warn，允许它享受基本的缓存服务、生成优化的代码（比如使用 j 跳转回循环开头）：

[img[用BaseLine编译器简单编译并缓存.jpg]]

但是 JS 是动态类型的，`+` 可能会产生多种编译结果

在运行时，引擎会担心数组里可能有数字也可能有字符串，所以会把每种类型组合的相加操作都编译一组 operation 出来

[img[JS的编译器需要对每种类型组合都编译一个操作.png]]

这时每次循环都要检查类型组合是什么，然后取出对应的缓存好的指令，这仍然比重新解释要快

[img[使用基线编译器的编译结果需要每次都检查类型.png]]

如果跑得足够多，Monitor 就会发现其实数组里都是 int 类型的数字，就可以抛弃掉其他组合的指令了，而且可以重新排列指令生成巨优化的代码

[img[用优化编译器做更优化的编译.jpg]]

当然这假设了每个变量的类型就是我们猜的那样

[img[使用优化编译器的结果需要假设类型.png]]

如果我们猜错了，比如数组中间突然放了一个字符串…就会去优化 （deoptimization）

[img[如果类型假设错了就会去优化.png]]

风险：

# 可能会猜错，导致浪费很多内存去缓存指令、浪费 Monitor 的时间去打扫缓存
# 优化了的代码没用几次就弃如敝履，浪费一片好心

解决风险：

# 鼓励Web程序员使用TypeScript等带静态类型标注的语言
# 如果 Monitor 翻错太多次，就让它冷静一会儿，先不要在这块代码上继续送人头了

!! Pipeline

Branch Detection

之前提到预加载 JS，gzip

!! ALU

同时计算多种运算的结果