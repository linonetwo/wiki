/**
  title: $:/plugins/linonetwo/watch-fs/watch.js
  type: application/javascript
  module-type: startup
 * https://github.com/yuanchuan/node-watch
 * @version 0.6.4
 */

function watchIIFE() {
  if (typeof $tw === 'undefined' || !$tw?.node) return;
  exports.name = 'watch-fs_watch';
  exports.after = ['load-modules', 'watch-fs_is', 'watch-fs_has-native-recursive'];
  exports.platforms = ['node'];
  exports.synchronous = true;

  const fs = require('fs');
  const path = require('path');
  const util = require('util');
  const events = require('events');

  const hasNativeRecursive = require('./has-native-recursive');
  const is = require('./is');

  const EVENT_UPDATE = 'update';
  const EVENT_REMOVE = 'remove';

  function hasDup(array) {
    return array.some(function(v, i, self) {
      return self.indexOf(v) !== i;
    });
  }

  function unique(array) {
    return array.filter(function(v, i, self) {
      return self.indexOf(v) === i;
    });
  }

  function assertEncoding(encoding) {
    if (encoding && encoding !== 'buffer' && !Buffer.isEncoding(encoding)) {
      throw new Error(`Unknown encoding: ${encoding}`);
    }
  }

  function guard(fn) {
    return function(argument, action) {
      if (is.func(fn)) {
        if (fn(argument)) action();
      } else if (is.regExp(fn)) {
        if (fn.test(argument)) action();
      } else {
        action();
      }
    };
  }

  function composeMessage(names) {
    return names.map(function(n) {
      return is.exists(n) ? [EVENT_UPDATE, n] : [EVENT_REMOVE, n];
    });
  }

  function getMessages(cache) {
    let filtered = unique(cache);

    // Saving file from an editor? If so, assuming the
    // non-existed files in the cache are temporary files
    // generated by an editor and thus be filtered.
    const reg = /~$|^\.#|^##$/g;
    const hasSpecialChar = cache.some(function(c) {
      return reg.test(c);
    });

    if (hasSpecialChar) {
      const dup = hasDup(
        cache.map(function(c) {
          return c.replace(reg, '');
        }),
      );
      if (dup) {
        filtered = filtered.filter(function(m) {
          return is.exists(m);
        });
      }
    }

    // Prevent redundant event for its parent when creating file/directory.
    // The operation is kinda expensive so only be triggered under Windows.
    // https://github.com/yuanchuan/node-watch/issues/79
    if (is.windows()) {
      const parents = filtered.map(function(n) {
        return path.parse(n).dir;
      });
      filtered = filtered.filter(function(n) {
        // Skip on removal
        if (!is.exists(n)) {
          return true;
        }
        // Ignore the parent directory
        return !parents.some(function(m) {
          return is.samePath(n, m);
        });
      });
    }

    return composeMessage(filtered);
  }

  function debounce(info, fn) {
    let timer;
    let cache = [];
    const { encoding } = info.options;
    let { delay } = info.options;
    if (!is.number(delay)) {
      delay = 200;
    }
    function handle() {
      getMessages(cache).forEach(function(message) {
        message[1] = Buffer.from(message[1]);
        if (encoding !== 'buffer') {
          message[1] = message[1].toString(encoding);
        }
        fn.apply(null, message);
      });
      timer = null;
      cache = [];
    }
    return function(rawEvent, name) {
      cache.push(name);
      if (!timer) {
        timer = setTimeout(handle, delay);
      }
    };
  }

  function createDupsFilter() {
    let memo = {};
    return function(fn) {
      return function(event, name) {
        memo[event + name] = [event, name];
        setTimeout(function() {
          Object.keys(memo).forEach(function(n) {
            fn.apply(null, memo[n]);
          });
          memo = {};
        });
      };
    };
  }

  function getSubDirectories(dir, fn, done = function() {}) {
    if (is.directory(dir)) {
      fs.readdir(dir, function(error, all) {
        if (error) {
          // don't throw permission errors.
          if (/^(EPERM|EACCES)$/.test(error.code)) {
            console.warn('Warning: Cannot access %s.', dir);
          } else {
            throw error;
          }
        } else {
          all.forEach(function(f) {
            const sdir = path.join(dir, f);
            if (is.directory(sdir)) fn(sdir);
          });
          done();
        }
      });
    } else {
      done();
    }
  }

  function semaphore(final) {
    let counter = 0;
    return function start() {
      counter++;
      return function stop() {
        counter--;
        if (counter === 0) final();
      };
    };
  }

  function nullCounter() {
    return function nullStop() {};
  }

  const deprecationWarning = util.deprecate(function() {},
  '(node-watch) First param in callback function\
  is replaced with event name since 0.5.0, use\
  `(evt, filename) => {}` if you want to get the filename');

  function Watcher() {
    events.EventEmitter.call(this);
    this.watchers = {};
    this._isReady = false;
    this._isClosed = false;
  }

  util.inherits(Watcher, events.EventEmitter);

  Watcher.prototype.expose = function() {
    const self = this;
    const methods = ['on', 'emit', 'close', 'isClosed', 'listeners', 'once', 'setMaxListeners', 'getMaxListeners'];
    return methods.reduce(function(expose, name) {
      expose[name] = function() {
        return self[name].apply(self, arguments);
      };
      return expose;
    }, {});
  };

  Watcher.prototype.isClosed = function() {
    return this._isClosed;
  };

  Watcher.prototype.close = function(fullPath) {
    const self = this;
    if (fullPath) {
      const watcher = this.watchers[fullPath];
      if (watcher && watcher.close) {
        watcher.close();
        delete self.watchers[fullPath];
      }
      getSubDirectories(fullPath, function(fpath) {
        self.close(fpath);
      });
    } else {
      Object.keys(self.watchers).forEach(function(fpath) {
        const watcher = self.watchers[fpath];
        if (watcher && watcher.close) {
          watcher.close();
        }
      });
      this.watchers = {};
    }
    // Do not close the Watcher unless all child watchers are closed.
    // https://github.com/yuanchuan/node-watch/issues/75
    if (is.emptyObject(self.watchers)) {
      this._isClosed = true;
      process.nextTick(emitClose, this);
    }
  };

  function emitReady(self) {
    if (!self._isReady) {
      self._isReady = true;
      // do not call emit for 'ready' until after watch() has returned,
      // so that consumer can call on().
      process.nextTick(function() {
        self.emit('ready');
      });
    }
  }

  function emitClose(self) {
    self.emit('close');
  }

  Watcher.prototype.add = function(watcher, info) {
    const self = this;
    info = info || { fpath: '' };
    const watcherPath = path.resolve(info.fpath);
    this.watchers[watcherPath] = watcher;

    // Internal callback for handling fs.FSWatcher 'change' events
    const internalOnChange = function(rawEvent, rawName) {
      if (self.isClosed()) {
        return;
      }

      // normalise lack of name and convert to full path
      let name = rawName;
      if (is.nil(name)) {
        name = '';
      }
      name = path.join(info.fpath, name);

      if (info.options.recursive) {
        hasNativeRecursive(function(has) {
          if (!has) {
            const fullPath = path.resolve(name);
            // remove watcher on removal
            if (!is.exists(name)) {
              self.close(fullPath);
            }
            // watch new created directory
            else if (is.directory(name) && !self.watchers[fullPath]) {
              self.watchDirectory(name, info.options);
            }
          }
        });
      }

      handlePublicEvents(rawEvent, name);
    };

    // Debounced based on the 'delay' option
    var handlePublicEvents = debounce(info, function(event, name) {
      // watch single file
      if (info.compareName) {
        if (info.compareName(name)) {
          self.emit('change', event, name);
        }
      }
      // watch directory
      else {
        const filterGuard = guard(info.options.filter);
        filterGuard(name, function() {
          if (self.flag) self.flag = '';
          else self.emit('change', event, name);
        });
      }
    });

    watcher.on('error', function(error) {
      if (self.isClosed()) {
        return;
      }
      if (is.windows() && error.code === 'EPERM') {
        watcher.emit('change', EVENT_REMOVE, info.fpath && '');
        self.flag = 'windows-error';
        self.close(watcherPath);
      } else {
        self.emit('error', error);
      }
    });

    watcher.on('change', internalOnChange);
  };

  Watcher.prototype.watchFile = function(file, options, fn) {
    const parent = path.join(file, '../');
    const options_ = {
      ...options, // no filter for single file
      filter: null,
      encoding: 'utf8',
    };

    // no need to watch recursively
    delete options_.recursive;

    const watcher = fs.watch(parent, options_);
    this.add(watcher, {
      type: 'file',
      fpath: parent,
      options: { ...options_, encoding: options.encoding },
      compareName(n) {
        return is.samePath(n, file);
      },
    });

    if (is.func(fn)) {
      if (fn.length === 1) deprecationWarning();
      this.on('change', fn);
    }
  };

  Watcher.prototype.watchDirectory = function(dir, options, fn, counter = nullCounter) {
    const self = this;
    const done = counter();
    hasNativeRecursive(function(has) {
      // always specify recursive
      options.recursive = !!options.recursive;
      // using utf8 internally
      const options_ = { ...options, encoding: 'utf8' };
      if (!has) {
        delete options_.recursive;
      }

      const watcher = fs.watch(dir, options_);

      self.add(watcher, {
        type: 'dir',
        fpath: dir,
        options,
      });

      if (is.func(fn)) {
        if (fn.length === 1) deprecationWarning();
        self.on('change', fn);
      }

      if (options.recursive && !has) {
        getSubDirectories(
          dir,
          function(d) {
            self.watchDirectory(d, options, null, counter);
          },
          counter(),
        );
      }

      done();
    });
  };

  function composeWatcher(watchers) {
    const watcher = new Watcher();
    const filterDups = createDupsFilter();
    let counter = watchers.length;
    watchers.forEach(function(w) {
      w.on(
        'change',
        filterDups(function(event, name) {
          watcher.emit('change', event, name);
        }),
      );
      w.on('error', function(error) {
        watcher.emit('error', error);
      });
      w.on('ready', function() {
        if (!--counter) {
          emitReady(watcher);
        }
      });
    });

    watcher.close = function() {
      watchers.forEach(function(w) {
        w.close();
      });
      process.nextTick(emitClose, watcher);
    };
    return watcher.expose();
  }

  function watch(fpath, options, fn) {
    const watcher = new Watcher();

    if (is.buffer(fpath)) {
      fpath = fpath.toString();
    }

    if (is.array(fpath)) {
      if (fpath.length === 1) {
        return watch(fpath[0], options, fn);
      }
      const filterDups = createDupsFilter();
      return composeWatcher(
        unique(fpath).map(function(f) {
          const w = watch(f, options);
          if (fn) w.on('change', filterDups(fn));
          return w;
        }),
      );
    }

    if (!is.exists(fpath)) {
      watcher.emit('error', new Error(`${fpath} does not exist.`));
    }

    if (is.string(options)) {
      options = {
        encoding: options,
      };
    }

    if (is.func(options)) {
      fn = options;
      options = {};
    }

    if (arguments.length < 2) {
      options = {};
    }

    if (options.encoding) {
      assertEncoding(options.encoding);
    } else {
      options.encoding = 'utf8';
    }

    if (is.file(fpath)) {
      watcher.watchFile(fpath, options, fn);
      emitReady(watcher);
    } else if (is.directory(fpath)) {
      const counter = semaphore(function() {
        emitReady(watcher);
      });
      watcher.watchDirectory(fpath, options, fn, counter);
    }

    return watcher.expose();
  }

  module.exports = watch;
  module.exports.default = watch;
}
watchIIFE();
