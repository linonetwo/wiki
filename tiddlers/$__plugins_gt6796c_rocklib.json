{
    "tiddlers": {
        "$:/plugins/gt6796c/rocklib/widget-tools.js": {
            "type": "application/javascript",
            "title": "$:/plugins/gt6796c/rocklib/widget-tools.js",
            "module-type": "library",
            "text": "/*\\\n title: $:/plugins/gt6796c/rocklib/widget-tools.js\n type: application/javascript\n*/\n\n(function() {\n\n\"use strict\";\n\n    function Rocklib()\n    {\n        this.uniqueID = 1;\n        this.hue = .2;\n    };\n\n    // tries to un-parse the wikitext. of dubious value\n    Rocklib.prototype.getScriptBody = function(src,attr)\n    {\n        var scriptBody= src.getAttribute(attr, src.parseTreeNode.text || \"\");\n\n        if (src.parseTreeNode.text) {\n            scriptBody = src.parseTreeNode.text;\n        }\n        else if (src.parseTreeNode.children)\n        {\n            var kids = src.parseTreeNode.children;\n            for (var k in kids)\n            {\n                var kk = kids[k];\n                switch(kk.type)\n                {\n                    // no wikiparsing found\n                    case \"text\":\n                        scriptBody += kk.text; break;\n                    // internal link, make it a permalink reference\n                    case \"link\":\n                        scriptBody += \"#\" + kk.children[0].text; break;\n                    // -- gets interpreted as an HTML element, we don't want that\n                    case \"entity\":\n                        switch(kk.entity)\n                        {\n                            case \"&ndash;\":\n                                scriptBody+=\"--\"; break;\n                        };\n                        break;\n                    // just re-write it back out\n                    case \"element\":\n                        switch (kk.tag)\n                        {\n                            case \"a\":\n                                scriptBody+=kk.children[0].text;\n                        }\n                };\n            }\n        }\n\n        return scriptBody;\n    };\n\n    /**\n     * Runs through lots of ways to get options. It can pull them from a named data Tiddler, from the fields of the\n     * Tiddler, and from the attributes of the widget specified by 'tag'. Any value pulled is treated as JSON first\n     * and then as straight text.\n     * @param src\n     * @param tag\n     * @param options\n     * @returns {*}\n     */\n    Rocklib.prototype.getOptions = function(src, tag, options)\n    {\n        try {\n            // try to set options from fields on tiddler first\n            // [tag-xxx]\n            var tt = src.getVariable('currentTiddler');\n            if (tt) {\n                var t = src.wiki.getTiddler(tt);\n                if (t)\n                {\n                    // this looks for fields that start with our tag\n                    // and then maps a.x to aX since something is\n                    // unCamelCasing the vars\n                    for (var f in t.fields) {\n                        var fi = f.indexOf(tag);\n                        if (fi != 0) continue;\n                        var k = f.substring(tag.length + 1);\n                        var cap = k.indexOf(\".\");\n                        while (cap > -1) {\n                            if (k.length < cap+2) break;\n                            k = k.substring(0, cap) + k.charAt(cap + 1).toUpperCase() + k.substring(cap + 2);\n                            cap = k.indexOf(\".\");\n                        }\n                        var v = t.fields[f];\n                        // try as JSON\n                        try {\n                            options[k] = JSON.parse(v);\n                        }\n                            // last attempt is just a string\n                        catch (ex) {\n                            options[k] = v;\n                        }\n                    }\n                }\n            }\n            // treat any attributes as JSON representations of options\n            // for the object\n            for (var att in src.attributes) {\n\n                var attval = src.getAttribute(att);\n                // allow for data from named tiddlers\n                if ($tw.wiki.tiddlerExists(attval))\n                {\n                    var data = $tw.wiki.getTiddlerData(attval);\n                    options[att] = data;\n                }\n                else {\n                    // try as JSON\n                    try { options[att] = JSON.parse(attval); }\n                        // last attempt is just a string\n                    catch (ex) { options[att] = attval; }\n                }\n            }\n        }\n        catch (ex) { console.error(ex); }\n\n        return options;\n\n    };\n\n    /**\n     * Retrieves a canvas to work with based on the calling functions need of a \"div\" or \"canvas\" element\n     * @param src\n     * @param tag\n     * @param type\n     * @returns {Element}\n     */\n    Rocklib.prototype.getCanvas = function(src, tag, type) {\n        type = typeof(type) === \"undefined\" ? \"div\" : type;\n\n        var height = src.getAttribute(\"height\");\n        var width = src.getAttribute(\"width\");\n\n        var canvas = src.document.createElement(type);\n        var style = \"\";\n        if (type === \"canvas\") {\n            if (width) canvas.width = width;\n            if (height) canvas.height = height;\n        }\n        else {\n            if (height) style += \" height:\" + height;\n            if (width) style += \" width:\" + width;\n            if (style) canvas.setAttribute(\"style\", style);\n        }\n        canvas.setAttribute(\"id\", tag+\"_\" + this.uniqueID);\n\n        this.uniqueID++;\n        return canvas;\n    };\n\n    /**\n     * based on http://martin.ankerl.com/2009/12/09/how-to-create-random-colors-programmatically/\n     * @param s\n     * @param v\n     * @returns {string}\n     */\n    Rocklib.prototype.nextColor = function(s, v)\n    {\n        var golden_ratio_conjugate = 0.618033988749895\n        this.hue += golden_ratio_conjugate;\n        this.hue %= 1;\n        var rgb = this.hsv_to_rgb(this.hue, s, v);\n        return \"#\" + rgb.r.toString(16) + rgb.g.toString(16) + rgb.b.toString(16);\n    };\n\n\n    /**\n     * Taken from http://stackoverflow.com/questions/17242144/javascript-convert-hsb-hsv-color-to-rgb-accurately\n     */\n    /* accepts parameters\n    * r  Object = {r:x, g:y, b:z}\n        * OR\n        * r, g, b\n    */\n\n    Rocklib.prototype.rgb_to_hsv = function (r, g, b) {\n        if (arguments.length === 1) {\n            g = r.g, b = r.b, r = r.r;\n        }\n        var max = Math.max(r, g, b), min = Math.min(r, g, b),\n            d = max - min,\n            h,\n            s = (max === 0 ? 0 : d / max),\n            v = max / 255;\n\n        switch (max) {\n            case min: h = 0; break;\n            case r: h = (g - b) + d * (g < b ? 6: 0); h /= 6 * d; break;\n            case g: h = (b - r) + d * 2; h /= 6 * d; break;\n            case b: h = (r - g) + d * 4; h /= 6 * d; break;\n        }\n\n        return {\n            h: h,\n            s: s,\n            v: v\n        };\n    };\n\n    /**\n     * Taken from http://stackoverflow.com/questions/17242144/javascript-convert-hsb-hsv-color-to-rgb-accurately\n     */\n    /* accepts parameters\n     * h  Object = {h:x, s:y, v:z}\n     * OR\n     * h, s, v\n     */\n    Rocklib.prototype.hsv_to_rgb = function(h, s, v) {\n        var r, g, b, i, f, p, q, t;\n        if (arguments.length === 1) {\n            s = h.s, v = h.v, h = h.h;\n        }\n        i = Math.floor(h * 6);\n        f = h * 6 - i;\n        p = v * (1 - s);\n        q = v * (1 - f * s);\n        t = v * (1 - (1 - f) * s);\n        switch (i % 6) {\n            case 0: r = v, g = t, b = p; break;\n            case 1: r = q, g = v, b = p; break;\n            case 2: r = p, g = v, b = t; break;\n            case 3: r = p, g = q, b = v; break;\n            case 4: r = t, g = p, b = v; break;\n            case 5: r = v, g = p, b = q; break;\n        }\n        return {\n            r: Math.round(r * 255),\n            g: Math.round(g * 255),\n            b: Math.round(b * 255)\n        };\n    };\n\n    exports.rocklib = Rocklib;\n\n})();\n\n"
        },
        "$:/plugins/gt6796c/rocklib/license": {
            "title": "$:/plugins/gt6796c/rocklib/license",
            "text": "The MIT License (MIT)\n\nCopyright (c) 2016 Nathaniel Jones\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        "$:/plugins/gt6796c/rocklib/readme": {
            "title": "$:/plugins/gt6796c/rocklib/readme",
            "text": "\nThis plugin packages [[rocklib|https://github.com/gt6796c/rocklib]] for use by other plugins. It does not provide any end-user visible features.\n\nNo user-visible elements.\n\nprovides the following functions:\n\n;getScriptBody(src, att)\n: attempts to pull the text out of ``src`` element's body or the specified attribute ``att``\n\n;getOptions(src,tag,options)\n: in the case of a widget, adds all of ``src`` element's attributes into the ``options`` object\n: in the case of a Tiddler, adds all of the fields that begin with ``tag`` into the ``options`` object (minus the ``tag-`` prefix)\n: All options are first treated as Data Tiddler Names, then JSON, and finally as plain text\n\n;getCanvas(src,tag,type)\n: creates a uniquely-named \"canvas\" which may be of type ``type``. Supported types are ``div`` and ``canvas``\n: The height and width attributes from the ``src`` element will be applied to the canvas\n\n;nextColor(s,v)\n: returns a random-ish color string from the same palette as specified byt the ``s`` saturation and ``h`` hue.\n: The color is in the form of ``#rrggbb``\n\n;rgb_to_hsv(r,g,b)\n: returns array of [hue, saturation, value]\n: r can be array of [r,g,b] or individual parameters can be used\n\n;hsv_to_rgb(h,s,v)\n: returns array of [red, green, blue]\n: h can be array of [h,s,v] or individual parameters can be used\n"
        }
    }
}