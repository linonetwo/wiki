{"tiddlers":{"$:/plugins/twcloud/tiddlyweb-sse/readme":{"title":"$:/plugins/twcloud/tiddlyweb-sse/readme","text":"This plugin runs in both the browser and server to sync changes immediately instead of waiting for polling. It adds a route to the server which sends server-sent events to the client, and loads an EventSource in the client to call $tw.syncer.syncFromServer(). \n\n[[Source code|https://github.com/twcloud/tiddlyweb-sse]]\r\n"},"$:/core/modules/server/server-sent-events.js":{"title":"$:/core/modules/server/server-sent-events.js","text":"\"use strict\";\r\n/*jslint node: true, browser: true */\r\n/*global $tw: false */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SSEClient = exports.JournalRecord = exports.Journal = void 0;\r\nvar Journal = /** @class */ (function () {\r\n  function Journal(JOURNALAGE) {\r\n    if (JOURNALAGE === void 0) { JOURNALAGE = 5 * 60 * 1000; }\r\n    this.JOURNALAGE = JOURNALAGE;\r\n    this.connections = {};\r\n    this.entryIDs = {};\r\n    this.records = {};\r\n    this.responseHeaders = {};\r\n    this.repeaterFilter = function (conn) { return function (conn) { return true; }; };\r\n  }\r\n  Journal.prototype.cleanJournal = function (ts, channel) {\r\n    var maxage = ts - this.JOURNALAGE;\r\n    while (this.records[channel][0].Timestamp < maxage) {\r\n      this.records[channel].shift();\r\n    }\r\n  };\r\n  Journal.prototype.initJournal = function (key) {\r\n    if (!this.connections[key]) {\r\n      this.connections[key] = [];\r\n    }\r\n    if (!this.records[key]) {\r\n      this.records[key] = [new JournalRecord(\"\", \"\", 0, Date.now())];\r\n    }\r\n    if (!this.entryIDs[key]) {\r\n      this.entryIDs[key] = 1;\r\n    }\r\n  };\r\n  Journal.prototype.handleConnection = function (conn) {\r\n    var channel = conn.channel;\r\n    this.initJournal(channel);\r\n    if (conn.request.headers[\"last-event-id\"]) {\r\n      var id = conn.request.headers[\"last-event-id\"];\r\n      var found = false;\r\n      // find the specified event ID the client last recieved and return everything since then\r\n      for (var i = 0; i < this.records[channel].length; i++) {\r\n        var tag = this.records[channel][i].EventIDString;\r\n        // return all records after the record that was found\r\n        if (found) {\r\n          conn.writeJournalRecord(this.records[channel][i]);\r\n        }\r\n        // we don't need to send the tag here because it is a reconnect and already has it\r\n        else if (tag === id) {\r\n          found = true;\r\n          conn.start(200, this.responseHeaders);\r\n        }\r\n      }\r\n      // If not found return 409 Conflict since that event id is not found\r\n      // this way the client can retry manually if needed.\r\n      if (found == false) {\r\n        conn.start(409);\r\n        conn.end();\r\n        return;\r\n      }\r\n    }\r\n    else {\r\n      var index = this.records[channel].length - 1;\r\n      var latest = index > -1 ? this.records[channel][index] : null;\r\n      conn.start(200, this.responseHeaders, latest === null || latest === void 0 ? void 0 : latest.EventIDString);\r\n    }\r\n    this.connections[channel].push(conn);\r\n    conn.onended = this.handleConnectionEnded.bind(this, conn);\r\n  };\r\n  Journal.prototype.handleConnectionEnded = function (conn) {\r\n    this.connections[conn.channel].splice(this.connections[conn.channel].indexOf(conn), 1);\r\n  };\r\n  Journal.prototype.handler = function (request, response, state) {\r\n    if (true /* this.isEventStreamRequest(request) */) {\r\n      this.handleConnection(new SSEClient(request, response, state));\r\n    }\r\n    else {\r\n      response.writeHead(406, \"Not Acceptable\");\r\n      response.end();\r\n    }\r\n  };\r\n  Journal.prototype.handlerExports = function (prefix, handler) {\r\n    if (handler === void 0) { handler = this.handler.bind(this); }\r\n    return {\r\n      method: \"GET\",\r\n      path: new RegExp(\"^/events/\" + prefix + \"/([^/]+)$\"),\r\n      bodyFormat: \"stream\",\r\n      handler: handler\r\n    };\r\n  };\r\n  Journal.prototype.isEventStreamRequest = function (request) {\r\n    return request.headers.accept &&\r\n      request.headers.accept.match(/^text\\/event-stream/);\r\n  };\r\n  Journal.prototype.emitEvent = function (channel, type, msg, filter) {\r\n    if (filter === void 0) { filter = function (a) { return true; }; }\r\n    var ts = Date.now();\r\n    var id = this.entryIDs[channel]++;\r\n    var data = new JournalRecord(type, msg, id, ts);\r\n    var success = new Array(this.connections[channel].length);\r\n    this.connections[channel].forEach(function (conn, i) {\r\n      success[i] = !filter(conn) || conn.writeJournalRecord(data);\r\n    });\r\n    for (var i = success.length - 1; i > -1; i--) {\r\n      if (!success[i]) {\r\n        this.connections[channel].splice(i, 1);\r\n      }\r\n    }\r\n    this.records[channel].push(data);\r\n    this.cleanJournal(data.Timestamp, channel);\r\n    return data;\r\n  };\r\n  Journal.prototype.repeater = function (request, response, state) {\r\n    var conn = { request: request, response: response, state: state };\r\n    var channel = state.params[0];\r\n    this.initJournal(channel);\r\n    var event = state.params[1];\r\n    var data = this.emitEvent(channel, event, state.data, this.repeaterFilter(conn));\r\n    response.writeHead(200);\r\n    response.write(data.EventIDString);\r\n    response.end();\r\n  };\r\n  Journal.prototype.repeaterExports = function (method, prefix, handler) {\r\n    if (handler === void 0) { handler = this.repeater.bind(this); }\r\n    return {\r\n      bodyFormat: \"string\",\r\n      method: method,\r\n      handler: handler,\r\n      path: new RegExp(\"^/events/\" + prefix + \"/([^/]+)/([^/]+)$\")\r\n    };\r\n  };\r\n  return Journal;\r\n}());\r\nexports.Journal = Journal;\r\nvar JournalRecord = /** @class */ (function () {\r\n  function JournalRecord(Type, Data, EntryID, Timestamp) {\r\n    this.Type = Type;\r\n    this.Data = Data;\r\n    this.EntryID = EntryID;\r\n    this.Timestamp = Timestamp;\r\n  }\r\n  Object.defineProperty(JournalRecord.prototype, \"EventIDString\", {\r\n    get: function () {\r\n      return this.Timestamp.toString() + this.EntryID.toString();\r\n    },\r\n    enumerable: false,\r\n    configurable: true\r\n  });\r\n  return JournalRecord;\r\n}());\r\nexports.JournalRecord = JournalRecord;\r\nvar SSEClient = /** @class */ (function () {\r\n  function SSEClient(request, response, state) {\r\n    this.request = request;\r\n    this.response = response;\r\n    this.state = state;\r\n    response.on(\"error\", this.onerror.bind(this));\r\n    response.on(\"close\", this.onclose.bind(this));\r\n  }\r\n  Object.defineProperty(SSEClient, \"retryInterval\", {\r\n    get: function () {\r\n      return $tw.Syncer.prototype.errorRetryInterval;\r\n    },\r\n    enumerable: false,\r\n    configurable: true\r\n  });\r\n  Object.defineProperty(SSEClient.prototype, \"channel\", {\r\n    get: function () {\r\n      return this.state.params[0];\r\n    },\r\n    enumerable: false,\r\n    configurable: true\r\n  });\r\n  SSEClient.prototype.onerror = function (err) {\r\n    console.log(\"response error\", err.message);\r\n    this.response.destroy();\r\n    this.onended && this.onended();\r\n  };\r\n  SSEClient.prototype.onclose = function () {\r\n    this.end();\r\n    this.onended && this.onended();\r\n  };\r\n  SSEClient.prototype.start = function (statusCode, headers, eventID) {\r\n    if (statusCode === void 0) { statusCode = 200; }\r\n    if (headers === void 0) { headers = {}; }\r\n    if (eventID === void 0) { eventID = \"\"; }\r\n    if (this.ended()) {\r\n      return false;\r\n    }\r\n    this.response.writeHead(statusCode, $tw.utils.extend({\r\n      \"Content-Type\": \"text/event-stream\",\r\n      \"Cache-Control\": \"no-cache\",\r\n      'Connection': 'keep-alive',\r\n      // According to https://serverfault.com/questions/801628/for-server-sent-events-sse-what-nginx-proxy-configuration-is-appropriate\r\n      'X-Accel-Buffering': 'no',\r\n    }, headers));\r\n    // write the retry interval and event id immediately\r\n    this.write(\"\", \"\", eventID);\r\n    // setTimeout(() => { this.end(); }, 10000);\r\n    return true;\r\n  };\r\n  SSEClient.prototype.writeJournalRecord = function (data) {\r\n    return this.write(data.Type, data.Data, data.EventIDString);\r\n  };\r\n  SSEClient.prototype.write = function (event, data, eventID) {\r\n    if (this.ended()) {\r\n      return false;\r\n    }\r\n    if (typeof event !== \"string\" || event.indexOf(\"\\n\") !== -1) {\r\n      throw new Error(\"Type must be a single-line string\");\r\n    }\r\n    if (typeof data !== \"string\") {\r\n      throw new Error(\"Data must be a string\");\r\n    }\r\n    this.response.write((event ? \"event: \" + event + \"\\n\" : \"\") +\r\n      (data ? data.split('\\n').map(function (e) { return \"data: \" + e + \"\\n\"; }).join('') : \"\") +\r\n      (eventID ? \"id: \" + eventID + \"\\n\" : \"\") +\r\n      (\"retry: \" + SSEClient.retryInterval.toString() + \"\\n\") +\r\n      \"\\n\", \"utf8\");\r\n    return true;\r\n  };\r\n  SSEClient.prototype.end = function () {\r\n    if (this.ended()) {\r\n      return false;\r\n    }\r\n    this.response.end();\r\n    return true;\r\n  };\r\n  SSEClient.prototype.ended = function () {\r\n    var res = false;\r\n    if (typeof this.response.writableEnded === \"boolean\") {\r\n      res = res || this.response.writableEnded;\r\n    }\r\n    else if (typeof this.response.finished === \"boolean\") {\r\n      res = res || this.response.finished;\r\n    }\r\n    return res;\r\n  };\r\n  return SSEClient;\r\n}());\r\nexports.SSEClient = SSEClient;\r\n","type":"application/javascript","module-type":"library"},"$:/plugins/twcloud/tiddlyweb-sse/sse-client.js":{"title":"$:/plugins/twcloud/tiddlyweb-sse/sse-client.js","text":"/*\\\r\ntitle: $:/plugins/twcloud/tiddlyweb-sse/sse-client.js\r\ntype: application/javascript\r\nmodule-type: startup\r\n\r\nMiscellaneous startup logic for both the client and server.\r\n\r\n\\*/\r\n(function() {\r\n\r\n/*jslint node: true, browser: true */\r\n/*global $tw: false */\r\n\"use strict\";\r\nvar checks = [\r\n\t\"$:/status/IsLoggedIn\",\r\n\t\"$:/status/UserName\",\r\n\t\"$:/status/IsAnonymous\",\r\n\t\"$:/status/IsReadOnly\"\r\n];\r\n// Export name and synchronous status\r\nexports.name = \"tiddlyweb-sse-hook\";\r\nexports.after = [\"startup\"];\r\nexports.platforms = [\"browser\"];\r\nexports.synchronous = true;\r\nexports.startup = function() {\r\n\tvar source = null;\r\n\tif(!$tw.syncer || !$tw.syncer.syncadaptor || $tw.syncer.syncadaptor.name !== \"tiddlyweb\") {return;}\r\n\t$tw.wiki.addEventListener(\"change\",function(changes) {\r\n\t\tif(checks.filter(e => changes[e]).length === 0) {return;}\r\n\t\t// check if we have a previous one and close it if we do\r\n\t\tif(source && source.readyState !== source.CLOSED) {source.close();}\r\n\t\t// Get the mount point in case a path prefix is used\r\n\t\tvar host = $tw.syncer.syncadaptor.getHost();\r\n\t\t// Make sure it ends with a slash (it usually does)\r\n\t\tif(host[host.length - 1] !== \"/\") {host += \"/\";}\r\n\t\t// get the endpoint \r\n\t\tvar endpoint = host + \"events/plugins/twcloud/tiddlyweb-sse/wiki-change\";\r\n\t\t// set the syncer poll to one hour\r\n\t\t$tw.syncer.pollTimerInterval = 1000 * 60 * 60;\r\n\t\t// Setup the event listener\r\n\t\tsource = exports.setupSSE(endpoint,$tw.syncer);\r\n\t});\r\n}\r\n\r\nfunction debounce(interval,callback) {\r\n\tvar timeout = null;\r\n\treturn function() {\r\n\t\tclearTimeout(timeout);\r\n\t\ttimeout = setTimeout(callback,interval);\r\n\t};\r\n}\r\n\r\nexports.setupSSE = function setupSSE(endpoint,syncer,refresh) {\r\n\tif(window.EventSource) {\r\n\t\tvar source = new EventSource(endpoint,{withCredentials: true});\r\n\t\tvar debouncedSync = debounce(syncer.throttleInterval,syncer.syncFromServer.bind(syncer));\r\n\t\tsource.addEventListener(\"change\",debouncedSync);\r\n\t\tsource.onerror = function() {\r\n\t\t\t// return if we're reconnecting because that's handled automatically\r\n\t\t\tif(source.readyState === source.CONNECTING) {return;}\r\n\t\t\t// wait for the errorRetryInterval\r\n\t\t\tsetTimeout(function() {\r\n\t\t\t\t//call this function to set everything up again\r\n\t\t\t\texports.setupSSE(endpoint,syncer,true);\r\n\t\t\t},syncer.errorRetryInterval);\r\n\t\t};\r\n\t\tsource.onopen = function() {\r\n\t\t\t// only run this on first open, not on auto reconnect\r\n\t\t\tsource.onopen = function() {};\r\n\t\t\t// once we've properly opened, disable polling\r\n\t\t\tsyncer.wiki.addTiddler({title: syncer.titleSyncDisablePolling,text: \"yes\"});\r\n\t\t\t//sync from server manually here to make sure we stay up to date\r\n\t\t\tif(refresh) {syncer.syncFromServer();}\r\n\t\t}\r\n\t\treturn source;\r\n\t} else {\r\n\t\treturn null;\r\n\t}\r\n}\r\n\r\n})();\r\n","type":"application/javascript","module-type":"startup"},"$:/plugins/twcloud/tiddlyweb-sse/sse-server.js":{"title":"$:/plugins/twcloud/tiddlyweb-sse/sse-server.js","text":"/*\\\r\ntitle: $:/plugins/twcloud/tiddlyweb-sse/sse-server.js\r\ntype: application/javascript\r\nmodule-type: route\r\n\r\nGET /events/plugins/twcloud/tiddlyweb/(channel)\r\n\r\n\\*/\r\n(function() {\r\n\r\n/*jslint node: true, browser: true */\r\n/*global $tw: false */\r\n\"use strict\";\r\n\r\nvar wikis = [];\r\n\r\n// Import the Journal class\r\nvar Journal = require(\"$:/core/modules/server/server-sent-events.js\").Journal;\r\n\r\n/*\r\nSetup up the array for this wiki and add the change listener\r\n*/\r\nfunction setupWiki(wiki) {\r\n\tfunction filter(conn) {\r\n\t\treturn conn.state.wiki === wiki;\r\n\t}\r\n\t// Listen to change events for this wiki\r\n\twiki.addEventListener(\"change\",function(changes) {\r\n\t\tvar jsonChanges = JSON.stringify(changes);\r\n\t\teventServer.emitEvent(\"wiki-change\",\"change\",jsonChanges,filter);\r\n\t});\r\n\twikis.push(wiki);\r\n}\r\n\r\n/*\r\nSetup this particular wiki if we haven't seen it before\r\n*/\r\nfunction ensureChannelSetup(channel,wiki) {\r\n\t// setup wikis for the wiki-change channel\r\n\tif(channel === \"wiki-change\" && wikis.indexOf(wiki) === -1) { setupWiki(wiki); }\r\n}\r\n/** @type {import('../server-sent-events').Journal} */\r\nvar eventServer = new Journal();\r\n\r\n// this filter is called for the emitter route, which recieves \r\n// messages from clients and forwards them to all listeners. It \r\n// does not affect messages sent directly by the server. \r\n// We don't use it in tiddlyweb so just set it to false\r\neventServer.emitterFilter = function(sender) {\r\n\t// do not allow clients to broadcast\r\n\t// they can't anyway unless a route is specified\r\n\treturn function() { return false; };\r\n}\r\n\r\nif(!$tw.wiki.getTiddler(\"$:/plugins/tiddlywiki/tiddlyweb\")) {\r\n\t$tw.utils.warning(\"Warning: Plugin \\\"twcloud/tiddlyweb-sse\\\" specified but \\\"tiddlywiki/tiddlyweb\\\" is missing\");\r\n}\r\n\r\n// Export the route definition for this server sent events handler. \r\n// We don't need an emitter route, otherwise we could put the common \r\n// instance in a library tiddler export and require it in both files.\r\n\r\nmodule.exports = eventServer.handlerExports(\r\n\t\"plugins/twcloud/tiddlyweb-sse\",\r\n\tfunction(request,response,state) {\r\n\t\tif(state.params[0] !== \"wiki-change\") {\r\n\t\t\tresponse.writeHead(404);\r\n\t\t\tresponse.end();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// remove the socket timeout\r\n\t\trequest.setTimeout(0);\r\n\t\tensureChannelSetup(state.params[0],state.wiki);\r\n\t\teventServer.handler(request,response,state);\r\n\t}\r\n);\r\n})();","type":"application/javascript","module-type":"route"}}}