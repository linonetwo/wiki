{"tiddlers":{"$:/plugins/twcloud/tiddlyweb-sse/readme":{"title":"$:/plugins/twcloud/tiddlyweb-sse/readme","text":"This plugin runs in both the browser and server to sync changes immediately instead of waiting for polling. It adds a route to the server which sends server-sent events to the client, and loads an EventSource in the client to call $tw.syncer.syncFromServer(). \n\n[[Source code|https://github.com/twcloud/tiddlyweb-sse]]\n\n"},"$:/core/modules/server/server-sent-events.js":{"title":"$:/core/modules/server/server-sent-events.js","text":"\"use strict\";\n\n/*jslint node: true, browser: true */\n\n/*global $tw: false */\n\nObject.defineProperty(exports,\"__esModule\",{value: true});\n\nexports.SSEClient = exports.JournalRecord = exports.Journal = void 0;\n\nvar Journal = /** @class */ (function() {\n\n function Journal(JOURNALAGE) {\n\n  if(JOURNALAGE === void 0) {JOURNALAGE = 5 * 60 * 1000;}\n\n  this.JOURNALAGE = JOURNALAGE;\n\n  this.connections = {};\n\n  this.entryIDs = {};\n\n  this.records = {};\n\n  this.responseHeaders = {};\n\n  this.repeaterFilter = function(conn) {return function(conn) {return true;};};\n\n }\n\n Journal.prototype.cleanJournal = function(ts,channel) {\n\n  var maxage = ts - this.JOURNALAGE;\n\n  while(this.records[channel][0].Timestamp < maxage) {\n\n   this.records[channel].shift();\n\n  }\n\n };\n\n Journal.prototype.initJournal = function(key) {\n\n  if(!this.connections[key]) {\n\n   this.connections[key] = [];\n\n  }\n\n  if(!this.records[key]) {\n\n   this.records[key] = [new JournalRecord(\"\",\"\",0,Date.now())];\n\n  }\n\n  if(!this.entryIDs[key]) {\n\n   this.entryIDs[key] = 1;\n\n  }\n\n };\n\n Journal.prototype.handleConnection = function(conn) {\n\n  var channel = conn.channel;\n\n  this.initJournal(channel);\n\n  if(conn.request.headers[\"last-event-id\"]) {\n\n   var id = conn.request.headers[\"last-event-id\"];\n\n   var found = false;\n\n   // find the specified event ID the client last recieved and return everything since then\n\n   for(var i = 0; i < this.records[channel].length; i++) {\n\n    var tag = this.records[channel][i].EventIDString;\n\n    // return all records after the record that was found\n\n    if(found) {\n\n     conn.writeJournalRecord(this.records[channel][i]);\n\n    }\n\n    // we don't need to send the tag here because it is a reconnect and already has it\n\n    else if(tag === id) {\n\n     found = true;\n\n     conn.start(200,this.responseHeaders);\n\n    }\n\n   }\n\n   // If not found return 409 Conflict since that event id is not found\n\n   // this way the client can retry manually if needed.\n\n   if(found == false) {\n\n    conn.start(409);\n\n    conn.end();\n\n    return;\n\n   }\n\n  }\n\n  else {\n\n   var index = this.records[channel].length - 1;\n\n   var latest = index > -1 ? this.records[channel][index] : null;\n\n   conn.start(200,this.responseHeaders,latest === null || latest === void 0 ? void 0 : latest.EventIDString);\n\n  }\n\n  this.connections[channel].push(conn);\n\n  conn.onended = this.handleConnectionEnded.bind(this,conn);\n\n };\n\n Journal.prototype.handleConnectionEnded = function(conn) {\n\n  this.connections[conn.channel].splice(this.connections[conn.channel].indexOf(conn),1);\n\n };\n\n Journal.prototype.handler = function(request,response,state) {\n\n  if(true /* this.isEventStreamRequest(request) */) {\n\n   this.handleConnection(new SSEClient(request,response,state));\n\n  }\n\n  else {\n\n   response.writeHead(406,\"Not Acceptable\");\n\n   response.end();\n\n  }\n\n };\n\n Journal.prototype.handlerExports = function(prefix,handler) {\n\n  if(handler === void 0) {handler = this.handler.bind(this);}\n\n  return {\n\n   method: \"GET\",\n\n   path: new RegExp(\"^/events/\" + prefix + \"/([^/]+)$\"),\n\n   bodyFormat: \"stream\",\n\n   handler: handler\n\n  };\n\n };\n\n Journal.prototype.isEventStreamRequest = function(request) {\n\n  return request.headers.accept &&\n\n   request.headers.accept.match(/^text\\/event-stream/);\n\n };\n\n Journal.prototype.emitEvent = function(channel,type,msg,filter) {\n\n  if(filter === void 0) {filter = function(a) {return true;};}\n\n  var ts = Date.now();\n\n  var id = this.entryIDs[channel]++;\n\n  var data = new JournalRecord(type,msg,id,ts);\n\n  var success = new Array(this.connections[channel].length);\n\n  this.connections[channel].forEach(function(conn,i) {\n\n   success[i] = !filter(conn) || conn.writeJournalRecord(data);\n\n  });\n\n  for(var i = success.length - 1; i > -1; i--) {\n\n   if(!success[i]) {\n\n    this.connections[channel].splice(i,1);\n\n   }\n\n  }\n\n  this.records[channel].push(data);\n\n  this.cleanJournal(data.Timestamp,channel);\n\n  return data;\n\n };\n\n Journal.prototype.repeater = function(request,response,state) {\n\n  var conn = {request: request,response: response,state: state};\n\n  var channel = state.params[0];\n\n  this.initJournal(channel);\n\n  var event = state.params[1];\n\n  var data = this.emitEvent(channel,event,state.data,this.repeaterFilter(conn));\n\n  response.writeHead(200);\n\n  response.write(data.EventIDString);\n\n  response.end();\n\n };\n\n Journal.prototype.repeaterExports = function(method,prefix,handler) {\n\n  if(handler === void 0) {handler = this.repeater.bind(this);}\n\n  return {\n\n   bodyFormat: \"string\",\n\n   method: method,\n\n   handler: handler,\n\n   path: new RegExp(\"^/events/\" + prefix + \"/([^/]+)/([^/]+)$\")\n\n  };\n\n };\n\n return Journal;\n\n}());\n\nexports.Journal = Journal;\n\nvar JournalRecord = /** @class */ (function() {\n\n function JournalRecord(Type,Data,EntryID,Timestamp) {\n\n  this.Type = Type;\n\n  this.Data = Data;\n\n  this.EntryID = EntryID;\n\n  this.Timestamp = Timestamp;\n\n }\n\n Object.defineProperty(JournalRecord.prototype,\"EventIDString\",{\n\n  get: function() {\n\n   return this.Timestamp.toString() + this.EntryID.toString();\n\n  },\n\n  enumerable: false,\n\n  configurable: true\n\n });\n\n return JournalRecord;\n\n}());\n\nexports.JournalRecord = JournalRecord;\n\nvar SSEClient = /** @class */ (function() {\n\n function SSEClient(request,response,state) {\n\n  this.request = request;\n\n  this.response = response;\n\n  this.state = state;\n\n  response.on(\"error\",this.onerror.bind(this));\n\n  response.on(\"close\",this.onclose.bind(this));\n\n }\n\n Object.defineProperty(SSEClient,\"retryInterval\",{\n\n  get: function() {\n\n   return $tw.Syncer.prototype.errorRetryInterval;\n\n  },\n\n  enumerable: false,\n\n  configurable: true\n\n });\n\n Object.defineProperty(SSEClient.prototype,\"channel\",{\n\n  get: function() {\n\n   return this.state.params[0];\n\n  },\n\n  enumerable: false,\n\n  configurable: true\n\n });\n\n SSEClient.prototype.onerror = function(err) {\n\n  console.log(\"response error\",err.message);\n\n  this.response.destroy();\n\n  this.onended && this.onended();\n\n };\n\n SSEClient.prototype.onclose = function() {\n\n  this.end();\n\n  this.onended && this.onended();\n\n };\n\n SSEClient.prototype.start = function(statusCode,headers,eventID) {\n\n  if(statusCode === void 0) {statusCode = 200;}\n\n  if(headers === void 0) {headers = {};}\n\n  if(eventID === void 0) {eventID = \"\";}\n\n  if(this.ended()) {\n\n   return false;\n\n  }\n\n  this.response.writeHead(statusCode,$tw.utils.extend({\n\n   \"Content-Type\": \"text/event-stream\",\n\n   \"Cache-Control\": \"no-cache\",\n\n   'Connection': 'keep-alive',\n\n  },headers));\n\n  // write the retry interval and event id immediately\n\n  this.write(\"\",\"\",eventID);\n\n  // setTimeout(() => { this.end(); }, 10000);\n\n  return true;\n\n };\n\n SSEClient.prototype.writeJournalRecord = function(data) {\n\n  return this.write(data.Type,data.Data,data.EventIDString);\n\n };\n\n SSEClient.prototype.write = function(event,data,eventID) {\n\n  if(this.ended()) {\n\n   return false;\n\n  }\n\n  if(typeof event !== \"string\" || event.indexOf(\"\\n\") !== -1) {\n\n   throw new Error(\"Type must be a single-line string\");\n\n  }\n\n  if(typeof data !== \"string\") {\n\n   throw new Error(\"Data must be a string\");\n\n  }\n\n  this.response.write((event ? \"event: \" + event + \"\\n\" : \"\") +\n\n   (data ? data.split('\\n').map(function(e) {return \"data: \" + e + \"\\n\";}).join('') : \"\") +\n\n   (eventID ? \"id: \" + eventID + \"\\n\" : \"\") +\n\n   (\"retry: \" + SSEClient.retryInterval.toString() + \"\\n\") +\n\n   \"\\n\",\"utf8\");\n\n  return true;\n\n };\n\n SSEClient.prototype.end = function() {\n\n  if(this.ended()) {\n\n   return false;\n\n  }\n\n  this.response.end();\n\n  return true;\n\n };\n\n SSEClient.prototype.ended = function() {\n\n  var res = false;\n\n  if(typeof this.response.writableEnded === \"boolean\") {\n\n   res = res || this.response.writableEnded;\n\n  }\n\n  else if(typeof this.response.finished === \"boolean\") {\n\n   res = res || this.response.finished;\n\n  }\n\n  return res;\n\n };\n\n return SSEClient;\n\n}());\n\nexports.SSEClient = SSEClient;\n\n","type":"application/javascript","module-type":"library"},"$:/plugins/twcloud/tiddlyweb-sse/sse-client.js":{"title":"$:/plugins/twcloud/tiddlyweb-sse/sse-client.js","text":"/*\\\n\ntitle: $:/plugins/twcloud/tiddlyweb-sse/sse-client.js\n\ntype: application/javascript\n\nmodule-type: startup\n\n\n\nMiscellaneous startup logic for both the client and server.\n\n\n\n\\*/\n\n(function() {\n\n\n\n/*jslint node: true, browser: true */\n\n/*global $tw: false */\n\n\"use strict\";\n\nvar checks = [\n\n \"$:/status/IsLoggedIn\",\n\n \"$:/status/UserName\",\n\n \"$:/status/IsAnonymous\",\n\n \"$:/status/IsReadOnly\"\n\n];\n\n// Export name and synchronous status\n\nexports.name = \"tiddlyweb-sse-hook\";\n\nexports.after = [\"startup\"];\n\nexports.platforms = [\"browser\"];\n\nexports.synchronous = true;\n\nexports.startup = function() {\n\n var source = null;\n\n if($tw.syncer.syncadaptor.name !== \"tiddlyweb\") {return;}\n\n $tw.wiki.addEventListener(\"change\",function(changes) {\n\n  if(checks.filter(e => changes[e]).length === 0) {return;}\n\n  // check if we have a previous one and close it if we do\n\n  if(source && source.readyState !== source.CLOSED) {source.close();}\n\n  // Get the mount point in case a path prefix is used\n\n  var host = $tw.syncer.syncadaptor.getHost();\n\n  // Make sure it ends with a slash (it usually does)\n\n  if(host[host.length - 1] !== \"/\") {host += \"/\";}\n\n  // get the endpoint \n\n  var endpoint = host + \"events/plugins/twcloud/tiddlyweb-sse/wiki-change\";\n\n  // set the syncer poll to one hour\n\n  $tw.syncer.pollTimerInterval = 1000 * 60 * 60;\n\n  // Setup the event listener\n\n  source = exports.setupSSE(endpoint,$tw.syncer);\n\n });\n\n}\n\n\n\nfunction debounce(interval,callback) {\n\n var timeout = null;\n\n return function() {\n\n  clearTimeout(timeout);\n\n  timeout = setTimeout(callback,interval);\n\n };\n\n}\n\n\n\nexports.setupSSE = function setupSSE(endpoint,syncer,refresh) {\n\n if(window.EventSource) {\n\n  var source = new EventSource(endpoint,{withCredentials: true});\n\n  var debouncedSync = debounce(syncer.throttleInterval,syncer.syncFromServer.bind(syncer));\n\n  source.addEventListener(\"change\",debouncedSync);\n\n  source.onerror = function() {\n\n   // return if we're reconnecting because that's handled automatically\n\n   if(source.readyState === source.CONNECTING) {return;}\n\n   // wait for the errorRetryInterval\n\n   setTimeout(function() {\n\n    //call this function to set everything up again\n\n    exports.setupSSE(endpoint,syncer,true);\n\n   },syncer.errorRetryInterval);\n\n  };\n\n  source.onopen = function() {\n\n   // only run this on first open, not on auto reconnect\n\n   source.onopen = function() {};\n\n   // once we've properly opened, disable polling\n\n   syncer.wiki.addTiddler({title: syncer.titleSyncDisablePolling,text: \"yes\"});\n\n   //sync from server manually here to make sure we stay up to date\n\n   if(refresh) {syncer.syncFromServer();}\n\n  }\n\n  return source;\n\n } else {\n\n  return null;\n\n }\n\n}\n\n\n\n})();","type":"application/javascript","module-type":"startup"},"$:/plugins/twcloud/tiddlyweb-sse/sse-server.js":{"title":"$:/plugins/twcloud/tiddlyweb-sse/sse-server.js","text":"/*\\\n\ntitle: $:/plugins/twcloud/tiddlyweb-sse/sse-server.js\n\ntype: application/javascript\n\nmodule-type: route\n\n\n\nGET /events/plugins/twcloud/tiddlyweb/(channel)\n\n\n\n\\*/\n\n(function() {\n\n\n\n/*jslint node: true, browser: true */\n\n/*global $tw: false */\n\n\"use strict\";\n\n\n\nvar wikis = [];\n\n\n\n// Import the Journal class\n\nvar Journal = require(\"$:/core/modules/server/server-sent-events.js\").Journal;\n\n\n\n/*\n\nSetup up the array for this wiki and add the change listener\n\n*/\n\nfunction setupWiki(wiki) {\n\n function filter(conn) {\n\n  return conn.state.wiki === wiki;\n\n }\n\n // Listen to change events for this wiki\n\n wiki.addEventListener(\"change\",function(changes) {\n\n  var jsonChanges = JSON.stringify(changes);\n\n  eventServer.emitEvent(\"wiki-change\",\"change\",jsonChanges,filter);\n\n });\n\n wikis.push(wiki);\n\n}\n\n\n\n/*\n\nSetup this particular wiki if we haven't seen it before\n\n*/\n\nfunction ensureChannelSetup(channel,wiki) {\n\n // setup wikis for the wiki-change channel\n\n if(channel === \"wiki-change\" && wikis.indexOf(wiki) === -1) { setupWiki(wiki); }\n\n}\n\n/** @type {import('../server-sent-events').Journal} */\n\nvar eventServer = new Journal();\n\n\n\n// this filter is called for the emitter route, which recieves \n\n// messages from clients and forwards them to all listeners. It \n\n// does not affect messages sent directly by the server. \n\n// We don't use it in tiddlyweb so just set it to false\n\neventServer.emitterFilter = function(sender) {\n\n // do not allow clients to broadcast\n\n // they can't anyway unless a route is specified\n\n return function() { return false; };\n\n}\n\n\n\nif(!$tw.wiki.getTiddler(\"$:/plugins/tiddlywiki/tiddlyweb\")) {\n\n $tw.utils.warning(\"Warning: Plugin \\\"twcloud/tiddlyweb-sse\\\" specified but \\\"tiddlywiki/tiddlyweb\\\" is missing\");\n\n}\n\n\n\n// Export the route definition for this server sent events handler. \n\n// We don't need an emitter route, otherwise we could put the common \n\n// instance in a library tiddler export and require it in both files.\n\n\n\nmodule.exports = eventServer.handlerExports(\n\n \"plugins/twcloud/tiddlyweb-sse\",\n\n function(request,response,state) {\n\n  if(state.params[0] !== \"wiki-change\") {\n\n   response.writeHead(404);\n\n   response.end();\n\n   return;\n\n  }\n\n  // remove the socket timeout\n\n  request.setTimeout(0);\n\n  ensureChannelSetup(state.params[0],state.wiki);\n\n  eventServer.handler(request,response,state);\n\n }\n\n);\n\n})();","type":"application/javascript","module-type":"route"}}}