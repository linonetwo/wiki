{"tiddlers":{"$:/language/Docs/Types/application/tldr":{"title":"$:/language/Docs/Types/application/tldr","description":"Tldraw白板","name":"application/tldr","group":"图像"},"$:/plugins/linonetwo/itonnote/Startup/registerFileType.js":{"title":"$:/plugins/linonetwo/itonnote/Startup/registerFileType.js","text":"$tw.utils.registerFileType(\"application/tldr\",\"utf8\",\".tldr\");","module-type":"startup","type":"application/javascript"},"dist/plugins/linonetwo/tw-whiteboard/components/App.css":{"title":"dist/plugins/linonetwo/tw-whiteboard/components/App.css","text":".tw-whiteboard-tldraw-container {\n  width: 100%;\n  height: 500px;\n  position: relative;\n  /** don't overlap with other dropdown */\n  z-index: 0;\n}\n\n.tw-whiteboard-tldraw-container button:not(.tc-btn-invisible) {\n  padding: unset;\n  margin: unset;\n  border-radius: unset;\n  background-color: unset;\n}"},"$:/themes/linonetwo/tw-whiteboard/useStyleVariables.css":{"title":"$:/themes/linonetwo/tw-whiteboard/useStyleVariables.css","text":".tl-container{--tl-zoom:1;--tl-scale:calc(1 / var(--tl-zoom));--tl-padding:calc(64px * max(1, var(--tl-scale)));--tl-performance-all:auto;--tl-performance-selected:auto;position:relative;top:0;left:0;width:100%;height:100%;max-width:100%;max-height:100%;box-sizing:border-box;padding:0;margin:0;z-index:100;overflow:hidden;touch-action:none;overscroll-behavior:none;background-color:var(--tl-background)}.tl-container *{box-sizing:border-box}.tl-overlay{position:absolute;width:100%;height:100%;touch-action:none;pointer-events:none}.tl-grid{position:absolute;width:100%;height:100%;touch-action:none;pointer-events:none;user-select:none}.tl-snap-line,.tl-snap-point{stroke:var(--tl-accent);stroke-width:calc(1px * var(--tl-scale))}.tl-canvas{position:absolute;width:100%;height:100%;touch-action:none;pointer-events:all;overflow:clip}.tl-layer{position:absolute;top:0;left:0;height:0;width:0;contain:layout style size}.tl-absolute{position:absolute;top:0;left:0;transform-origin:center center;contain:layout style size}.tl-positioned{position:absolute;top:0;left:0;transform-origin:center center;pointer-events:none;display:flex;align-items:center;justify-content:center;contain:layout style size;will-change:var(--tl-performance-all)}.tl-positioned-svg{width:100%;height:100%;overflow:hidden;contain:layout style size}.tl-positioned-div{position:relative;width:100%;height:100%;padding:var(--tl-padding);overflow:hidden;contain:layout style size}.tl-positioned-selected{will-change:var(--tl-performance-selected)}.tl-inner-div{position:relative;width:100%;height:100%}.tl-stroke-hitarea{fill:none;stroke:transparent;stroke-width:calc(24px * var(--tl-scale));pointer-events:stroke;stroke-linecap:round;stroke-linejoin:round}.tl-fill-hitarea{fill:transparent;stroke:transparent;stroke-width:calc(24px * var(--tl-scale));pointer-events:all;stroke-linecap:round;stroke-linejoin:round}.tl-counter-scaled{transform:scale(var(--tl-scale))}.tl-dashed{stroke-dasharray:calc(2px * var(--tl-scale)),calc(2px * var(--tl-scale))}.tl-transparent{fill:transparent;stroke:transparent}.tl-cursor-ns{cursor:ns-resize}.tl-cursor-ew{cursor:ew-resize}.tl-cursor-nesw{cursor:nesw-resize}.tl-cursor-nwse{cursor:nwse-resize}.tl-corner-handle{stroke:var(--tl-selectStroke);fill:var(--tl-background);stroke-width:calc(1.5px * var(--tl-scale))}.tl-rotate-handle{stroke:var(--tl-selectStroke);fill:var(--tl-background);stroke-width:calc(1.5px * var(--tl-scale));cursor:grab}.tl-binding{fill:var(--tl-selectFill);stroke:var(--tl-selectStroke);stroke-width:calc(1px * var(--tl-scale));pointer-events:none}.tl-user{left:calc(-15px * var(--tl-scale));top:calc(-15px * var(--tl-scale));height:calc(35px * var(--tl-scale));width:calc(35px * var(--tl-scale));transform:scale(var(--tl-scale));pointer-events:none;will-change:transform}.tl-animated{transition:transform .2s linear}.tl-indicator{fill:transparent;stroke-width:calc(1.5px * var(--tl-scale));pointer-events:none}.tl-user-indicator-bounds{border-style:solid;border-width:calc(1px * var(--tl-scale))}.tl-hovered,.tl-selected{stroke:var(--tl-selectStroke)}.tl-locked{stroke-dasharray:calc(3px * var(--tl-scale)) calc(3px * var(--tl-scale))}.tl-editing{stroke-width:calc(2.5px * min(5,var(--tl-scale)))}.tl-performance{will-change:transform,contents}.tl-clone-target{pointer-events:all}.tl-clone-target:hover .tl-clone-button{opacity:1}.tl-clone-button-target{cursor:pointer;pointer-events:all}.tl-clone-button-target:hover .tl-clone-button{fill:var(--tl-selectStroke)}.tl-clone-button{opacity:0;r:calc(8px * var(--tl-scale));stroke-width:calc(1.5px * var(--tl-scale));stroke:var(--tl-selectStroke);fill:var(--tl-background)}.tl-bounds{pointer-events:none;contain:layout style size}.tl-bounds-bg{stroke:none;fill:var(--tl-selectFill);pointer-events:all;contain:layout style size}.tl-bounds-center{fill:transparent;stroke:var(--tl-selectStroke);stroke-width:calc(1.5px * var(--tl-scale))}.tl-brush{fill:var(--tl-brushFill);stroke:var(--tl-brushStroke);stroke-width:calc(1px * var(--tl-scale));pointer-events:none;contain:layout style size}.tl-dashed-brush-line{fill:none;stroke:var(--tl-brushDashStroke);stroke-width:calc(1px * var(--tl-scale));pointer-events:none}.tl-brush.dashed{stroke:none}.tl-handle{pointer-events:all;cursor:grab;fill:var(--tl-background);stroke:var(--tl-selectStroke);stroke-width:1.5px}.tl-handle:hover .tl-handle-bg{fill:var(--tl-selectFill)}.tl-handle:hover .tl-handle-bg>*{stroke:var(--tl-selectFill)}.tl-handle:active .tl-handle-bg{cursor:grabbing;fill:var(--tl-selectFill)}.tl-handle:active .tl-handle-bg>*{stroke:var(--tl-selectFill)}.tl-handle-bg{fill:transparent;stroke:none;pointer-events:all;r:calc(16px / max(1,var(--tl-zoom)))}.tl-binding-indicator{fill:transparent;stroke:var(--tl-binding)}.tl-centered-g{transform:translate(var(--tl-padding),var(--tl-padding))}.tl-current-parent>[data-shy=true]{opacity:1}.tl-binding{fill:none;stroke:var(--tl-selectStroke);stroke-width:calc(2px * var(--tl-scale))}.tl-grid-dot{fill:var(--tl-grid)}.tl-erase-line{stroke-linejoin:round;stroke-linecap:round;pointer-events:none;fill:var(--tl-grid);opacity:.32}","tags":"$:/tags/Stylesheet","type":"text/css"},"$:/plugins/linonetwo/tw-whiteboard/readme":{"title":"$:/plugins/linonetwo/tw-whiteboard/readme","creator":"LinOnetwo","type":"text/vnd.tiddlywiki","text":"Tiny little drawing app in TW, using tldraw. Providing diagram widget and whiteboard view. \n"},"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/EditTemplate/body/EditTemplateBody.css":{"title":"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/EditTemplate/body/EditTemplateBody.css","text":".tw-whiteboard-edit-body-container {\n  width: 100%;\n  height: 100%;\n  margin-bottom: 20px;\n}","type":"text/vnd.tiddlywiki","tags":"$:/tags/Stylesheet"},"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/EditTemplate/body/edit-whiteboard-cascade-filter":{"title":"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/EditTemplate/body/edit-whiteboard-cascade-filter","tags":"$:/tags/EditTemplateBodyFilter","list-before":"$:/config/EditTemplateBodyFilters/default","text":"[field:type[application/tldr]then[$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/EditTemplate/body/edit-whiteboard]]"},"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/EditTemplate/body/edit-whiteboard":{"title":"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/EditTemplate/body/edit-whiteboard","text":"\\define lingo-base() $:/language/EditTemplate/Body/\n\n<div class=\"tw-whiteboard-edit-body-container\">\n<!-- always get real tiddler title, prevent getting `\"Draft of 'AAA'\"` from <<currentTiddler>> when in draft mode. -->\n<$set name=\"tiddler\" value={{!!draft.title}} emptyValue=<<currentTiddler>>>\n<$edit-whiteboard tiddler=<<tiddler>> draftTitle={{!!draft.title}} height=\"500px\" />\n</$set>\n</div>"},"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/PageLayout/CreateNewTiddlerPopup":{"title":"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/PageLayout/CreateNewTiddlerPopup","text":"<div class=\"tw-whiteboard-layout-create-new-tiddler-popup\">\n  <$edit-text focus=\"yes\" tiddler=\"$:/state/Whiteboard/PageLayout/create-tiddler\" default=\"\" rows=1 />\n  <$button>\n    Create\n    <$action-createtiddler $basetitle={{$:/state/Whiteboard/PageLayout/create-tiddler}} type=\"application/tldr\" />\n    <$action-setfield $tiddler=\"$:/state/Whiteboard/PageLayout/create-tiddler\" text=\"\"/>\n  </$button>\n</div>"},"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/PageLayout/WhiteBoardLayout.css":{"title":"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/PageLayout/WhiteBoardLayout.css","text":".tw-whiteboard-layout-top-bar {\n  position: absolute;\n  z-index: 1;\n  top: 0;\n\n  width: 400px;\n  left: calc(50% - 400px / 2);\n  padding: 5px;\n\n  background-color: rgba(255, 255, 255, 0.5);\n  backdrop-filter: blur(5px);\n\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n.tw-whiteboard-layout-top-bar > select {\n  max-width: 200px;\n}\n\n.tw-whiteboard-layout-main-area {\n}\n\ndiv.tw-whiteboard-layout-container {\n  margin-top: 0px;\n}\n.tw-whiteboard-layout-container p {\n  margin: 0;\n}\n\n.tw-whiteboard-layout-create-new-tiddler-popup {\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  width: 200px;\n}\n.tw-whiteboard-layout-create-new-tiddler-popup button {\n  width: 100%;\n}\n.tw-whiteboard-layout-create-new-tiddler-popup textarea {\n  width: 100%;\n}\n","type":"text/vnd.tiddlywiki","tags":"$:/tags/Stylesheet"},"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/PageLayout/WhiteBoard":{"title":"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/PageLayout/WhiteBoard","name":"White Board","description":"show `application/tldr` type tiddlers in full screen whiteboard","tags":"$:/tags/Layout","text":"\\whitespace trim\n\\define containerClasses()\ntc-page-container tc-page-view-$(storyviewTitle)$ tc-language-$(languageTitle)$ tw-whiteboard-layout-container\n\\end\n\\import [[$:/core/ui/PageMacros]] [all[shadows+tiddlers]tag[$:/tags/Macro]!has[draft.of]]\n\n<$vars\n\ttv-config-toolbar-icons={{$:/config/Toolbar/Icons}}\n\ttv-config-toolbar-text={{$:/config/Toolbar/Text}}\n\ttv-config-toolbar-class={{$:/config/Toolbar/ButtonClass}}\n\ttv-show-missing-links={{$:/config/MissingLinks}}\n\tstoryviewTitle={{$:/view}}\n\tlanguageTitle={{{ [{$:/language}get[name]] }}}>\n\n<div class=<<containerClasses>>>\n\n<$navigator story=\"$:/StoryList\" history=\"$:/HistoryList\" openLinkFromInsideRiver={{$:/config/Navigation/openLinkFromInsideRiver}} openLinkFromOutsideRiver={{$:/config/Navigation/openLinkFromOutsideRiver}} relinkOnRename={{$:/config/RelinkOnRename}}>\n\n<main class=\"tw-whiteboard-layout-main-area\">\n\t<$reveal state=\"$:/state/Whiteboard/PageLayout/tiddler\" type=\"nomatch\" text=\"\">\n\t\t<$whiteboard tiddler={{$:/state/Whiteboard/PageLayout/tiddler}} height=\"calc(100vh - 35px)\" />\n\t</$reveal>\n\t<!-- default value, when first opened, select widget's state tiddler is empty, but default value filter gives a value, we show that tiddler -->\n\t<$reveal state=\"$:/state/Whiteboard/PageLayout/tiddler\" type=\"match\" text=\"\">\n\t\t<$list filter='[all[shadows+tiddlers]field:type[application/tldr]sort[modified]first[]]'>\n\t\t\t<$whiteboard tiddler={{{[all[shadows+tiddlers]field:type[application/tldr]sort[modified]first[]]}}} height=\"calc(100vh - 35px)\" />\n\t\t</$list>\n\t</$reveal>\n</main>\n\n<!-- put this below main, so nav bar is layered on top of the main. In UI, this nav in on the top of the page. -->\n<nav class=\"tw-whiteboard-layout-top-bar\">\n\tSelect board: \n\t<!-- default to recently used whiteboard tiddler -->\n\t<$select tiddler=\"$:/state/Whiteboard/PageLayout/tiddler\" default={{{[all[shadows+tiddlers]field:type[application/tldr]sort[modified]first[]]}}}>\n\t\t<$list filter='[all[shadows+tiddlers]field:type[application/tldr]sort[modified]]'>\n\t\t\t<option value=<<currentTiddler>>><$view field='title'/></option>\n\t\t</$list>\n\t</$select>\n\n\t<$button tooltip=\"New\" popup=\"$:/state/Whiteboard/PageLayout/CreateNewTiddlerPopup\">{{$:/core/images/new-button}}</$button>\n\t<$reveal type=\"popup\" state=\"$:/state/Whiteboard/PageLayout/CreateNewTiddlerPopup\">\n\t\t{{$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/PageLayout/CreateNewTiddlerPopup}}\n\t</$reveal>\n\n\t<$reveal state=\"$:/state/Whiteboard/PageLayout/tiddler\" type=\"nomatch\" text=\"\">\n\t\t<$button tooltip=\"Open In StoryView\">\n\t\t\t{{$:/core/images/home-button}}\n\t\t\t<$action-setfield $tiddler=\"$:/layout\" text=\"$:/core/ui/PageTemplate\"/>\n\t\t\t<$action-navigate $to={{$:/state/Whiteboard/PageLayout/tiddler}}/>\n\t\t</$button>\n\t</$reveal>\n\t<!-- default value, when first opened, select widget's state tiddler is empty, but default value filter gives a value, we show that tiddler -->\n\t<$reveal state=\"$:/state/Whiteboard/PageLayout/tiddler\" type=\"match\" text=\"\">\n\t\t<$list filter='[all[shadows+tiddlers]field:type[application/tldr]sort[modified]first[]]'>\n\t\t\t<$button tooltip=\"Open In StoryView\">\n\t\t\t\t{{$:/core/images/home-button}}\n\t\t\t\t<$action-setfield $tiddler=\"$:/layout\" text=\"$:/core/ui/PageTemplate\"/>\n\t\t\t\t<$action-navigate $to={{{[all[shadows+tiddlers]field:type[application/tldr]sort[modified]first[]]}}} />\n\t\t\t</$button>\n\t\t</$list>\n\t</$reveal>\n</nav>\n\n</$navigator>\n\n</div>\n\n</$vars>"},"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/ViewTemplate/body/view-whiteboard-cascade-filter":{"title":"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/ViewTemplate/body/view-whiteboard-cascade-filter","tags":"$:/tags/ViewTemplateBodyFilter","list-before":"$:/config/ViewTemplateBodyFilters/system","text":"[field:type[application/tldr]then[$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/ViewTemplate/body/view-whiteboard]]"},"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/ViewTemplate/body/view-whiteboard":{"title":"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/ViewTemplate/body/view-whiteboard","text":"\\define lingo-base() $:/language/ViewTemplate/Body/\n\n<$whiteboard tiddler=<<currentTiddler>> readonly=\"yes\" height=\"500px\" />\n"},"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/ViewToolbar/Buttons/OpenInFullScreenWhiteBoardButton":{"title":"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/ViewToolbar/Buttons/OpenInFullScreenWhiteBoardButton","tags":"$:/tags/ViewToolbar","caption":"{{$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/ViewToolbar/images/OpenInFullScreenWhiteBoardButtonImage}} {{$:/language/Buttons/Edit/Caption}}","description":"{{$:/language/Buttons/Edit/Hint}}","text":"\\whitespace trim\n<$list filter=\"[<currentTiddler>field:type[application/tldr]]\" variable=\"ignore\">\n  <$button tooltip={{$:/language/Buttons/Edit/Hint}} aria-label={{$:/language/Buttons/Edit/Caption}} class=<<tv-config-toolbar-class>> >\n    <$action-setfield $tiddler=\"$:/layout\" text=\"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/PageLayout/WhiteBoard\"/>\n    <$action-setfield $tiddler=\"$:/state/Whiteboard/PageLayout/tiddler\" text=<<currentTiddler>> />\n\n    <$list filter=\"[<tv-config-toolbar-icons>match[yes]]\">\n      {{$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/ViewToolbar/images/OpenInFullScreenWhiteBoardButtonImage}}\n    </$list>\n    <$list filter=\"[<tv-config-toolbar-text>match[yes]]\">\n      <span class=\"tc-btn-text\">\n        <$text text={{$:/language/Buttons/Edit/Caption}}/>\n      </span>\n    </$list>\n  </$button>\n</$list>"},"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/ViewToolbar/images/OpenInFullScreenWhiteBoardButtonImage":{"title":"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/ViewToolbar/images/OpenInFullScreenWhiteBoardButtonImage","tags":"$:/tags/Image","text":"<svg width=\"22pt\" height=\"22pt\" class=\"tc-image-edit-button tc-image-whiteboard-edit-button tc-image-button\" viewBox=\"0 0 128 128\">\n  <g fill-rule=\"evenodd\">\n    <g id=\"svg_1\" fill-rule=\"evenodd\">\n      <path id=\"svg_2\"\n        d=\"m95.627,10.059l-5.656,5.657l11.313,11.313l5.657,-5.656l-11.314,-11.314zm5.657,-5.657l1.966,-1.966c3.123,-3.122 8.194,-3.129 11.319,-0.005c3.117,3.118 3.122,8.192 -0.005,11.32l-1.966,1.965l-11.314,-11.314zm-16.97,16.97l-60.25,60.25a8.12,8.12 0 0 0 -0.322,0.342c-0.1,0.087 -0.198,0.179 -0.295,0.275c-5.735,5.735 -10.702,22.016 -10.702,22.016s16.405,-5.09 22.016,-10.702c0.095,-0.096 0.186,-0.193 0.272,-0.292a8.12,8.12 0 0 0 0.345,-0.325l60.25,-60.25l-11.314,-11.313l0,-0.001zm-49.143,102.818c6.788,-0.577 13.898,-2.272 23.689,-5.348c1.825,-0.573 3.57,-1.136 6.336,-2.04c16,-5.226 21.877,-6.807 28.745,-7.146c8.358,-0.413 13.854,2.13 17.58,8.699a4,4 0 0 0 6.959,-3.946c-5.334,-9.406 -13.745,-13.296 -24.933,-12.744c-7.875,0.39 -14.057,2.052 -30.835,7.533c-2.739,0.894 -4.46,1.45 -6.25,2.012c-19.46,6.112 -30.77,7.072 -39.597,1.747a4,4 0 1 0 -4.132,6.85c6.333,3.82 13.754,5.12 22.438,4.383z\" />\n    </g>\n    <text xml:space=\"preserve\" text-anchor=\"start\" font-family=\"Noto Sans JP\" font-size=\"108\" id=\"svg_11\" y=\"89\" x=\"2\"\n      stroke-width=\"0\">Bo</text>\n  </g>\n</svg>"},"$:/plugins/linonetwo/tw-whiteboard/widget-loader.js":{"title":"$:/plugins/linonetwo/tw-whiteboard/widget-loader.js","text":"!function(){if(!$tw.browser)return;const t=require(\"$:/plugins/linonetwo/tw-whiteboard/widget.js\"),{whiteboard:e}=t;exports.whiteboard=e,exports[\"edit-whiteboard\"]=e}();","type":"application/javascript","module-type":"widget"},"$:/plugins/linonetwo/tw-whiteboard/widget.css":{"title":"$:/plugins/linonetwo/tw-whiteboard/widget.css","text":"/* src/components/App.css */\n.tw-whiteboard-tldraw-container {\n  width: 100%;\n  height: 500px;\n  position: relative;\n  z-index: 0;\n}\n.tw-whiteboard-tldraw-container button:not(.tc-btn-invisible) {\n  padding: unset;\n  margin: unset;\n  border-radius: unset;\n  background-color: unset;\n}\n","type":"text/vnd.tiddlywiki","tags":"$:/tags/Stylesheet"},"$:/plugins/linonetwo/tw-whiteboard/widget.js":{"title":"$:/plugins/linonetwo/tw-whiteboard/widget.js","text":"\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n// node_modules/lodash.debounce/index.js\nvar require_lodash = __commonJS({\n  \"node_modules/lodash.debounce/index.js\"(exports2, module2) {\n    var FUNC_ERROR_TEXT = \"Expected a function\";\n    var NAN = 0 / 0;\n    var symbolTag = \"[object Symbol]\";\n    var reTrim = /^\\s+|\\s+$/g;\n    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n    var reIsBinary = /^0b[01]+$/i;\n    var reIsOctal = /^0o[0-7]+$/i;\n    var freeParseInt = parseInt;\n    var freeGlobal = typeof global == \"object\" && global && global.Object === Object && global;\n    var freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\n    var root = freeGlobal || freeSelf || Function(\"return this\")();\n    var objectProto = Object.prototype;\n    var objectToString = objectProto.toString;\n    var nativeMax = Math.max;\n    var nativeMin = Math.min;\n    var now = function() {\n      return root.Date.now();\n    };\n    function debounce2(func, wait, options) {\n      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;\n      if (typeof func != \"function\") {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      wait = toNumber(wait) || 0;\n      if (isObject(options)) {\n        leading = !!options.leading;\n        maxing = \"maxWait\" in options;\n        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n        trailing = \"trailing\" in options ? !!options.trailing : trailing;\n      }\n      function invokeFunc(time) {\n        var args = lastArgs, thisArg = lastThis;\n        lastArgs = lastThis = void 0;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n      }\n      function leadingEdge(time) {\n        lastInvokeTime = time;\n        timerId = setTimeout(timerExpired, wait);\n        return leading ? invokeFunc(time) : result;\n      }\n      function remainingWait(time) {\n        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;\n        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;\n      }\n      function shouldInvoke(time) {\n        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;\n        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n      }\n      function timerExpired() {\n        var time = now();\n        if (shouldInvoke(time)) {\n          return trailingEdge(time);\n        }\n        timerId = setTimeout(timerExpired, remainingWait(time));\n      }\n      function trailingEdge(time) {\n        timerId = void 0;\n        if (trailing && lastArgs) {\n          return invokeFunc(time);\n        }\n        lastArgs = lastThis = void 0;\n        return result;\n      }\n      function cancel() {\n        if (timerId !== void 0) {\n          clearTimeout(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = void 0;\n      }\n      function flush() {\n        return timerId === void 0 ? result : trailingEdge(now());\n      }\n      function debounced() {\n        var time = now(), isInvoking = shouldInvoke(time);\n        lastArgs = arguments;\n        lastThis = this;\n        lastCallTime = time;\n        if (isInvoking) {\n          if (timerId === void 0) {\n            return leadingEdge(lastCallTime);\n          }\n          if (maxing) {\n            timerId = setTimeout(timerExpired, wait);\n            return invokeFunc(lastCallTime);\n          }\n        }\n        if (timerId === void 0) {\n          timerId = setTimeout(timerExpired, wait);\n        }\n        return result;\n      }\n      debounced.cancel = cancel;\n      debounced.flush = flush;\n      return debounced;\n    }\n    function isObject(value) {\n      var type = typeof value;\n      return !!value && (type == \"object\" || type == \"function\");\n    }\n    function isObjectLike(value) {\n      return !!value && typeof value == \"object\";\n    }\n    function isSymbol(value) {\n      return typeof value == \"symbol\" || isObjectLike(value) && objectToString.call(value) == symbolTag;\n    }\n    function toNumber(value) {\n      if (typeof value == \"number\") {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      if (isObject(value)) {\n        var other = typeof value.valueOf == \"function\" ? value.valueOf() : value;\n        value = isObject(other) ? other + \"\" : other;\n      }\n      if (typeof value != \"string\") {\n        return value === 0 ? value : +value;\n      }\n      value = value.replace(reTrim, \"\");\n      var isBinary = reIsBinary.test(value);\n      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n    }\n    module2.exports = debounce2;\n  }\n});\n\n// node_modules/tw-react/dist/plugins/linonetwo/tw-react/index.js\nvar require_tw_react = __commonJS({\n  \"node_modules/tw-react/dist/plugins/linonetwo/tw-react/index.js\"(exports2, module2) {\n    \"use strict\";\n    var __defProp2 = Object.defineProperty;\n    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;\n    var __getOwnPropNames2 = Object.getOwnPropertyNames;\n    var __hasOwnProp2 = Object.prototype.hasOwnProperty;\n    var __export = (target, all) => {\n      for (var name in all)\n        __defProp2(target, name, { get: all[name], enumerable: true });\n    };\n    var __copyProps2 = (to, from, except, desc) => {\n      if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of __getOwnPropNames2(from))\n          if (!__hasOwnProp2.call(to, key) && key !== except)\n            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });\n      }\n      return to;\n    };\n    var __toCommonJS = (mod) => __copyProps2(__defProp2({}, \"__esModule\", { value: true }), mod);\n    var src_exports = {};\n    __export(src_exports, {\n      ParentWidgetContext: () => ParentWidgetContext2,\n      useFilter: () => useFilter,\n      useRenderTiddler: () => useRenderTiddler,\n      useWidget: () => useWidget2\n    });\n    module2.exports = __toCommonJS(src_exports);\n    var import_react43 = require(\"react\");\n    function useFilter(twFilter, widget = $tw.rootWidget, dependencies = []) {\n      const [filterResult, setFilterResult] = (0, import_react43.useState)([]);\n      const compiledFilter = (0, import_react43.useMemo)(() => $tw.wiki.compileFilter(twFilter), [twFilter]);\n      (0, import_react43.useEffect)(() => {\n        setFilterResult(compiledFilter(void 0, widget));\n      }, [compiledFilter, widget, ...dependencies]);\n      return filterResult;\n    }\n    var import_react310 = require(\"react\");\n    var import_react210 = require(\"react\");\n    var ParentWidgetContext2 = (0, import_react210.createContext)(void 0);\n    function useRenderTiddler(tiddlerTitle, containerReference, options) {\n      const parentWidget = (0, import_react310.useContext)(ParentWidgetContext2);\n      (0, import_react310.useEffect)(() => {\n        const domNode = containerReference.current;\n        if (domNode === null) {\n          return;\n        }\n        if (parentWidget === void 0) {\n          throw new Error(\n            \"Your plugin have a bug: `parentWidget` is undefined, you should use `<ParentWidgetContext.Provider value={props.parentWidget}>`, see tw-react for document.\"\n          );\n        }\n        if (options?.skip === true) {\n          return;\n        }\n        const id = String(Math.random());\n        const transcludeWidgetNode = $tw.wiki.makeTranscludeWidget(tiddlerTitle, {\n          document,\n          parentWidget,\n          recursionMarker: \"yes\",\n          mode: \"block\",\n          importPageMacros: true,\n          variables: { \"use-widget-id\": id }\n        });\n        const tiddlerContainer = document.createElement(\"div\");\n        domNode.append(tiddlerContainer);\n        transcludeWidgetNode.render(tiddlerContainer, null);\n        parentWidget.children.push(transcludeWidgetNode);\n        return () => {\n          parentWidget.children = parentWidget.children.filter((child) => child.getVariable(\"use-widget-id\") !== id);\n          if (domNode === null) {\n            return;\n          }\n          domNode.textContent = \"\";\n        };\n      }, [tiddlerTitle, containerReference]);\n    }\n    var import_react44 = require(\"react\");\n    function useWidget2(parseTreeNode, containerReference, options) {\n      const parentWidget = (0, import_react44.useContext)(ParentWidgetContext2);\n      (0, import_react44.useEffect)(() => {\n        const domNode = containerReference.current;\n        if (domNode === null) {\n          return;\n        }\n        if (parentWidget === void 0) {\n          throw new Error(\n            \"Your plugin have a bug: `parentWidget` is undefined, you should use `<ParentWidgetContext.Provider value={props.parentWidget}>`, see tw-react for document.\"\n          );\n        }\n        if (options?.skip === true) {\n          return;\n        }\n        const id = String(Math.random());\n        const newWidgetNode = parentWidget.makeChildWidget(parseTreeNode, { variables: { \"use-widget-id\": id } });\n        newWidgetNode.render(domNode, null);\n        parentWidget.children.push(newWidgetNode);\n        return () => {\n          parentWidget.children = parentWidget.children.filter((child) => child.getVariable(\"use-widget-id\") !== id);\n          if (domNode === null) {\n            return;\n          }\n          domNode.textContent = \"\";\n        };\n      }, [parseTreeNode, containerReference, parentWidget, options?.skip]);\n    }\n  }\n});\n\n// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\nvar require_use_sync_external_store_shim_development = __commonJS({\n  \"node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\"(exports2) {\n    \"use strict\";\n    if (true) {\n      (function() {\n        \"use strict\";\n        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n        }\n        var React50 = require(\"react\");\n        var ReactSharedInternals = React50.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n          {\n            {\n              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                args[_key2 - 1] = arguments[_key2];\n              }\n              printWarning(\"error\", format, args);\n            }\n          }\n        }\n        function printWarning(level, format, args) {\n          {\n            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n            var stack = ReactDebugCurrentFrame.getStackAddendum();\n            if (stack !== \"\") {\n              format += \"%s\";\n              args = args.concat([stack]);\n            }\n            var argsWithFormat = args.map(function(item) {\n              return String(item);\n            });\n            argsWithFormat.unshift(\"Warning: \" + format);\n            Function.prototype.apply.call(console[level], console, argsWithFormat);\n          }\n        }\n        function is(x5, y6) {\n          return x5 === y6 && (x5 !== 0 || 1 / x5 === 1 / y6) || x5 !== x5 && y6 !== y6;\n        }\n        var objectIs = typeof Object.is === \"function\" ? Object.is : is;\n        var useState15 = React50.useState, useEffect24 = React50.useEffect, useLayoutEffect11 = React50.useLayoutEffect, useDebugValue2 = React50.useDebugValue;\n        var didWarnOld18Alpha = false;\n        var didWarnUncachedGetSnapshot = false;\n        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n          {\n            if (!didWarnOld18Alpha) {\n              if (React50.startTransition !== void 0) {\n                didWarnOld18Alpha = true;\n                error(\"You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.\");\n              }\n            }\n          }\n          var value = getSnapshot();\n          {\n            if (!didWarnUncachedGetSnapshot) {\n              var cachedValue = getSnapshot();\n              if (!objectIs(value, cachedValue)) {\n                error(\"The result of getSnapshot should be cached to avoid an infinite loop\");\n                didWarnUncachedGetSnapshot = true;\n              }\n            }\n          }\n          var _useState = useState15({\n            inst: {\n              value,\n              getSnapshot\n            }\n          }), inst = _useState[0].inst, forceUpdate = _useState[1];\n          useLayoutEffect11(function() {\n            inst.value = value;\n            inst.getSnapshot = getSnapshot;\n            if (checkIfSnapshotChanged(inst)) {\n              forceUpdate({\n                inst\n              });\n            }\n          }, [subscribe, value, getSnapshot]);\n          useEffect24(function() {\n            if (checkIfSnapshotChanged(inst)) {\n              forceUpdate({\n                inst\n              });\n            }\n            var handleStoreChange = function() {\n              if (checkIfSnapshotChanged(inst)) {\n                forceUpdate({\n                  inst\n                });\n              }\n            };\n            return subscribe(handleStoreChange);\n          }, [subscribe]);\n          useDebugValue2(value);\n          return value;\n        }\n        function checkIfSnapshotChanged(inst) {\n          var latestGetSnapshot = inst.getSnapshot;\n          var prevValue = inst.value;\n          try {\n            var nextValue = latestGetSnapshot();\n            return !objectIs(prevValue, nextValue);\n          } catch (error2) {\n            return true;\n          }\n        }\n        function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\n          return getSnapshot();\n        }\n        var canUseDOM = !!(typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\");\n        var isServerEnvironment = !canUseDOM;\n        var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;\n        var useSyncExternalStore$2 = React50.useSyncExternalStore !== void 0 ? React50.useSyncExternalStore : shim;\n        exports2.useSyncExternalStore = useSyncExternalStore$2;\n        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n        }\n      })();\n    }\n  }\n});\n\n// node_modules/use-sync-external-store/shim/index.js\nvar require_shim = __commonJS({\n  \"node_modules/use-sync-external-store/shim/index.js\"(exports2, module2) {\n    \"use strict\";\n    if (false) {\n      module2.exports = null;\n    } else {\n      module2.exports = require_use_sync_external_store_shim_development();\n    }\n  }\n});\n\n// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js\nvar require_with_selector_development = __commonJS({\n  \"node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js\"(exports2) {\n    \"use strict\";\n    if (true) {\n      (function() {\n        \"use strict\";\n        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n        }\n        var React50 = require(\"react\");\n        var shim = require_shim();\n        function is(x5, y6) {\n          return x5 === y6 && (x5 !== 0 || 1 / x5 === 1 / y6) || x5 !== x5 && y6 !== y6;\n        }\n        var objectIs = typeof Object.is === \"function\" ? Object.is : is;\n        var useSyncExternalStore = shim.useSyncExternalStore;\n        var useRef26 = React50.useRef, useEffect24 = React50.useEffect, useMemo14 = React50.useMemo, useDebugValue2 = React50.useDebugValue;\n        function useSyncExternalStoreWithSelector2(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {\n          var instRef = useRef26(null);\n          var inst;\n          if (instRef.current === null) {\n            inst = {\n              hasValue: false,\n              value: null\n            };\n            instRef.current = inst;\n          } else {\n            inst = instRef.current;\n          }\n          var _useMemo = useMemo14(function() {\n            var hasMemo = false;\n            var memoizedSnapshot;\n            var memoizedSelection;\n            var memoizedSelector = function(nextSnapshot) {\n              if (!hasMemo) {\n                hasMemo = true;\n                memoizedSnapshot = nextSnapshot;\n                var _nextSelection = selector(nextSnapshot);\n                if (isEqual !== void 0) {\n                  if (inst.hasValue) {\n                    var currentSelection = inst.value;\n                    if (isEqual(currentSelection, _nextSelection)) {\n                      memoizedSelection = currentSelection;\n                      return currentSelection;\n                    }\n                  }\n                }\n                memoizedSelection = _nextSelection;\n                return _nextSelection;\n              }\n              var prevSnapshot = memoizedSnapshot;\n              var prevSelection = memoizedSelection;\n              if (objectIs(prevSnapshot, nextSnapshot)) {\n                return prevSelection;\n              }\n              var nextSelection = selector(nextSnapshot);\n              if (isEqual !== void 0 && isEqual(prevSelection, nextSelection)) {\n                return prevSelection;\n              }\n              memoizedSnapshot = nextSnapshot;\n              memoizedSelection = nextSelection;\n              return nextSelection;\n            };\n            var maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;\n            var getSnapshotWithSelector = function() {\n              return memoizedSelector(getSnapshot());\n            };\n            var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : function() {\n              return memoizedSelector(maybeGetServerSnapshot());\n            };\n            return [getSnapshotWithSelector, getServerSnapshotWithSelector];\n          }, [getSnapshot, getServerSnapshot, selector, isEqual]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];\n          var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);\n          useEffect24(function() {\n            inst.hasValue = true;\n            inst.value = value;\n          }, [value]);\n          useDebugValue2(value);\n          return value;\n        }\n        exports2.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector2;\n        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n        }\n      })();\n    }\n  }\n});\n\n// node_modules/use-sync-external-store/shim/with-selector.js\nvar require_with_selector = __commonJS({\n  \"node_modules/use-sync-external-store/shim/with-selector.js\"(exports2, module2) {\n    \"use strict\";\n    if (false) {\n      module2.exports = null;\n    } else {\n      module2.exports = require_with_selector_development();\n    }\n  }\n});\n\n// src/components/App.tsx\nvar import_react42 = require(\"react\");\n\n// node_modules/beautiful-react-hooks/esm/useDebouncedCallback.js\nvar import_react3 = require(\"react\");\nvar import_lodash = __toESM(require_lodash());\n\n// node_modules/beautiful-react-hooks/esm/useWillUnmount.js\nvar import_react2 = require(\"react\");\n\n// node_modules/beautiful-react-hooks/esm/shared/isFunction.js\nvar isFunction = (functionToCheck) => !!(typeof functionToCheck === \"function\" && !!functionToCheck.constructor && !!functionToCheck.call && !!functionToCheck.apply);\nvar isFunction_default = isFunction;\n\n// node_modules/beautiful-react-hooks/esm/factory/createHandlerSetter.js\nvar import_react = require(\"react\");\nvar createHandlerSetter = (callback) => {\n  const handlerRef = (0, import_react.useRef)(callback);\n  const setHandler = (0, import_react.useRef)((nextCallback) => {\n    if (typeof nextCallback !== \"function\") {\n      throw new Error(\"the argument supplied to the 'setHandler' function should be of type function\");\n    }\n    handlerRef.current = nextCallback;\n  });\n  return [handlerRef, setHandler.current];\n};\nvar createHandlerSetter_default = createHandlerSetter;\n\n// node_modules/beautiful-react-hooks/esm/useWillUnmount.js\nvar useWillUnmount = (callback) => {\n  const mountRef = (0, import_react2.useRef)(false);\n  const [handler, setHandler] = createHandlerSetter_default(callback);\n  (0, import_react2.useEffect)(() => {\n    mountRef.current = true;\n    return () => {\n      if (isFunction_default(handler === null || handler === void 0 ? void 0 : handler.current) && mountRef.current) {\n        handler.current();\n      }\n    };\n  }, []);\n  return setHandler;\n};\nvar useWillUnmount_default = useWillUnmount;\n\n// node_modules/beautiful-react-hooks/esm/useDebouncedCallback.js\nvar defaultOptions = {\n  leading: false,\n  trailing: true\n};\nvar useDebouncedCallback = (fn2, dependencies, wait = 600, options = defaultOptions) => {\n  const debounced = (0, import_react3.useRef)((0, import_lodash.default)(fn2, wait, options));\n  (0, import_react3.useEffect)(() => {\n    debounced.current = (0, import_lodash.default)(fn2, wait, options);\n  }, [fn2, wait, options]);\n  useWillUnmount_default(() => {\n    var _a;\n    (_a = debounced.current) === null || _a === void 0 ? void 0 : _a.cancel();\n  });\n  return (0, import_react3.useCallback)(debounced.current, dependencies);\n};\nvar useDebouncedCallback_default = useDebouncedCallback;\n\n// src/components/Tldraw/Tldraw.tsx\nvar React49 = __toESM(require(\"react\"));\n\n// node_modules/@tldraw/core/dist/index.mjs\nvar N2 = __toESM(require(\"react\"), 1);\nvar D2 = __toESM(require(\"react\"), 1);\nvar z2 = __toESM(require(\"react\"), 1);\nvar Ye = __toESM(require(\"react\"), 1);\nvar Se2 = __toESM(require(\"react\"), 1);\n\n// node_modules/@tldraw/vec/dist/index.mjs\nvar h = Object.defineProperty;\nvar d = (s5, n5, r5) => n5 in s5 ? h(s5, n5, { enumerable: true, configurable: true, writable: true, value: r5 }) : s5[n5] = r5;\nvar m = (s5, n5, r5) => (d(s5, typeof n5 != \"symbol\" ? n5 + \"\" : n5, r5), r5);\nvar t = class {\n  static clamp(n5, r5, u5) {\n    return Math.max(r5, typeof u5 != \"undefined\" ? Math.min(n5, u5) : n5);\n  }\n  static clampV(n5, r5, u5) {\n    return n5.map((b6) => u5 ? t.clamp(b6, r5, u5) : t.clamp(b6, r5));\n  }\n  static cross(n5, r5, u5) {\n    return (r5[0] - n5[0]) * (u5[1] - n5[1]) - (u5[0] - n5[0]) * (r5[1] - n5[1]);\n  }\n  static snap(n5, r5 = 1) {\n    return [Math.round(n5[0] / r5) * r5, Math.round(n5[1] / r5) * r5];\n  }\n};\nvar e = t;\nm(e, \"neg\", (n5) => [-n5[0], -n5[1]]), m(e, \"add\", (n5, r5) => [n5[0] + r5[0], n5[1] + r5[1]]), m(e, \"addScalar\", (n5, r5) => [n5[0] + r5, n5[1] + r5]), m(e, \"sub\", (n5, r5) => [n5[0] - r5[0], n5[1] - r5[1]]), m(e, \"subScalar\", (n5, r5) => [n5[0] - r5, n5[1] - r5]), m(e, \"vec\", (n5, r5) => [r5[0] - n5[0], r5[1] - n5[1]]), m(e, \"mul\", (n5, r5) => [n5[0] * r5, n5[1] * r5]), m(e, \"mulV\", (n5, r5) => [n5[0] * r5[0], n5[1] * r5[1]]), m(e, \"div\", (n5, r5) => [n5[0] / r5, n5[1] / r5]), m(e, \"divV\", (n5, r5) => [n5[0] / r5[0], n5[1] / r5[1]]), m(e, \"per\", (n5) => [n5[1], -n5[0]]), m(e, \"dpr\", (n5, r5) => n5[0] * r5[0] + n5[1] * r5[1]), m(e, \"cpr\", (n5, r5) => n5[0] * r5[1] - r5[0] * n5[1]), m(e, \"len2\", (n5) => n5[0] * n5[0] + n5[1] * n5[1]), m(e, \"len\", (n5) => Math.hypot(n5[0], n5[1])), m(e, \"pry\", (n5, r5) => t.dpr(n5, r5) / t.len(r5)), m(e, \"uni\", (n5) => t.div(n5, t.len(n5))), m(e, \"normalize\", (n5) => t.uni(n5)), m(e, \"tangent\", (n5, r5) => t.uni(t.sub(n5, r5))), m(e, \"dist2\", (n5, r5) => t.len2(t.sub(n5, r5))), m(e, \"dist\", (n5, r5) => Math.hypot(n5[1] - r5[1], n5[0] - r5[0])), m(e, \"fastDist\", (n5, r5) => {\n  let u5 = [r5[0] - n5[0], r5[1] - n5[1]], b6 = [Math.abs(u5[0]), Math.abs(u5[1])], a7 = 1 / Math.max(b6[0], b6[1]);\n  return a7 = a7 * (1.29289 - (b6[0] + b6[1]) * a7 * 0.29289), [u5[0] * a7, u5[1] * a7];\n}), m(e, \"ang\", (n5, r5) => Math.atan2(t.cpr(n5, r5), t.dpr(n5, r5))), m(e, \"angle\", (n5, r5) => Math.atan2(r5[1] - n5[1], r5[0] - n5[0])), m(e, \"med\", (n5, r5) => t.mul(t.add(n5, r5), 0.5)), m(e, \"rot\", (n5, r5 = 0) => [n5[0] * Math.cos(r5) - n5[1] * Math.sin(r5), n5[0] * Math.sin(r5) + n5[1] * Math.cos(r5)]), m(e, \"rotWith\", (n5, r5, u5 = 0) => {\n  if (u5 === 0)\n    return n5;\n  let b6 = Math.sin(u5), a7 = Math.cos(u5), i4 = n5[0] - r5[0], o5 = n5[1] - r5[1], c5 = i4 * a7 - o5 * b6, l7 = i4 * b6 + o5 * a7;\n  return [c5 + r5[0], l7 + r5[1]];\n}), m(e, \"isEqual\", (n5, r5) => n5[0] === r5[0] && n5[1] === r5[1]), m(e, \"lrp\", (n5, r5, u5) => t.add(n5, t.mul(t.sub(r5, n5), u5))), m(e, \"int\", (n5, r5, u5, b6, a7 = 1) => {\n  let i4 = (t.clamp(u5, b6) - u5) / (b6 - u5);\n  return t.add(t.mul(n5, 1 - i4), t.mul(r5, a7));\n}), m(e, \"ang3\", (n5, r5, u5) => {\n  let b6 = t.vec(r5, n5), a7 = t.vec(r5, u5);\n  return t.ang(b6, a7);\n}), m(e, \"abs\", (n5) => [Math.abs(n5[0]), Math.abs(n5[1])]), m(e, \"rescale\", (n5, r5) => {\n  let u5 = t.len(n5);\n  return [r5 * n5[0] / u5, r5 * n5[1] / u5];\n}), m(e, \"isLeft\", (n5, r5, u5) => (r5[0] - n5[0]) * (u5[1] - n5[1]) - (u5[0] - n5[0]) * (r5[1] - n5[1])), m(e, \"clockwise\", (n5, r5, u5) => t.isLeft(n5, r5, u5) > 0), m(e, \"toFixed\", (n5) => n5.map((r5) => Math.round(r5 * 100) / 100)), m(e, \"nearestPointOnLineThroughPoint\", (n5, r5, u5) => t.add(n5, t.mul(r5, t.pry(t.sub(u5, n5), r5)))), m(e, \"distanceToLineThroughPoint\", (n5, r5, u5) => t.dist(u5, t.nearestPointOnLineThroughPoint(n5, r5, u5))), m(e, \"nearestPointOnLineSegment\", (n5, r5, u5, b6 = true) => {\n  let a7 = t.uni(t.sub(r5, n5)), i4 = t.add(n5, t.mul(a7, t.pry(t.sub(u5, n5), a7)));\n  if (b6) {\n    if (i4[0] < Math.min(n5[0], r5[0]))\n      return n5[0] < r5[0] ? n5 : r5;\n    if (i4[0] > Math.max(n5[0], r5[0]))\n      return n5[0] > r5[0] ? n5 : r5;\n    if (i4[1] < Math.min(n5[1], r5[1]))\n      return n5[1] < r5[1] ? n5 : r5;\n    if (i4[1] > Math.max(n5[1], r5[1]))\n      return n5[1] > r5[1] ? n5 : r5;\n  }\n  return i4;\n}), m(e, \"distanceToLineSegment\", (n5, r5, u5, b6 = true) => t.dist(u5, t.nearestPointOnLineSegment(n5, r5, u5, b6))), m(e, \"nearestPointOnBounds\", (n5, r5) => [t.clamp(r5[0], n5.minX, n5.maxX), t.clamp(r5[1], n5.minY, n5.maxY)]), m(e, \"distanceToBounds\", (n5, r5) => t.dist(r5, t.nearestPointOnBounds(n5, r5))), m(e, \"nudge\", (n5, r5, u5) => t.isEqual(n5, r5) ? n5 : t.add(n5, t.mul(t.uni(t.sub(r5, n5)), u5))), m(e, \"nudgeAtAngle\", (n5, r5, u5) => [Math.cos(r5) * u5 + n5[0], Math.sin(r5) * u5 + n5[1]]), m(e, \"toPrecision\", (n5, r5 = 4) => [+n5[0].toPrecision(r5), +n5[1].toPrecision(r5)]), m(e, \"pointsBetween\", (n5, r5, u5 = 6) => Array.from(Array(u5)).map((b6, a7) => {\n  let i4 = a7 / (u5 - 1), o5 = Math.min(1, 0.5 + Math.abs(0.5 - i4));\n  return [...t.lrp(n5, r5, i4), o5];\n})), m(e, \"slope\", (n5, r5) => n5[0] === r5[0] ? NaN : (n5[1] - r5[1]) / (n5[0] - r5[0])), m(e, \"max\", (...n5) => [Math.max(...n5.map((r5) => r5[0])), Math.max(...n5.map((r5) => r5[1]))]), m(e, \"min\", (...n5) => [Math.min(...n5.map((r5) => r5[0])), Math.min(...n5.map((r5) => r5[1]))]);\nvar p = e;\n\n// node_modules/@use-gesture/core/dist/maths-b28d9b98.esm.js\nfunction clamp(v6, min, max) {\n  return Math.max(min, Math.min(v6, max));\n}\nvar V = {\n  toVector(v6, fallback) {\n    if (v6 === void 0)\n      v6 = fallback;\n    return Array.isArray(v6) ? v6 : [v6, v6];\n  },\n  add(v1, v22) {\n    return [v1[0] + v22[0], v1[1] + v22[1]];\n  },\n  sub(v1, v22) {\n    return [v1[0] - v22[0], v1[1] - v22[1]];\n  },\n  addTo(v1, v22) {\n    v1[0] += v22[0];\n    v1[1] += v22[1];\n  },\n  subTo(v1, v22) {\n    v1[0] -= v22[0];\n    v1[1] -= v22[1];\n  }\n};\nfunction rubberband(distance, dimension, constant) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity)\n    return Math.pow(distance, constant * 5);\n  return distance * dimension * constant / (dimension + constant * distance);\n}\nfunction rubberbandIfOutOfBounds(position, min, max, constant = 0.15) {\n  if (constant === 0)\n    return clamp(position, min, max);\n  if (position < min)\n    return -rubberband(min - position, max - min, constant) + min;\n  if (position > max)\n    return +rubberband(position - max, max - min, constant) + max;\n  return position;\n}\nfunction computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {\n  const [[X0, X1], [Y0, Y1]] = bounds;\n  return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];\n}\n\n// node_modules/@use-gesture/core/dist/actions-e3d93fde.esm.js\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function(sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i4 = 1; i4 < arguments.length; i4++) {\n    var source = null != arguments[i4] ? arguments[i4] : {};\n    i4 % 2 ? ownKeys(Object(source), true).forEach(function(key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nvar EVENT_TYPE_MAP = {\n  pointer: {\n    start: \"down\",\n    change: \"move\",\n    end: \"up\"\n  },\n  mouse: {\n    start: \"down\",\n    change: \"move\",\n    end: \"up\"\n  },\n  touch: {\n    start: \"start\",\n    change: \"move\",\n    end: \"end\"\n  },\n  gesture: {\n    start: \"start\",\n    change: \"change\",\n    end: \"end\"\n  }\n};\nfunction capitalize(string) {\n  if (!string)\n    return \"\";\n  return string[0].toUpperCase() + string.slice(1);\n}\nvar actionsWithoutCaptureSupported = [\"enter\", \"leave\"];\nfunction hasCapture(capture = false, actionKey) {\n  return capture && !actionsWithoutCaptureSupported.includes(actionKey);\n}\nfunction toHandlerProp(device, action = \"\", capture = false) {\n  const deviceProps = EVENT_TYPE_MAP[device];\n  const actionKey = deviceProps ? deviceProps[action] || action : action;\n  return \"on\" + capitalize(device) + capitalize(actionKey) + (hasCapture(capture, actionKey) ? \"Capture\" : \"\");\n}\nvar pointerCaptureEvents = [\"gotpointercapture\", \"lostpointercapture\"];\nfunction parseProp(prop) {\n  let eventKey = prop.substring(2).toLowerCase();\n  const passive = !!~eventKey.indexOf(\"passive\");\n  if (passive)\n    eventKey = eventKey.replace(\"passive\", \"\");\n  const captureKey = pointerCaptureEvents.includes(eventKey) ? \"capturecapture\" : \"capture\";\n  const capture = !!~eventKey.indexOf(captureKey);\n  if (capture)\n    eventKey = eventKey.replace(\"capture\", \"\");\n  return {\n    device: eventKey,\n    capture,\n    passive\n  };\n}\nfunction toDomEventType(device, action = \"\") {\n  const deviceProps = EVENT_TYPE_MAP[device];\n  const actionKey = deviceProps ? deviceProps[action] || action : action;\n  return device + actionKey;\n}\nfunction isTouch(event) {\n  return \"touches\" in event;\n}\nfunction getPointerType(event) {\n  if (isTouch(event))\n    return \"touch\";\n  if (\"pointerType\" in event)\n    return event.pointerType;\n  return \"mouse\";\n}\nfunction getCurrentTargetTouchList(event) {\n  return Array.from(event.touches).filter((e5) => {\n    var _event$currentTarget, _event$currentTarget$;\n    return e5.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 ? void 0 : (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e5.target));\n  });\n}\nfunction getTouchList(event) {\n  return event.type === \"touchend\" || event.type === \"touchcancel\" ? event.changedTouches : event.targetTouches;\n}\nfunction getValueEvent(event) {\n  return isTouch(event) ? getTouchList(event)[0] : event;\n}\nfunction distanceAngle(P1, P22) {\n  const dx = P22.clientX - P1.clientX;\n  const dy = P22.clientY - P1.clientY;\n  const cx = (P22.clientX + P1.clientX) / 2;\n  const cy = (P22.clientY + P1.clientY) / 2;\n  const distance = Math.hypot(dx, dy);\n  const angle = -(Math.atan2(dx, dy) * 180) / Math.PI;\n  const origin = [cx, cy];\n  return {\n    angle,\n    distance,\n    origin\n  };\n}\nfunction touchIds(event) {\n  return getCurrentTargetTouchList(event).map((touch) => touch.identifier);\n}\nfunction touchDistanceAngle(event, ids) {\n  const [P1, P22] = Array.from(event.touches).filter((touch) => ids.includes(touch.identifier));\n  return distanceAngle(P1, P22);\n}\nfunction pointerId(event) {\n  const valueEvent = getValueEvent(event);\n  return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;\n}\nfunction pointerValues(event) {\n  const valueEvent = getValueEvent(event);\n  return [valueEvent.clientX, valueEvent.clientY];\n}\nvar LINE_HEIGHT = 40;\nvar PAGE_HEIGHT = 800;\nfunction wheelValues(event) {\n  let {\n    deltaX,\n    deltaY,\n    deltaMode\n  } = event;\n  if (deltaMode === 1) {\n    deltaX *= LINE_HEIGHT;\n    deltaY *= LINE_HEIGHT;\n  } else if (deltaMode === 2) {\n    deltaX *= PAGE_HEIGHT;\n    deltaY *= PAGE_HEIGHT;\n  }\n  return [deltaX, deltaY];\n}\nfunction scrollValues(event) {\n  var _ref, _ref2;\n  const {\n    scrollX,\n    scrollY,\n    scrollLeft,\n    scrollTop\n  } = event.currentTarget;\n  return [(_ref = scrollX !== null && scrollX !== void 0 ? scrollX : scrollLeft) !== null && _ref !== void 0 ? _ref : 0, (_ref2 = scrollY !== null && scrollY !== void 0 ? scrollY : scrollTop) !== null && _ref2 !== void 0 ? _ref2 : 0];\n}\nfunction getEventDetails(event) {\n  const payload = {};\n  if (\"buttons\" in event)\n    payload.buttons = event.buttons;\n  if (\"shiftKey\" in event) {\n    const {\n      shiftKey,\n      altKey,\n      metaKey,\n      ctrlKey\n    } = event;\n    Object.assign(payload, {\n      shiftKey,\n      altKey,\n      metaKey,\n      ctrlKey\n    });\n  }\n  return payload;\n}\nfunction call(v6, ...args) {\n  if (typeof v6 === \"function\") {\n    return v6(...args);\n  } else {\n    return v6;\n  }\n}\nfunction noop() {\n}\nfunction chain(...fns) {\n  if (fns.length === 0)\n    return noop;\n  if (fns.length === 1)\n    return fns[0];\n  return function() {\n    let result;\n    for (const fn2 of fns) {\n      result = fn2.apply(this, arguments) || result;\n    }\n    return result;\n  };\n}\nfunction assignDefault(value, fallback) {\n  return Object.assign({}, fallback, value || {});\n}\nvar BEFORE_LAST_KINEMATICS_DELAY = 32;\nvar Engine = class {\n  constructor(ctrl, args, key) {\n    this.ctrl = ctrl;\n    this.args = args;\n    this.key = key;\n    if (!this.state) {\n      this.state = {};\n      this.computeValues([0, 0]);\n      this.computeInitial();\n      if (this.init)\n        this.init();\n      this.reset();\n    }\n  }\n  get state() {\n    return this.ctrl.state[this.key];\n  }\n  set state(state) {\n    this.ctrl.state[this.key] = state;\n  }\n  get shared() {\n    return this.ctrl.state.shared;\n  }\n  get eventStore() {\n    return this.ctrl.gestureEventStores[this.key];\n  }\n  get timeoutStore() {\n    return this.ctrl.gestureTimeoutStores[this.key];\n  }\n  get config() {\n    return this.ctrl.config[this.key];\n  }\n  get sharedConfig() {\n    return this.ctrl.config.shared;\n  }\n  get handler() {\n    return this.ctrl.handlers[this.key];\n  }\n  reset() {\n    const {\n      state,\n      shared,\n      ingKey,\n      args\n    } = this;\n    shared[ingKey] = state._active = state.active = state._blocked = state._force = false;\n    state._step = [false, false];\n    state.intentional = false;\n    state._movement = [0, 0];\n    state._distance = [0, 0];\n    state._direction = [0, 0];\n    state._delta = [0, 0];\n    state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];\n    state.args = args;\n    state.axis = void 0;\n    state.memo = void 0;\n    state.elapsedTime = 0;\n    state.direction = [0, 0];\n    state.distance = [0, 0];\n    state.overflow = [0, 0];\n    state._movementBound = [false, false];\n    state.velocity = [0, 0];\n    state.movement = [0, 0];\n    state.delta = [0, 0];\n    state.timeStamp = 0;\n  }\n  start(event) {\n    const state = this.state;\n    const config = this.config;\n    if (!state._active) {\n      this.reset();\n      this.computeInitial();\n      state._active = true;\n      state.target = event.target;\n      state.currentTarget = event.currentTarget;\n      state.lastOffset = config.from ? call(config.from, state) : state.offset;\n      state.offset = state.lastOffset;\n    }\n    state.startTime = state.timeStamp = event.timeStamp;\n  }\n  computeValues(values) {\n    const state = this.state;\n    state._values = values;\n    state.values = this.config.transform(values);\n  }\n  computeInitial() {\n    const state = this.state;\n    state._initial = state._values;\n    state.initial = state.values;\n  }\n  compute(event) {\n    const {\n      state,\n      config,\n      shared\n    } = this;\n    state.args = this.args;\n    let dt2 = 0;\n    if (event) {\n      state.event = event;\n      if (config.preventDefault && event.cancelable)\n        state.event.preventDefault();\n      state.type = event.type;\n      shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;\n      shared.locked = !!document.pointerLockElement;\n      Object.assign(shared, getEventDetails(event));\n      shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;\n      dt2 = event.timeStamp - state.timeStamp;\n      state.timeStamp = event.timeStamp;\n      state.elapsedTime = state.timeStamp - state.startTime;\n    }\n    if (state._active) {\n      const _absoluteDelta = state._delta.map(Math.abs);\n      V.addTo(state._distance, _absoluteDelta);\n    }\n    if (this.axisIntent)\n      this.axisIntent(event);\n    const [_m0, _m1] = state._movement;\n    const [t0, t1] = config.threshold;\n    const {\n      _step,\n      values\n    } = state;\n    if (config.hasCustomTransform) {\n      if (_step[0] === false)\n        _step[0] = Math.abs(_m0) >= t0 && values[0];\n      if (_step[1] === false)\n        _step[1] = Math.abs(_m1) >= t1 && values[1];\n    } else {\n      if (_step[0] === false)\n        _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;\n      if (_step[1] === false)\n        _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;\n    }\n    state.intentional = _step[0] !== false || _step[1] !== false;\n    if (!state.intentional)\n      return;\n    const movement = [0, 0];\n    if (config.hasCustomTransform) {\n      const [v0, v1] = values;\n      movement[0] = _step[0] !== false ? v0 - _step[0] : 0;\n      movement[1] = _step[1] !== false ? v1 - _step[1] : 0;\n    } else {\n      movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;\n      movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;\n    }\n    if (this.restrictToAxis && !state._blocked)\n      this.restrictToAxis(movement);\n    const previousOffset = state.offset;\n    const gestureIsActive = state._active && !state._blocked || state.active;\n    if (gestureIsActive) {\n      state.first = state._active && !state.active;\n      state.last = !state._active && state.active;\n      state.active = shared[this.ingKey] = state._active;\n      if (event) {\n        if (state.first) {\n          if (\"bounds\" in config)\n            state._bounds = call(config.bounds, state);\n          if (this.setup)\n            this.setup();\n        }\n        state.movement = movement;\n        this.computeOffset();\n      }\n    }\n    const [ox, oy] = state.offset;\n    const [[x0, x1], [y0, y1]] = state._bounds;\n    state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];\n    state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;\n    state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;\n    const rubberband2 = state._active ? config.rubberband || [0, 0] : [0, 0];\n    state.offset = computeRubberband(state._bounds, state.offset, rubberband2);\n    state.delta = V.sub(state.offset, previousOffset);\n    this.computeMovement();\n    if (gestureIsActive && (!state.last || dt2 > BEFORE_LAST_KINEMATICS_DELAY)) {\n      state.delta = V.sub(state.offset, previousOffset);\n      const absoluteDelta = state.delta.map(Math.abs);\n      V.addTo(state.distance, absoluteDelta);\n      state.direction = state.delta.map(Math.sign);\n      state._direction = state._delta.map(Math.sign);\n      if (!state.first && dt2 > 0) {\n        state.velocity = [absoluteDelta[0] / dt2, absoluteDelta[1] / dt2];\n      }\n    }\n  }\n  emit() {\n    const state = this.state;\n    const shared = this.shared;\n    const config = this.config;\n    if (!state._active)\n      this.clean();\n    if ((state._blocked || !state.intentional) && !state._force && !config.triggerAllEvents)\n      return;\n    const memo45 = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared), state), {}, {\n      [this.aliasKey]: state.values\n    }));\n    if (memo45 !== void 0)\n      state.memo = memo45;\n  }\n  clean() {\n    this.eventStore.clean();\n    this.timeoutStore.clean();\n  }\n};\nfunction selectAxis([dx, dy], threshold) {\n  const absDx = Math.abs(dx);\n  const absDy = Math.abs(dy);\n  if (absDx > absDy && absDx > threshold) {\n    return \"x\";\n  }\n  if (absDy > absDx && absDy > threshold) {\n    return \"y\";\n  }\n  return void 0;\n}\nvar CoordinatesEngine = class extends Engine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"aliasKey\", \"xy\");\n  }\n  reset() {\n    super.reset();\n    this.state.axis = void 0;\n  }\n  init() {\n    this.state.offset = [0, 0];\n    this.state.lastOffset = [0, 0];\n  }\n  computeOffset() {\n    this.state.offset = V.add(this.state.lastOffset, this.state.movement);\n  }\n  computeMovement() {\n    this.state.movement = V.sub(this.state.offset, this.state.lastOffset);\n  }\n  axisIntent(event) {\n    const state = this.state;\n    const config = this.config;\n    if (!state.axis && event) {\n      const threshold = typeof config.axisThreshold === \"object\" ? config.axisThreshold[getPointerType(event)] : config.axisThreshold;\n      state.axis = selectAxis(state._movement, threshold);\n    }\n    state._blocked = (config.lockDirection || !!config.axis) && !state.axis || !!config.axis && config.axis !== state.axis;\n  }\n  restrictToAxis(v6) {\n    if (this.config.axis || this.config.lockDirection) {\n      switch (this.state.axis) {\n        case \"x\":\n          v6[1] = 0;\n          break;\n        case \"y\":\n          v6[0] = 0;\n          break;\n      }\n    }\n  }\n};\nvar identity = (v6) => v6;\nvar DEFAULT_RUBBERBAND = 0.15;\nvar commonConfigResolver = {\n  enabled(value = true) {\n    return value;\n  },\n  eventOptions(value, _k, config) {\n    return _objectSpread2(_objectSpread2({}, config.shared.eventOptions), value);\n  },\n  preventDefault(value = false) {\n    return value;\n  },\n  triggerAllEvents(value = false) {\n    return value;\n  },\n  rubberband(value = 0) {\n    switch (value) {\n      case true:\n        return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];\n      case false:\n        return [0, 0];\n      default:\n        return V.toVector(value);\n    }\n  },\n  from(value) {\n    if (typeof value === \"function\")\n      return value;\n    if (value != null)\n      return V.toVector(value);\n  },\n  transform(value, _k, config) {\n    const transform = value || config.shared.transform;\n    this.hasCustomTransform = !!transform;\n    if (true) {\n      const originalTransform = transform || identity;\n      return (v6) => {\n        const r5 = originalTransform(v6);\n        if (!isFinite(r5[0]) || !isFinite(r5[1])) {\n          console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${r5[0]},${[1]}]`);\n        }\n        return r5;\n      };\n    }\n    return transform || identity;\n  },\n  threshold(value) {\n    return V.toVector(value, 0);\n  }\n};\nif (true) {\n  Object.assign(commonConfigResolver, {\n    domTarget(value) {\n      if (value !== void 0) {\n        throw Error(`[@use-gesture]: \\`domTarget\\` option has been renamed to \\`target\\`.`);\n      }\n      return NaN;\n    },\n    lockDirection(value) {\n      if (value !== void 0) {\n        throw Error(`[@use-gesture]: \\`lockDirection\\` option has been merged with \\`axis\\`. Use it as in \\`{ axis: 'lock' }\\``);\n      }\n      return NaN;\n    },\n    initial(value) {\n      if (value !== void 0) {\n        throw Error(`[@use-gesture]: \\`initial\\` option has been renamed to \\`from\\`.`);\n      }\n      return NaN;\n    }\n  });\n}\nvar DEFAULT_AXIS_THRESHOLD = 0;\nvar coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {\n  axis(_v, _k, {\n    axis\n  }) {\n    this.lockDirection = axis === \"lock\";\n    if (!this.lockDirection)\n      return axis;\n  },\n  axisThreshold(value = DEFAULT_AXIS_THRESHOLD) {\n    return value;\n  },\n  bounds(value = {}) {\n    if (typeof value === \"function\") {\n      return (state) => coordinatesConfigResolver.bounds(value(state));\n    }\n    if (\"current\" in value) {\n      return () => value.current;\n    }\n    if (typeof HTMLElement === \"function\" && value instanceof HTMLElement) {\n      return value;\n    }\n    const {\n      left = -Infinity,\n      right = Infinity,\n      top: top2 = -Infinity,\n      bottom = Infinity\n    } = value;\n    return [[left, right], [top2, bottom]];\n  }\n});\nvar DISPLACEMENT = 10;\nvar KEYS_DELTA_MAP = {\n  ArrowRight: (factor = 1) => [DISPLACEMENT * factor, 0],\n  ArrowLeft: (factor = 1) => [-DISPLACEMENT * factor, 0],\n  ArrowUp: (factor = 1) => [0, -DISPLACEMENT * factor],\n  ArrowDown: (factor = 1) => [0, DISPLACEMENT * factor]\n};\nvar DragEngine = class extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", \"dragging\");\n  }\n  reset() {\n    super.reset();\n    const state = this.state;\n    state._pointerId = void 0;\n    state._pointerActive = false;\n    state._keyboardActive = false;\n    state._preventScroll = false;\n    state._delayed = false;\n    state.swipe = [0, 0];\n    state.tap = false;\n    state.canceled = false;\n    state.cancel = this.cancel.bind(this);\n  }\n  setup() {\n    const state = this.state;\n    if (state._bounds instanceof HTMLElement) {\n      const boundRect = state._bounds.getBoundingClientRect();\n      const targetRect = state.currentTarget.getBoundingClientRect();\n      const _bounds = {\n        left: boundRect.left - targetRect.left + state.offset[0],\n        right: boundRect.right - targetRect.right + state.offset[0],\n        top: boundRect.top - targetRect.top + state.offset[1],\n        bottom: boundRect.bottom - targetRect.bottom + state.offset[1]\n      };\n      state._bounds = coordinatesConfigResolver.bounds(_bounds);\n    }\n  }\n  cancel() {\n    const state = this.state;\n    if (state.canceled)\n      return;\n    state.canceled = true;\n    state._active = false;\n    setTimeout(() => {\n      this.compute();\n      this.emit();\n    }, 0);\n  }\n  setActive() {\n    this.state._active = this.state._pointerActive || this.state._keyboardActive;\n  }\n  clean() {\n    this.pointerClean();\n    this.state._pointerActive = false;\n    this.state._keyboardActive = false;\n    super.clean();\n  }\n  pointerDown(event) {\n    const config = this.config;\n    const state = this.state;\n    if (event.buttons != null && (Array.isArray(config.pointerButtons) ? !config.pointerButtons.includes(event.buttons) : config.pointerButtons !== -1 && config.pointerButtons !== event.buttons))\n      return;\n    const ctrlIds = this.ctrl.setEventIds(event);\n    if (config.pointerCapture) {\n      event.target.setPointerCapture(event.pointerId);\n    }\n    if (ctrlIds && ctrlIds.size > 1 && state._pointerActive)\n      return;\n    this.start(event);\n    this.setupPointer(event);\n    state._pointerId = pointerId(event);\n    state._pointerActive = true;\n    this.computeValues(pointerValues(event));\n    this.computeInitial();\n    if (config.preventScrollAxis && getPointerType(event) !== \"mouse\") {\n      state._active = false;\n      this.setupScrollPrevention(event);\n    } else if (config.delay > 0) {\n      this.setupDelayTrigger(event);\n      if (config.triggerAllEvents) {\n        this.compute(event);\n        this.emit();\n      }\n    } else {\n      this.startPointerDrag(event);\n    }\n  }\n  startPointerDrag(event) {\n    const state = this.state;\n    state._active = true;\n    state._preventScroll = true;\n    state._delayed = false;\n    this.compute(event);\n    this.emit();\n  }\n  pointerMove(event) {\n    const state = this.state;\n    const config = this.config;\n    if (!state._pointerActive)\n      return;\n    if (state.type === event.type && event.timeStamp === state.timeStamp)\n      return;\n    const id = pointerId(event);\n    if (state._pointerId !== void 0 && id !== state._pointerId)\n      return;\n    const _values = pointerValues(event);\n    if (document.pointerLockElement === event.target) {\n      state._delta = [event.movementX, event.movementY];\n    } else {\n      state._delta = V.sub(_values, state._values);\n      this.computeValues(_values);\n    }\n    V.addTo(state._movement, state._delta);\n    this.compute(event);\n    if (state._delayed && state.intentional) {\n      this.timeoutStore.remove(\"dragDelay\");\n      state.active = false;\n      this.startPointerDrag(event);\n      return;\n    }\n    if (config.preventScrollAxis && !state._preventScroll) {\n      if (state.axis) {\n        if (state.axis === config.preventScrollAxis || config.preventScrollAxis === \"xy\") {\n          state._active = false;\n          this.clean();\n          return;\n        } else {\n          this.timeoutStore.remove(\"startPointerDrag\");\n          this.startPointerDrag(event);\n          return;\n        }\n      } else {\n        return;\n      }\n    }\n    this.emit();\n  }\n  pointerUp(event) {\n    this.ctrl.setEventIds(event);\n    try {\n      if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {\n        ;\n        event.target.releasePointerCapture(event.pointerId);\n      }\n    } catch (_unused) {\n      if (true) {\n        console.warn(`[@use-gesture]: If you see this message, it's likely that you're using an outdated version of \\`@react-three/fiber\\`. \n\nPlease upgrade to the latest version.`);\n      }\n    }\n    const state = this.state;\n    const config = this.config;\n    if (!state._active || !state._pointerActive)\n      return;\n    const id = pointerId(event);\n    if (state._pointerId !== void 0 && id !== state._pointerId)\n      return;\n    this.state._pointerActive = false;\n    this.setActive();\n    this.compute(event);\n    const [dx, dy] = state._distance;\n    state.tap = dx <= config.tapsThreshold && dy <= config.tapsThreshold;\n    if (state.tap && config.filterTaps) {\n      state._force = true;\n    } else {\n      const [dirx, diry] = state.direction;\n      const [vx, vy] = state.velocity;\n      const [mx, my] = state.movement;\n      const [svx, svy] = config.swipe.velocity;\n      const [sx, sy] = config.swipe.distance;\n      const sdt = config.swipe.duration;\n      if (state.elapsedTime < sdt) {\n        if (Math.abs(vx) > svx && Math.abs(mx) > sx)\n          state.swipe[0] = dirx;\n        if (Math.abs(vy) > svy && Math.abs(my) > sy)\n          state.swipe[1] = diry;\n      }\n    }\n    this.emit();\n  }\n  pointerClick(event) {\n    if (!this.state.tap && event.detail > 0) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  }\n  setupPointer(event) {\n    const config = this.config;\n    const device = config.device;\n    if (true) {\n      try {\n        if (device === \"pointer\" && config.preventScrollDelay === void 0) {\n          const currentTarget = \"uv\" in event ? event.sourceEvent.currentTarget : event.currentTarget;\n          const style = window.getComputedStyle(currentTarget);\n          if (style.touchAction === \"auto\") {\n            console.warn(`[@use-gesture]: The drag target has its \\`touch-action\\` style property set to \\`auto\\`. It is recommended to add \\`touch-action: 'none'\\` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.\n\nThis message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.`, currentTarget);\n          }\n        }\n      } catch (_unused2) {\n      }\n    }\n    if (config.pointerLock) {\n      event.currentTarget.requestPointerLock();\n    }\n    if (!config.pointerCapture) {\n      this.eventStore.add(this.sharedConfig.window, device, \"change\", this.pointerMove.bind(this));\n      this.eventStore.add(this.sharedConfig.window, device, \"end\", this.pointerUp.bind(this));\n      this.eventStore.add(this.sharedConfig.window, device, \"cancel\", this.pointerUp.bind(this));\n    }\n  }\n  pointerClean() {\n    if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {\n      document.exitPointerLock();\n    }\n  }\n  preventScroll(event) {\n    if (this.state._preventScroll && event.cancelable) {\n      event.preventDefault();\n    }\n  }\n  setupScrollPrevention(event) {\n    this.state._preventScroll = false;\n    persistEvent(event);\n    const remove = this.eventStore.add(this.sharedConfig.window, \"touch\", \"change\", this.preventScroll.bind(this), {\n      passive: false\n    });\n    this.eventStore.add(this.sharedConfig.window, \"touch\", \"end\", remove);\n    this.eventStore.add(this.sharedConfig.window, \"touch\", \"cancel\", remove);\n    this.timeoutStore.add(\"startPointerDrag\", this.startPointerDrag.bind(this), this.config.preventScrollDelay, event);\n  }\n  setupDelayTrigger(event) {\n    this.state._delayed = true;\n    this.timeoutStore.add(\"dragDelay\", () => {\n      this.state._step = [0, 0];\n      this.startPointerDrag(event);\n    }, this.config.delay);\n  }\n  keyDown(event) {\n    const deltaFn = KEYS_DELTA_MAP[event.key];\n    if (deltaFn) {\n      const state = this.state;\n      const factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;\n      this.start(event);\n      state._delta = deltaFn(factor);\n      state._keyboardActive = true;\n      V.addTo(state._movement, state._delta);\n      this.compute(event);\n      this.emit();\n    }\n  }\n  keyUp(event) {\n    if (!(event.key in KEYS_DELTA_MAP))\n      return;\n    this.state._keyboardActive = false;\n    this.setActive();\n    this.compute(event);\n    this.emit();\n  }\n  bind(bindFunction) {\n    const device = this.config.device;\n    bindFunction(device, \"start\", this.pointerDown.bind(this));\n    if (this.config.pointerCapture) {\n      bindFunction(device, \"change\", this.pointerMove.bind(this));\n      bindFunction(device, \"end\", this.pointerUp.bind(this));\n      bindFunction(device, \"cancel\", this.pointerUp.bind(this));\n      bindFunction(\"lostPointerCapture\", \"\", this.pointerUp.bind(this));\n    }\n    if (this.config.keys) {\n      bindFunction(\"key\", \"down\", this.keyDown.bind(this));\n      bindFunction(\"key\", \"up\", this.keyUp.bind(this));\n    }\n    if (this.config.filterTaps) {\n      bindFunction(\"click\", \"\", this.pointerClick.bind(this), {\n        capture: true,\n        passive: false\n      });\n    }\n  }\n};\nfunction persistEvent(event) {\n  \"persist\" in event && typeof event.persist === \"function\" && event.persist();\n}\nvar isBrowser = typeof window !== \"undefined\" && window.document && window.document.createElement;\nfunction supportsTouchEvents() {\n  return isBrowser && \"ontouchstart\" in window;\n}\nfunction isTouchScreen() {\n  return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;\n}\nfunction supportsPointerEvents() {\n  return isBrowser && \"onpointerdown\" in window;\n}\nfunction supportsPointerLock() {\n  return isBrowser && \"exitPointerLock\" in window.document;\n}\nfunction supportsGestureEvents() {\n  try {\n    return \"constructor\" in GestureEvent;\n  } catch (e5) {\n    return false;\n  }\n}\nvar SUPPORT = {\n  isBrowser,\n  gesture: supportsGestureEvents(),\n  touch: isTouchScreen(),\n  touchscreen: isTouchScreen(),\n  pointer: supportsPointerEvents(),\n  pointerLock: supportsPointerLock()\n};\nvar DEFAULT_PREVENT_SCROLL_DELAY = 250;\nvar DEFAULT_DRAG_DELAY = 180;\nvar DEFAULT_SWIPE_VELOCITY = 0.5;\nvar DEFAULT_SWIPE_DISTANCE = 50;\nvar DEFAULT_SWIPE_DURATION = 250;\nvar DEFAULT_DRAG_AXIS_THRESHOLD = {\n  mouse: 0,\n  touch: 0,\n  pen: 8\n};\nvar dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  device(_v, _k, {\n    pointer: {\n      touch = false,\n      lock = false,\n      mouse = false\n    } = {}\n  }) {\n    this.pointerLock = lock && SUPPORT.pointerLock;\n    if (SUPPORT.touch && touch)\n      return \"touch\";\n    if (this.pointerLock)\n      return \"mouse\";\n    if (SUPPORT.pointer && !mouse)\n      return \"pointer\";\n    if (SUPPORT.touch)\n      return \"touch\";\n    return \"mouse\";\n  },\n  preventScrollAxis(value, _k, {\n    preventScroll\n  }) {\n    this.preventScrollDelay = typeof preventScroll === \"number\" ? preventScroll : preventScroll || preventScroll === void 0 && value ? DEFAULT_PREVENT_SCROLL_DELAY : void 0;\n    if (!SUPPORT.touchscreen || preventScroll === false)\n      return void 0;\n    return value ? value : preventScroll !== void 0 ? \"y\" : void 0;\n  },\n  pointerCapture(_v, _k, {\n    pointer: {\n      capture = true,\n      buttons = 1,\n      keys = true\n    } = {}\n  }) {\n    this.pointerButtons = buttons;\n    this.keys = keys;\n    return !this.pointerLock && this.device === \"pointer\" && capture;\n  },\n  threshold(value, _k, {\n    filterTaps = false,\n    tapsThreshold = 3,\n    axis = void 0\n  }) {\n    const threshold = V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);\n    this.filterTaps = filterTaps;\n    this.tapsThreshold = tapsThreshold;\n    return threshold;\n  },\n  swipe({\n    velocity = DEFAULT_SWIPE_VELOCITY,\n    distance = DEFAULT_SWIPE_DISTANCE,\n    duration = DEFAULT_SWIPE_DURATION\n  } = {}) {\n    return {\n      velocity: this.transform(V.toVector(velocity)),\n      distance: this.transform(V.toVector(distance)),\n      duration\n    };\n  },\n  delay(value = 0) {\n    switch (value) {\n      case true:\n        return DEFAULT_DRAG_DELAY;\n      case false:\n        return 0;\n      default:\n        return value;\n    }\n  },\n  axisThreshold(value) {\n    if (!value)\n      return DEFAULT_DRAG_AXIS_THRESHOLD;\n    return _objectSpread2(_objectSpread2({}, DEFAULT_DRAG_AXIS_THRESHOLD), value);\n  }\n});\nif (true) {\n  Object.assign(dragConfigResolver, {\n    useTouch(value) {\n      if (value !== void 0) {\n        throw Error(`[@use-gesture]: \\`useTouch\\` option has been renamed to \\`pointer.touch\\`. Use it as in \\`{ pointer: { touch: true } }\\`.`);\n      }\n      return NaN;\n    },\n    experimental_preventWindowScrollY(value) {\n      if (value !== void 0) {\n        throw Error(`[@use-gesture]: \\`experimental_preventWindowScrollY\\` option has been renamed to \\`preventScroll\\`.`);\n      }\n      return NaN;\n    },\n    swipeVelocity(value) {\n      if (value !== void 0) {\n        throw Error(`[@use-gesture]: \\`swipeVelocity\\` option has been renamed to \\`swipe.velocity\\`. Use it as in \\`{ swipe: { velocity: 0.5 } }\\`.`);\n      }\n      return NaN;\n    },\n    swipeDistance(value) {\n      if (value !== void 0) {\n        throw Error(`[@use-gesture]: \\`swipeDistance\\` option has been renamed to \\`swipe.distance\\`. Use it as in \\`{ swipe: { distance: 50 } }\\`.`);\n      }\n      return NaN;\n    },\n    swipeDuration(value) {\n      if (value !== void 0) {\n        throw Error(`[@use-gesture]: \\`swipeDuration\\` option has been renamed to \\`swipe.duration\\`. Use it as in \\`{ swipe: { duration: 250 } }\\`.`);\n      }\n      return NaN;\n    }\n  });\n}\nfunction clampStateInternalMovementToBounds(state) {\n  const [ox, oy] = state.overflow;\n  const [dx, dy] = state._delta;\n  const [dirx, diry] = state._direction;\n  if (ox < 0 && dx > 0 && dirx < 0 || ox > 0 && dx < 0 && dirx > 0) {\n    state._movement[0] = state._movementBound[0];\n  }\n  if (oy < 0 && dy > 0 && diry < 0 || oy > 0 && dy < 0 && diry > 0) {\n    state._movement[1] = state._movementBound[1];\n  }\n}\nvar SCALE_ANGLE_RATIO_INTENT_DEG = 30;\nvar PINCH_WHEEL_RATIO = 100;\nvar PinchEngine = class extends Engine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", \"pinching\");\n    _defineProperty(this, \"aliasKey\", \"da\");\n  }\n  init() {\n    this.state.offset = [1, 0];\n    this.state.lastOffset = [1, 0];\n    this.state._pointerEvents = /* @__PURE__ */ new Map();\n  }\n  reset() {\n    super.reset();\n    const state = this.state;\n    state._touchIds = [];\n    state.canceled = false;\n    state.cancel = this.cancel.bind(this);\n    state.turns = 0;\n  }\n  computeOffset() {\n    const {\n      type,\n      movement,\n      lastOffset\n    } = this.state;\n    if (type === \"wheel\") {\n      this.state.offset = V.add(movement, lastOffset);\n    } else {\n      this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];\n    }\n  }\n  computeMovement() {\n    const {\n      offset,\n      lastOffset\n    } = this.state;\n    this.state.movement = [offset[0] / lastOffset[0], offset[1] - lastOffset[1]];\n  }\n  axisIntent() {\n    const state = this.state;\n    const [_m0, _m1] = state._movement;\n    if (!state.axis) {\n      const axisMovementDifference = Math.abs(_m0) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(_m1);\n      if (axisMovementDifference < 0)\n        state.axis = \"angle\";\n      else if (axisMovementDifference > 0)\n        state.axis = \"scale\";\n    }\n  }\n  restrictToAxis(v6) {\n    if (this.config.lockDirection) {\n      if (this.state.axis === \"scale\")\n        v6[1] = 0;\n      else if (this.state.axis === \"angle\")\n        v6[0] = 0;\n    }\n  }\n  cancel() {\n    const state = this.state;\n    if (state.canceled)\n      return;\n    setTimeout(() => {\n      state.canceled = true;\n      state._active = false;\n      this.compute();\n      this.emit();\n    }, 0);\n  }\n  touchStart(event) {\n    this.ctrl.setEventIds(event);\n    const state = this.state;\n    const ctrlTouchIds = this.ctrl.touchIds;\n    if (state._active) {\n      if (state._touchIds.every((id) => ctrlTouchIds.has(id)))\n        return;\n    }\n    if (ctrlTouchIds.size < 2)\n      return;\n    this.start(event);\n    state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);\n    const payload = touchDistanceAngle(event, state._touchIds);\n    this.pinchStart(event, payload);\n  }\n  pointerStart(event) {\n    if (event.buttons != null && event.buttons % 2 !== 1)\n      return;\n    this.ctrl.setEventIds(event);\n    event.target.setPointerCapture(event.pointerId);\n    const state = this.state;\n    const _pointerEvents = state._pointerEvents;\n    const ctrlPointerIds = this.ctrl.pointerIds;\n    if (state._active) {\n      if (Array.from(_pointerEvents.keys()).every((id) => ctrlPointerIds.has(id)))\n        return;\n    }\n    if (_pointerEvents.size < 2) {\n      _pointerEvents.set(event.pointerId, event);\n    }\n    if (state._pointerEvents.size < 2)\n      return;\n    this.start(event);\n    const payload = distanceAngle(...Array.from(_pointerEvents.values()));\n    this.pinchStart(event, payload);\n  }\n  pinchStart(event, payload) {\n    const state = this.state;\n    state.origin = payload.origin;\n    this.computeValues([payload.distance, payload.angle]);\n    this.computeInitial();\n    this.compute(event);\n    this.emit();\n  }\n  touchMove(event) {\n    if (!this.state._active)\n      return;\n    const payload = touchDistanceAngle(event, this.state._touchIds);\n    this.pinchMove(event, payload);\n  }\n  pointerMove(event) {\n    const _pointerEvents = this.state._pointerEvents;\n    if (_pointerEvents.has(event.pointerId)) {\n      _pointerEvents.set(event.pointerId, event);\n    }\n    if (!this.state._active)\n      return;\n    const payload = distanceAngle(...Array.from(_pointerEvents.values()));\n    this.pinchMove(event, payload);\n  }\n  pinchMove(event, payload) {\n    const state = this.state;\n    const prev_a = state._values[1];\n    const delta_a = payload.angle - prev_a;\n    let delta_turns = 0;\n    if (Math.abs(delta_a) > 270)\n      delta_turns += Math.sign(delta_a);\n    this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);\n    state.origin = payload.origin;\n    state.turns = delta_turns;\n    state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];\n    this.compute(event);\n    this.emit();\n  }\n  touchEnd(event) {\n    this.ctrl.setEventIds(event);\n    if (!this.state._active)\n      return;\n    if (this.state._touchIds.some((id) => !this.ctrl.touchIds.has(id))) {\n      this.state._active = false;\n      this.compute(event);\n      this.emit();\n    }\n  }\n  pointerEnd(event) {\n    const state = this.state;\n    this.ctrl.setEventIds(event);\n    try {\n      event.target.releasePointerCapture(event.pointerId);\n    } catch (_unused) {\n    }\n    if (state._pointerEvents.has(event.pointerId)) {\n      state._pointerEvents.delete(event.pointerId);\n    }\n    if (!state._active)\n      return;\n    if (state._pointerEvents.size < 2) {\n      state._active = false;\n      this.compute(event);\n      this.emit();\n    }\n  }\n  gestureStart(event) {\n    if (event.cancelable)\n      event.preventDefault();\n    const state = this.state;\n    if (state._active)\n      return;\n    this.start(event);\n    this.computeValues([event.scale, event.rotation]);\n    state.origin = [event.clientX, event.clientY];\n    this.compute(event);\n    this.emit();\n  }\n  gestureMove(event) {\n    if (event.cancelable)\n      event.preventDefault();\n    if (!this.state._active)\n      return;\n    const state = this.state;\n    this.computeValues([event.scale, event.rotation]);\n    state.origin = [event.clientX, event.clientY];\n    const _previousMovement = state._movement;\n    state._movement = [event.scale - 1, event.rotation];\n    state._delta = V.sub(state._movement, _previousMovement);\n    this.compute(event);\n    this.emit();\n  }\n  gestureEnd(event) {\n    if (!this.state._active)\n      return;\n    this.state._active = false;\n    this.compute(event);\n    this.emit();\n  }\n  wheel(event) {\n    const modifierKey = this.config.modifierKey;\n    if (modifierKey && !event[modifierKey])\n      return;\n    if (!this.state._active)\n      this.wheelStart(event);\n    else\n      this.wheelChange(event);\n    this.timeoutStore.add(\"wheelEnd\", this.wheelEnd.bind(this));\n  }\n  wheelStart(event) {\n    this.start(event);\n    this.wheelChange(event);\n  }\n  wheelChange(event) {\n    const isR3f = \"uv\" in event;\n    if (!isR3f) {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n      if (!event.defaultPrevented) {\n        console.warn(`[@use-gesture]: To properly support zoom on trackpads, try using the \\`target\\` option.\n\nThis message will only appear in development mode.`);\n      }\n    }\n    const state = this.state;\n    state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];\n    V.addTo(state._movement, state._delta);\n    clampStateInternalMovementToBounds(state);\n    this.state.origin = [event.clientX, event.clientY];\n    this.compute(event);\n    this.emit();\n  }\n  wheelEnd() {\n    if (!this.state._active)\n      return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n  bind(bindFunction) {\n    const device = this.config.device;\n    if (!!device) {\n      bindFunction(device, \"start\", this[device + \"Start\"].bind(this));\n      bindFunction(device, \"change\", this[device + \"Move\"].bind(this));\n      bindFunction(device, \"end\", this[device + \"End\"].bind(this));\n      bindFunction(device, \"cancel\", this[device + \"End\"].bind(this));\n    }\n    if (this.config.pinchOnWheel) {\n      bindFunction(\"wheel\", \"\", this.wheel.bind(this), {\n        passive: false\n      });\n    }\n  }\n};\nvar pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {\n  device(_v, _k, {\n    shared,\n    pointer: {\n      touch = false\n    } = {}\n  }) {\n    const sharedConfig = shared;\n    if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture)\n      return \"gesture\";\n    if (SUPPORT.touch && touch)\n      return \"touch\";\n    if (SUPPORT.touchscreen) {\n      if (SUPPORT.pointer)\n        return \"pointer\";\n      if (SUPPORT.touch)\n        return \"touch\";\n    }\n  },\n  bounds(_v, _k, {\n    scaleBounds = {},\n    angleBounds = {}\n  }) {\n    const _scaleBounds = (state) => {\n      const D6 = assignDefault(call(scaleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [D6.min, D6.max];\n    };\n    const _angleBounds = (state) => {\n      const A5 = assignDefault(call(angleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [A5.min, A5.max];\n    };\n    if (typeof scaleBounds !== \"function\" && typeof angleBounds !== \"function\")\n      return [_scaleBounds(), _angleBounds()];\n    return (state) => [_scaleBounds(state), _angleBounds(state)];\n  },\n  threshold(value, _k, config) {\n    this.lockDirection = config.axis === \"lock\";\n    const threshold = V.toVector(value, this.lockDirection ? [0.1, 3] : 0);\n    return threshold;\n  },\n  modifierKey(value) {\n    if (value === void 0)\n      return \"ctrlKey\";\n    return value;\n  },\n  pinchOnWheel(value = true) {\n    return value;\n  }\n});\nvar MoveEngine = class extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", \"moving\");\n  }\n  move(event) {\n    if (this.config.mouseOnly && event.pointerType !== \"mouse\")\n      return;\n    if (!this.state._active)\n      this.moveStart(event);\n    else\n      this.moveChange(event);\n    this.timeoutStore.add(\"moveEnd\", this.moveEnd.bind(this));\n  }\n  moveStart(event) {\n    this.start(event);\n    this.computeValues(pointerValues(event));\n    this.compute(event);\n    this.computeInitial();\n    this.emit();\n  }\n  moveChange(event) {\n    if (!this.state._active)\n      return;\n    const values = pointerValues(event);\n    const state = this.state;\n    state._delta = V.sub(values, state._values);\n    V.addTo(state._movement, state._delta);\n    this.computeValues(values);\n    this.compute(event);\n    this.emit();\n  }\n  moveEnd(event) {\n    if (!this.state._active)\n      return;\n    this.state._active = false;\n    this.compute(event);\n    this.emit();\n  }\n  bind(bindFunction) {\n    bindFunction(\"pointer\", \"change\", this.move.bind(this));\n    bindFunction(\"pointer\", \"leave\", this.moveEnd.bind(this));\n  }\n};\nvar moveConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  mouseOnly: (value = true) => value\n});\nvar ScrollEngine = class extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", \"scrolling\");\n  }\n  scroll(event) {\n    if (!this.state._active)\n      this.start(event);\n    this.scrollChange(event);\n    this.timeoutStore.add(\"scrollEnd\", this.scrollEnd.bind(this));\n  }\n  scrollChange(event) {\n    if (event.cancelable)\n      event.preventDefault();\n    const state = this.state;\n    const values = scrollValues(event);\n    state._delta = V.sub(values, state._values);\n    V.addTo(state._movement, state._delta);\n    this.computeValues(values);\n    this.compute(event);\n    this.emit();\n  }\n  scrollEnd() {\n    if (!this.state._active)\n      return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n  bind(bindFunction) {\n    bindFunction(\"scroll\", \"\", this.scroll.bind(this));\n  }\n};\nvar scrollConfigResolver = coordinatesConfigResolver;\nvar WheelEngine = class extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", \"wheeling\");\n  }\n  wheel(event) {\n    if (!this.state._active)\n      this.start(event);\n    this.wheelChange(event);\n    this.timeoutStore.add(\"wheelEnd\", this.wheelEnd.bind(this));\n  }\n  wheelChange(event) {\n    const state = this.state;\n    state._delta = wheelValues(event);\n    V.addTo(state._movement, state._delta);\n    clampStateInternalMovementToBounds(state);\n    this.compute(event);\n    this.emit();\n  }\n  wheelEnd() {\n    if (!this.state._active)\n      return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n  bind(bindFunction) {\n    bindFunction(\"wheel\", \"\", this.wheel.bind(this));\n  }\n};\nvar wheelConfigResolver = coordinatesConfigResolver;\nvar HoverEngine = class extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", \"hovering\");\n  }\n  enter(event) {\n    if (this.config.mouseOnly && event.pointerType !== \"mouse\")\n      return;\n    this.start(event);\n    this.computeValues(pointerValues(event));\n    this.compute(event);\n    this.emit();\n  }\n  leave(event) {\n    if (this.config.mouseOnly && event.pointerType !== \"mouse\")\n      return;\n    const state = this.state;\n    if (!state._active)\n      return;\n    state._active = false;\n    const values = pointerValues(event);\n    state._movement = state._delta = V.sub(values, state._values);\n    this.computeValues(values);\n    this.compute(event);\n    state.delta = state.movement;\n    this.emit();\n  }\n  bind(bindFunction) {\n    bindFunction(\"pointer\", \"enter\", this.enter.bind(this));\n    bindFunction(\"pointer\", \"leave\", this.leave.bind(this));\n  }\n};\nvar hoverConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  mouseOnly: (value = true) => value\n});\nvar EngineMap = /* @__PURE__ */ new Map();\nvar ConfigResolverMap = /* @__PURE__ */ new Map();\nfunction registerAction(action) {\n  EngineMap.set(action.key, action.engine);\n  ConfigResolverMap.set(action.key, action.resolver);\n}\nvar dragAction = {\n  key: \"drag\",\n  engine: DragEngine,\n  resolver: dragConfigResolver\n};\nvar hoverAction = {\n  key: \"hover\",\n  engine: HoverEngine,\n  resolver: hoverConfigResolver\n};\nvar moveAction = {\n  key: \"move\",\n  engine: MoveEngine,\n  resolver: moveConfigResolver\n};\nvar pinchAction = {\n  key: \"pinch\",\n  engine: PinchEngine,\n  resolver: pinchConfigResolver\n};\nvar scrollAction = {\n  key: \"scroll\",\n  engine: ScrollEngine,\n  resolver: scrollConfigResolver\n};\nvar wheelAction = {\n  key: \"wheel\",\n  engine: WheelEngine,\n  resolver: wheelConfigResolver\n};\n\n// node_modules/@use-gesture/react/dist/use-gesture-react.esm.js\nvar import_react4 = __toESM(require(\"react\"));\n\n// node_modules/@use-gesture/core/dist/use-gesture-core.esm.js\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null)\n    return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i4;\n  for (i4 = 0; i4 < sourceKeys.length; i4++) {\n    key = sourceKeys[i4];\n    if (excluded.indexOf(key) >= 0)\n      continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null)\n    return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i4;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i4 = 0; i4 < sourceSymbolKeys.length; i4++) {\n      key = sourceSymbolKeys[i4];\n      if (excluded.indexOf(key) >= 0)\n        continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key))\n        continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nvar sharedConfigResolver = {\n  target(value) {\n    if (value) {\n      return () => \"current\" in value ? value.current : value;\n    }\n    return void 0;\n  },\n  enabled(value = true) {\n    return value;\n  },\n  window(value = SUPPORT.isBrowser ? window : void 0) {\n    return value;\n  },\n  eventOptions({\n    passive = true,\n    capture = false\n  } = {}) {\n    return {\n      passive,\n      capture\n    };\n  },\n  transform(value) {\n    return value;\n  }\n};\nvar _excluded = [\"target\", \"eventOptions\", \"window\", \"enabled\", \"transform\"];\nfunction resolveWith(config = {}, resolvers) {\n  const result = {};\n  for (const [key, resolver] of Object.entries(resolvers)) {\n    switch (typeof resolver) {\n      case \"function\":\n        if (true) {\n          const r5 = resolver.call(result, config[key], key, config);\n          if (!Number.isNaN(r5))\n            result[key] = r5;\n        } else {\n          result[key] = resolver.call(result, config[key], key, config);\n        }\n        break;\n      case \"object\":\n        result[key] = resolveWith(config[key], resolver);\n        break;\n      case \"boolean\":\n        if (resolver)\n          result[key] = config[key];\n        break;\n    }\n  }\n  return result;\n}\nfunction parse(newConfig, gestureKey, _config = {}) {\n  const _ref = newConfig, {\n    target,\n    eventOptions,\n    window: window2,\n    enabled,\n    transform\n  } = _ref, rest = _objectWithoutProperties(_ref, _excluded);\n  _config.shared = resolveWith({\n    target,\n    eventOptions,\n    window: window2,\n    enabled,\n    transform\n  }, sharedConfigResolver);\n  if (gestureKey) {\n    const resolver = ConfigResolverMap.get(gestureKey);\n    _config[gestureKey] = resolveWith(_objectSpread2({\n      shared: _config.shared\n    }, rest), resolver);\n  } else {\n    for (const key in rest) {\n      const resolver = ConfigResolverMap.get(key);\n      if (resolver) {\n        _config[key] = resolveWith(_objectSpread2({\n          shared: _config.shared\n        }, rest[key]), resolver);\n      } else if (true) {\n        if (![\"drag\", \"pinch\", \"scroll\", \"wheel\", \"move\", \"hover\"].includes(key)) {\n          if (key === \"domTarget\") {\n            throw Error(`[@use-gesture]: \\`domTarget\\` option has been renamed to \\`target\\`.`);\n          }\n          console.warn(`[@use-gesture]: Unknown config key \\`${key}\\` was used. Please read the documentation for further information.`);\n        }\n      }\n    }\n  }\n  return _config;\n}\nvar EventStore = class {\n  constructor(ctrl, gestureKey) {\n    _defineProperty(this, \"_listeners\", /* @__PURE__ */ new Set());\n    this._ctrl = ctrl;\n    this._gestureKey = gestureKey;\n  }\n  add(element, device, action, handler, options) {\n    const listeners = this._listeners;\n    const type = toDomEventType(device, action);\n    const _options = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {};\n    const eventOptions = _objectSpread2(_objectSpread2({}, _options), options);\n    element.addEventListener(type, handler, eventOptions);\n    const remove = () => {\n      element.removeEventListener(type, handler, eventOptions);\n      listeners.delete(remove);\n    };\n    listeners.add(remove);\n    return remove;\n  }\n  clean() {\n    this._listeners.forEach((remove) => remove());\n    this._listeners.clear();\n  }\n};\nvar TimeoutStore = class {\n  constructor() {\n    _defineProperty(this, \"_timeouts\", /* @__PURE__ */ new Map());\n  }\n  add(key, callback, ms = 140, ...args) {\n    this.remove(key);\n    this._timeouts.set(key, window.setTimeout(callback, ms, ...args));\n  }\n  remove(key) {\n    const timeout = this._timeouts.get(key);\n    if (timeout)\n      window.clearTimeout(timeout);\n  }\n  clean() {\n    this._timeouts.forEach((timeout) => void window.clearTimeout(timeout));\n    this._timeouts.clear();\n  }\n};\nvar Controller = class {\n  constructor(handlers) {\n    _defineProperty(this, \"gestures\", /* @__PURE__ */ new Set());\n    _defineProperty(this, \"_targetEventStore\", new EventStore(this));\n    _defineProperty(this, \"gestureEventStores\", {});\n    _defineProperty(this, \"gestureTimeoutStores\", {});\n    _defineProperty(this, \"handlers\", {});\n    _defineProperty(this, \"config\", {});\n    _defineProperty(this, \"pointerIds\", /* @__PURE__ */ new Set());\n    _defineProperty(this, \"touchIds\", /* @__PURE__ */ new Set());\n    _defineProperty(this, \"state\", {\n      shared: {\n        shiftKey: false,\n        metaKey: false,\n        ctrlKey: false,\n        altKey: false\n      }\n    });\n    resolveGestures(this, handlers);\n  }\n  setEventIds(event) {\n    if (isTouch(event)) {\n      this.touchIds = new Set(touchIds(event));\n      return this.touchIds;\n    } else if (\"pointerId\" in event) {\n      if (event.type === \"pointerup\" || event.type === \"pointercancel\")\n        this.pointerIds.delete(event.pointerId);\n      else if (event.type === \"pointerdown\")\n        this.pointerIds.add(event.pointerId);\n      return this.pointerIds;\n    }\n  }\n  applyHandlers(handlers, nativeHandlers) {\n    this.handlers = handlers;\n    this.nativeHandlers = nativeHandlers;\n  }\n  applyConfig(config, gestureKey) {\n    this.config = parse(config, gestureKey, this.config);\n  }\n  clean() {\n    this._targetEventStore.clean();\n    for (const key of this.gestures) {\n      this.gestureEventStores[key].clean();\n      this.gestureTimeoutStores[key].clean();\n    }\n  }\n  effect() {\n    if (this.config.shared.target)\n      this.bind();\n    return () => this._targetEventStore.clean();\n  }\n  bind(...args) {\n    const sharedConfig = this.config.shared;\n    const props = {};\n    let target;\n    if (sharedConfig.target) {\n      target = sharedConfig.target();\n      if (!target)\n        return;\n    }\n    if (sharedConfig.enabled) {\n      for (const gestureKey of this.gestures) {\n        const gestureConfig = this.config[gestureKey];\n        const bindFunction = bindToProps(props, gestureConfig.eventOptions, !!target);\n        if (gestureConfig.enabled) {\n          const Engine2 = EngineMap.get(gestureKey);\n          new Engine2(this, args, gestureKey).bind(bindFunction);\n        }\n      }\n      const nativeBindFunction = bindToProps(props, sharedConfig.eventOptions, !!target);\n      for (const eventKey in this.nativeHandlers) {\n        nativeBindFunction(\n          eventKey,\n          \"\",\n          (event) => this.nativeHandlers[eventKey](_objectSpread2(_objectSpread2({}, this.state.shared), {}, {\n            event,\n            args\n          })),\n          void 0,\n          true\n        );\n      }\n    }\n    for (const handlerProp in props) {\n      props[handlerProp] = chain(...props[handlerProp]);\n    }\n    if (!target)\n      return props;\n    for (const handlerProp in props) {\n      const {\n        device,\n        capture,\n        passive\n      } = parseProp(handlerProp);\n      this._targetEventStore.add(target, device, \"\", props[handlerProp], {\n        capture,\n        passive\n      });\n    }\n  }\n};\nfunction setupGesture(ctrl, gestureKey) {\n  ctrl.gestures.add(gestureKey);\n  ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl, gestureKey);\n  ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();\n}\nfunction resolveGestures(ctrl, internalHandlers) {\n  if (internalHandlers.drag)\n    setupGesture(ctrl, \"drag\");\n  if (internalHandlers.wheel)\n    setupGesture(ctrl, \"wheel\");\n  if (internalHandlers.scroll)\n    setupGesture(ctrl, \"scroll\");\n  if (internalHandlers.move)\n    setupGesture(ctrl, \"move\");\n  if (internalHandlers.pinch)\n    setupGesture(ctrl, \"pinch\");\n  if (internalHandlers.hover)\n    setupGesture(ctrl, \"hover\");\n}\nvar bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options = {}, isNative = false) => {\n  var _options$capture, _options$passive;\n  const capture = (_options$capture = options.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;\n  const passive = (_options$passive = options.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;\n  let handlerProp = isNative ? device : toHandlerProp(device, action, capture);\n  if (withPassiveOption && passive)\n    handlerProp += \"Passive\";\n  props[handlerProp] = props[handlerProp] || [];\n  props[handlerProp].push(handler);\n};\nvar RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;\nfunction sortHandlers(_handlers2) {\n  const native = {};\n  const handlers = {};\n  const actions = /* @__PURE__ */ new Set();\n  for (let key in _handlers2) {\n    if (RE_NOT_NATIVE.test(key)) {\n      actions.add(RegExp.lastMatch);\n      handlers[key] = _handlers2[key];\n    } else {\n      native[key] = _handlers2[key];\n    }\n  }\n  return [handlers, native, actions];\n}\nfunction registerGesture(actions, handlers, handlerKey, key, internalHandlers, config) {\n  if (!actions.has(handlerKey))\n    return;\n  if (!EngineMap.has(key)) {\n    if (true) {\n      console.warn(`[@use-gesture]: You've created a custom handler that that uses the \\`${key}\\` gesture but isn't properly configured.\n\nPlease add \\`${key}Action\\` when creating your handler.`);\n    }\n    return;\n  }\n  const startKey = handlerKey + \"Start\";\n  const endKey = handlerKey + \"End\";\n  const fn2 = (state) => {\n    let memo45 = void 0;\n    if (state.first && startKey in handlers)\n      handlers[startKey](state);\n    if (handlerKey in handlers)\n      memo45 = handlers[handlerKey](state);\n    if (state.last && endKey in handlers)\n      handlers[endKey](state);\n    return memo45;\n  };\n  internalHandlers[key] = fn2;\n  config[key] = config[key] || {};\n}\nfunction parseMergedHandlers(mergedHandlers, mergedConfig) {\n  const [handlers, nativeHandlers, actions] = sortHandlers(mergedHandlers);\n  const internalHandlers = {};\n  registerGesture(actions, handlers, \"onDrag\", \"drag\", internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, \"onWheel\", \"wheel\", internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, \"onScroll\", \"scroll\", internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, \"onPinch\", \"pinch\", internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, \"onMove\", \"move\", internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, \"onHover\", \"hover\", internalHandlers, mergedConfig);\n  return {\n    handlers: internalHandlers,\n    config: mergedConfig,\n    nativeHandlers\n  };\n}\n\n// node_modules/@use-gesture/react/dist/use-gesture-react.esm.js\nfunction useRecognizers(handlers, config = {}, gestureKey, nativeHandlers) {\n  const ctrl = import_react4.default.useMemo(() => new Controller(handlers), []);\n  ctrl.applyHandlers(handlers, nativeHandlers);\n  ctrl.applyConfig(config, gestureKey);\n  import_react4.default.useEffect(ctrl.effect.bind(ctrl));\n  import_react4.default.useEffect(() => {\n    return ctrl.clean.bind(ctrl);\n  }, []);\n  if (config.target === void 0) {\n    return ctrl.bind.bind(ctrl);\n  }\n  return void 0;\n}\nfunction createUseGesture(actions) {\n  actions.forEach(registerAction);\n  return function useGesture2(_handlers2, _config) {\n    const {\n      handlers,\n      nativeHandlers,\n      config\n    } = parseMergedHandlers(_handlers2, _config || {});\n    return useRecognizers(handlers, config, void 0, nativeHandlers);\n  };\n}\nfunction useGesture(handlers, config) {\n  const hook = createUseGesture([dragAction, pinchAction, scrollAction, wheelAction, moveAction, hoverAction]);\n  return hook(handlers, config || {});\n}\n\n// node_modules/@tldraw/core/dist/index.mjs\nvar V4 = __toESM(require(\"react\"), 1);\nvar import_react6 = require(\"react\");\nvar ot = __toESM(require(\"react\"), 1);\nvar Me = __toESM(require(\"react\"), 1);\nvar ye2 = __toESM(require(\"react\"), 1);\nvar ve = __toESM(require(\"react\"), 1);\nvar pe3 = __toESM(require(\"react\"), 1);\nvar xe2 = __toESM(require(\"react\"), 1);\nvar ut = __toESM(require(\"react\"), 1);\nvar pt = __toESM(require(\"react\"), 1);\nvar ft = __toESM(require(\"react\"), 1);\nvar gt = __toESM(require(\"react\"), 1);\nvar Ke = __toESM(require(\"react\"), 1);\nvar yt = __toESM(require(\"react\"), 1);\nvar xt = __toESM(require(\"react\"), 1);\nvar W2 = __toESM(require(\"react\"), 1);\n\n// node_modules/perfect-freehand/dist/esm/index.js\nfunction $(e5, t5, u5, x5 = (h6) => h6) {\n  return e5 * x5(0.5 - t5 * (0.5 - u5));\n}\nfunction se(e5) {\n  return [-e5[0], -e5[1]];\n}\nfunction l(e5, t5) {\n  return [e5[0] + t5[0], e5[1] + t5[1]];\n}\nfunction a(e5, t5) {\n  return [e5[0] - t5[0], e5[1] - t5[1]];\n}\nfunction b(e5, t5) {\n  return [e5[0] * t5, e5[1] * t5];\n}\nfunction he(e5, t5) {\n  return [e5[0] / t5, e5[1] / t5];\n}\nfunction R(e5) {\n  return [e5[1], -e5[0]];\n}\nfunction B(e5, t5) {\n  return e5[0] * t5[0] + e5[1] * t5[1];\n}\nfunction ue(e5, t5) {\n  return e5[0] === t5[0] && e5[1] === t5[1];\n}\nfunction ge(e5) {\n  return Math.hypot(e5[0], e5[1]);\n}\nfunction de(e5) {\n  return e5[0] * e5[0] + e5[1] * e5[1];\n}\nfunction A(e5, t5) {\n  return de(a(e5, t5));\n}\nfunction G(e5) {\n  return he(e5, ge(e5));\n}\nfunction ie(e5, t5) {\n  return Math.hypot(e5[1] - t5[1], e5[0] - t5[0]);\n}\nfunction L(e5, t5, u5) {\n  let x5 = Math.sin(u5), h6 = Math.cos(u5), y6 = e5[0] - t5[0], n5 = e5[1] - t5[1], f5 = y6 * h6 - n5 * x5, d6 = y6 * x5 + n5 * h6;\n  return [f5 + t5[0], d6 + t5[1]];\n}\nfunction K(e5, t5, u5) {\n  return l(e5, b(a(t5, e5), u5));\n}\nfunction ee(e5, t5, u5) {\n  return l(e5, b(t5, u5));\n}\nvar { min: C, PI: xe } = Math;\nvar pe = 0.275;\nvar V2 = xe + 1e-4;\nfunction ce(e5, t5 = {}) {\n  let { size: u5 = 16, smoothing: x5 = 0.5, thinning: h6 = 0.5, simulatePressure: y6 = true, easing: n5 = (r5) => r5, start: f5 = {}, end: d6 = {}, last: D6 = false } = t5, { cap: S4 = true, easing: j4 = (r5) => r5 * (2 - r5) } = f5, { cap: q4 = true, easing: c5 = (r5) => --r5 * r5 * r5 + 1 } = d6;\n  if (e5.length === 0 || u5 <= 0)\n    return [];\n  let p6 = e5[e5.length - 1].runningLength, g6 = f5.taper === false ? 0 : f5.taper === true ? Math.max(u5, p6) : f5.taper, T5 = d6.taper === false ? 0 : d6.taper === true ? Math.max(u5, p6) : d6.taper, te2 = Math.pow(u5 * x5, 2), _3 = [], M3 = [], H5 = e5.slice(0, 10).reduce((r5, i4) => {\n    let o5 = i4.pressure;\n    if (y6) {\n      let s5 = C(1, i4.distance / u5), W5 = C(1, 1 - s5);\n      o5 = C(1, r5 + (W5 - r5) * (s5 * pe));\n    }\n    return (r5 + o5) / 2;\n  }, e5[0].pressure), m6 = $(u5, h6, e5[e5.length - 1].pressure, n5), U4, X3 = e5[0].vector, z5 = e5[0].point, F4 = z5, O5 = z5, E6 = F4, J3 = false;\n  for (let r5 = 0; r5 < e5.length; r5++) {\n    let { pressure: i4 } = e5[r5], { point: o5, vector: s5, distance: W5, runningLength: I3 } = e5[r5];\n    if (r5 < e5.length - 1 && p6 - I3 < 3)\n      continue;\n    if (h6) {\n      if (y6) {\n        let v6 = C(1, W5 / u5), Z3 = C(1, 1 - v6);\n        i4 = C(1, H5 + (Z3 - H5) * (v6 * pe));\n      }\n      m6 = $(u5, h6, i4, n5);\n    } else\n      m6 = u5 / 2;\n    U4 === void 0 && (U4 = m6);\n    let le3 = I3 < g6 ? j4(I3 / g6) : 1, fe2 = p6 - I3 < T5 ? c5((p6 - I3) / T5) : 1;\n    m6 = Math.max(0.01, m6 * Math.min(le3, fe2));\n    let re3 = (r5 < e5.length - 1 ? e5[r5 + 1] : e5[r5]).vector, Y3 = r5 < e5.length - 1 ? B(s5, re3) : 1, be3 = B(s5, X3) < 0 && !J3, ne2 = Y3 !== null && Y3 < 0;\n    if (be3 || ne2) {\n      let v6 = b(R(X3), m6);\n      for (let Z3 = 1 / 13, w7 = 0; w7 <= 1; w7 += Z3)\n        O5 = L(a(o5, v6), o5, V2 * w7), _3.push(O5), E6 = L(l(o5, v6), o5, V2 * -w7), M3.push(E6);\n      z5 = O5, F4 = E6, ne2 && (J3 = true);\n      continue;\n    }\n    if (J3 = false, r5 === e5.length - 1) {\n      let v6 = b(R(s5), m6);\n      _3.push(a(o5, v6)), M3.push(l(o5, v6));\n      continue;\n    }\n    let oe2 = b(R(K(re3, s5, Y3)), m6);\n    O5 = a(o5, oe2), (r5 <= 1 || A(z5, O5) > te2) && (_3.push(O5), z5 = O5), E6 = l(o5, oe2), (r5 <= 1 || A(F4, E6) > te2) && (M3.push(E6), F4 = E6), H5 = i4, X3 = s5;\n  }\n  let P4 = e5[0].point.slice(0, 2), k6 = e5.length > 1 ? e5[e5.length - 1].point.slice(0, 2) : l(e5[0].point, [1, 1]), Q3 = [], N5 = [];\n  if (e5.length === 1) {\n    if (!(g6 || T5) || D6) {\n      let r5 = ee(P4, G(R(a(P4, k6))), -(U4 || m6)), i4 = [];\n      for (let o5 = 1 / 13, s5 = o5; s5 <= 1; s5 += o5)\n        i4.push(L(r5, P4, V2 * 2 * s5));\n      return i4;\n    }\n  } else {\n    if (!(g6 || T5 && e5.length === 1))\n      if (S4)\n        for (let i4 = 1 / 13, o5 = i4; o5 <= 1; o5 += i4) {\n          let s5 = L(M3[0], P4, V2 * o5);\n          Q3.push(s5);\n        }\n      else {\n        let i4 = a(_3[0], M3[0]), o5 = b(i4, 0.5), s5 = b(i4, 0.51);\n        Q3.push(a(P4, o5), a(P4, s5), l(P4, s5), l(P4, o5));\n      }\n    let r5 = R(se(e5[e5.length - 1].vector));\n    if (T5 || g6 && e5.length === 1)\n      N5.push(k6);\n    else if (q4) {\n      let i4 = ee(k6, r5, m6);\n      for (let o5 = 1 / 29, s5 = o5; s5 < 1; s5 += o5)\n        N5.push(L(i4, k6, V2 * 3 * s5));\n    } else\n      N5.push(l(k6, b(r5, m6)), l(k6, b(r5, m6 * 0.99)), a(k6, b(r5, m6 * 0.99)), a(k6, b(r5, m6)));\n  }\n  return _3.concat(N5, M3.reverse(), Q3);\n}\nfunction me(e5, t5 = {}) {\n  var q4;\n  let { streamline: u5 = 0.5, size: x5 = 16, last: h6 = false } = t5;\n  if (e5.length === 0)\n    return [];\n  let y6 = 0.15 + (1 - u5) * 0.85, n5 = Array.isArray(e5[0]) ? e5 : e5.map(({ x: c5, y: p6, pressure: g6 = 0.5 }) => [c5, p6, g6]);\n  if (n5.length === 2) {\n    let c5 = n5[1];\n    n5 = n5.slice(0, -1);\n    for (let p6 = 1; p6 < 5; p6++)\n      n5.push(K(n5[0], c5, p6 / 4));\n  }\n  n5.length === 1 && (n5 = [...n5, [...l(n5[0], [1, 1]), ...n5[0].slice(2)]]);\n  let f5 = [{ point: [n5[0][0], n5[0][1]], pressure: n5[0][2] >= 0 ? n5[0][2] : 0.25, vector: [1, 1], distance: 0, runningLength: 0 }], d6 = false, D6 = 0, S4 = f5[0], j4 = n5.length - 1;\n  for (let c5 = 1; c5 < n5.length; c5++) {\n    let p6 = h6 && c5 === j4 ? n5[c5].slice(0, 2) : K(S4.point, n5[c5], y6);\n    if (ue(S4.point, p6))\n      continue;\n    let g6 = ie(p6, S4.point);\n    if (D6 += g6, c5 < j4 && !d6) {\n      if (D6 < x5)\n        continue;\n      d6 = true;\n    }\n    S4 = { point: p6, pressure: n5[c5][2] >= 0 ? n5[c5][2] : 0.5, vector: G(a(S4.point, p6)), distance: g6, runningLength: D6 }, f5.push(S4);\n  }\n  return f5[0].vector = ((q4 = f5[1]) == null ? void 0 : q4.vector) || [0, 0], f5;\n}\nfunction ae(e5, t5 = {}) {\n  return ce(me(e5, t5), t5);\n}\nvar _e = ae;\n\n// node_modules/@tldraw/core/dist/index.mjs\nvar Ue = __toESM(require(\"react\"), 1);\nvar he2 = __toESM(require(\"react\"), 1);\nvar ne = __toESM(require(\"react\"), 1);\nvar G3 = __toESM(require(\"react\"), 1);\nvar K3 = __toESM(require(\"react\"), 1);\nvar ae2 = __toESM(require(\"react\"), 1);\nvar $e = __toESM(require(\"react\"), 1);\nvar $3 = __toESM(require(\"react\"), 1);\nvar q2 = __toESM(require(\"react\"), 1);\nvar fe = __toESM(require(\"react\"), 1);\nvar Ne = __toESM(require(\"react\"), 1);\nvar F2 = __toESM(require(\"react\"), 1);\nvar Te2 = __toESM(require(\"react\"), 1);\nvar ge2 = __toESM(require(\"react\"), 1);\nvar de3 = __toESM(require(\"react\"), 1);\nvar oe = __toESM(require(\"react\"), 1);\nvar re = __toESM(require(\"react\"), 1);\nvar Re = __toESM(require(\"react\"), 1);\nvar We = __toESM(require(\"react\"), 1);\nvar le2 = __toESM(require(\"react\"), 1);\nvar j2 = __toESM(require(\"react\"), 1);\nvar Be = __toESM(require(\"react\"), 1);\nvar ce3 = __toESM(require(\"react\"), 1);\nvar ie3 = __toESM(require(\"react\"), 1);\nvar se3 = __toESM(require(\"react\"), 1);\nvar me2 = __toESM(require(\"react\"), 1);\n\n// node_modules/@tldraw/intersect/dist/index.mjs\nvar A2 = Object.defineProperty;\nvar M = Object.defineProperties;\nvar q = Object.getOwnPropertyDescriptors;\nvar X = Object.getOwnPropertySymbols;\nvar V3 = Object.prototype.hasOwnProperty;\nvar $2 = Object.prototype.propertyIsEnumerable;\nvar Y = (e5, n5, t5) => n5 in e5 ? A2(e5, n5, { enumerable: true, configurable: true, writable: true, value: t5 }) : e5[n5] = t5;\nvar g = (e5, n5) => {\n  for (var t5 in n5 || (n5 = {}))\n    V3.call(n5, t5) && Y(e5, t5, n5[t5]);\n  if (X)\n    for (var t5 of X(n5))\n      $2.call(n5, t5) && Y(e5, t5, n5[t5]);\n  return e5;\n};\nvar T = (e5, n5) => M(e5, q(n5));\nfunction l2(e5, ...n5) {\n  return { didIntersect: n5.length > 0, message: e5, points: n5 };\n}\nfunction I(e5, n5, t5 = 0) {\n  let r5 = [e5[0] + n5[0] / 2, e5[1] + n5[1] / 2], i4 = e.rotWith(e5, r5, t5), u5 = e.rotWith(e.add(e5, [n5[0], 0]), r5, t5), s5 = e.rotWith(e.add(e5, n5), r5, t5), o5 = e.rotWith(e.add(e5, [0, n5[1]]), r5, t5);\n  return [[\"top\", [i4, u5]], [\"right\", [u5, s5]], [\"bottom\", [s5, o5]], [\"left\", [o5, i4]]];\n}\nfunction v(e5, n5, t5) {\n  if (t5 === e5 || t5 === n5)\n    return true;\n  let r5 = Math.PI * 2, i4 = (n5 - e5 + r5) % r5, u5 = (t5 - e5 + r5) % r5;\n  return i4 <= Math.PI != u5 > i4;\n}\nfunction ie2(e5, n5) {\n  let t5 = e.slope(e5[0], e5[1]), r5 = e.slope(n5[0], n5[1]);\n  if (t5 === r5)\n    return;\n  if (Number.isNaN(t5) && !Number.isNaN(r5))\n    return [e5[0][0], (e5[0][0] - n5[0][0]) * r5 + n5[0][1]];\n  if (Number.isNaN(r5) && !Number.isNaN(t5))\n    return [n5[0][0], (n5[0][0] - e5[0][0]) * t5 + e5[0][1]];\n  let i4 = (t5 * e5[0][0] - r5 * n5[0][0] + n5[0][1] - e5[0][1]) / (t5 - r5), u5 = r5 * (i4 - n5[0][0]) + n5[0][1];\n  return [i4, u5];\n}\nfunction x(e5, n5, t5, r5) {\n  let [i4, u5] = e5, [s5, o5] = n5, [c5, m6] = t5, [b6, f5] = r5;\n  if (o5 / s5 !== (f5 - m6) / (b6 - c5)) {\n    let p6 = s5 * (f5 - m6) - o5 * (b6 - c5);\n    if (p6 !== 0) {\n      let L5 = ((u5 - m6) * (b6 - c5) - (i4 - c5) * (f5 - m6)) / p6, h6 = ((u5 - m6) * s5 - (i4 - c5) * o5) / p6;\n      if (L5 >= 0 && h6 >= 0 && h6 <= 1)\n        return l2(\"intersection\", [i4 + L5 * s5, u5 + L5 * o5]);\n    }\n  }\n  return l2(\"no intersection\");\n}\nfunction N(e5, n5, t5, r5, i4 = 0) {\n  return G2(t5, r5, i4, e5, n5);\n}\nfunction F(e5, n5, t5, r5, i4, u5) {\n  let s5 = e5, o5 = e.mul(n5, 999999999);\n  return y(s5, o5, t5, r5, i4, u5);\n}\nfunction se2(e5, n5, t5, r5 = 0) {\n  let { minX: i4, minY: u5, width: s5, height: o5 } = t5;\n  return N(e5, n5, [i4, u5], [s5, o5], r5);\n}\nfunction B2(e5, n5, t5, r5) {\n  let i4 = e.sub(e5, t5), u5 = e.sub(r5, t5), s5 = e.sub(n5, e5), o5 = u5[0] * i4[1] - u5[1] * i4[0], c5 = s5[0] * i4[1] - s5[1] * i4[0], m6 = u5[1] * s5[0] - u5[0] * s5[1];\n  if (o5 === 0 || c5 === 0)\n    return l2(\"coincident\");\n  if (m6 === 0)\n    return l2(\"parallel\");\n  if (m6 !== 0) {\n    let b6 = o5 / m6, f5 = c5 / m6;\n    if (0 <= b6 && b6 <= 1 && 0 <= f5 && f5 <= 1)\n      return l2(\"intersection\", e.add(e5, e.mul(s5, b6)));\n  }\n  return l2(\"no intersection\");\n}\nfunction j(e5, n5, t5, r5) {\n  return E(t5, r5, e5, n5);\n}\nfunction k(e5, n5, t5, r5, i4, u5) {\n  let s5 = e.angle(t5, i4), o5 = e.angle(t5, u5), c5 = U(t5, r5, r5, 0, e5, n5);\n  if (!c5.didIntersect)\n    return l2(\"no intersection\");\n  let m6 = c5.points.filter((b6) => v(s5, o5, e.angle(t5, b6)));\n  return m6.length === 0 ? l2(\"no intersection\") : l2(\"intersection\", ...m6);\n}\nfunction R2(e5, n5, t5, r5) {\n  let i4 = (n5[0] - e5[0]) * (n5[0] - e5[0]) + (n5[1] - e5[1]) * (n5[1] - e5[1]), u5 = 2 * ((n5[0] - e5[0]) * (e5[0] - t5[0]) + (n5[1] - e5[1]) * (e5[1] - t5[1])), s5 = t5[0] * t5[0] + t5[1] * t5[1] + e5[0] * e5[0] + e5[1] * e5[1] - 2 * (t5[0] * e5[0] + t5[1] * e5[1]) - r5 * r5, o5 = u5 * u5 - 4 * i4 * s5;\n  if (o5 < 0)\n    return l2(\"outside\");\n  if (o5 === 0)\n    return l2(\"tangent\");\n  let c5 = Math.sqrt(o5), m6 = (-u5 + c5) / (2 * i4), b6 = (-u5 - c5) / (2 * i4);\n  if ((m6 < 0 || m6 > 1) && (b6 < 0 || b6 > 1))\n    return m6 < 0 && b6 < 0 || m6 > 1 && b6 > 1 ? l2(\"outside\") : l2(\"inside\");\n  let f5 = [];\n  return 0 <= m6 && m6 <= 1 && f5.push(e.lrp(e5, n5, m6)), 0 <= b6 && b6 <= 1 && f5.push(e.lrp(e5, n5, b6)), l2(\"intersection\", ...f5);\n}\nfunction y(e5, n5, t5, r5, i4, u5 = 0) {\n  if (r5 === 0 || i4 === 0 || e.isEqual(e5, n5))\n    return l2(\"no intersection\");\n  r5 = r5 < 0 ? r5 : -r5, i4 = i4 < 0 ? i4 : -i4, e5 = e.sub(e.rotWith(e5, t5, -u5), t5), n5 = e.sub(e.rotWith(n5, t5, -u5), t5);\n  let s5 = e.sub(n5, e5), o5 = s5[0] * s5[0] / r5 / r5 + s5[1] * s5[1] / i4 / i4, c5 = 2 * e5[0] * s5[0] / r5 / r5 + 2 * e5[1] * s5[1] / i4 / i4, m6 = e5[0] * e5[0] / r5 / r5 + e5[1] * e5[1] / i4 / i4 - 1, b6 = [], f5 = c5 * c5 - 4 * o5 * m6;\n  if (f5 === 0)\n    b6.push(-c5 / 2 / o5);\n  else if (f5 > 0) {\n    let L5 = Math.sqrt(f5);\n    b6.push((-c5 + L5) / 2 / o5), b6.push((-c5 - L5) / 2 / o5);\n  }\n  let p6 = b6.filter((L5) => L5 >= 0 && L5 <= 1).map((L5) => e.add(t5, e.add(e5, e.mul(e.sub(n5, e5), L5)))).map((L5) => e.rotWith(L5, t5, u5));\n  return l2(\"intersection\", ...p6);\n}\nfunction ce2(e5, n5, t5) {\n  return z(t5, e5, n5);\n}\nfunction S(e5, n5, t5) {\n  let r5 = [];\n  for (let i4 = 1; i4 < t5.length; i4++) {\n    let u5 = B2(e5, n5, t5[i4 - 1], t5[i4]);\n    u5 && r5.push(...u5.points);\n  }\n  return r5.length === 0 ? l2(\"no intersection\") : l2(\"intersection\", ...t5);\n}\nfunction D(e5, n5, t5) {\n  let r5 = [];\n  for (let i4 = 1; i4 < t5.length + 1; i4++) {\n    let u5 = B2(e5, n5, t5[i4 - 1], t5[i4 % t5.length]);\n    u5 && r5.push(...u5.points);\n  }\n  return r5.length === 0 ? l2(\"no intersection\") : l2(\"intersection\", ...t5);\n}\nfunction G2(e5, n5, t5, r5, i4) {\n  return I(e5, n5, t5).reduce((s5, [o5, [c5, m6]]) => {\n    let b6 = x(r5, i4, c5, m6);\n    return b6 && s5.push(l2(o5, ...b6.points)), s5;\n  }, []).filter((s5) => s5.didIntersect);\n}\nfunction E(e5, n5, t5, r5) {\n  return I(e5, n5).reduce((u5, [s5, [o5, c5]]) => {\n    let m6 = B2(t5, r5, o5, c5);\n    return m6 && u5.push(l2(s5, ...m6.points)), u5;\n  }, []).filter((u5) => u5.didIntersect);\n}\nfunction a2(e5, n5, t5, r5) {\n  return I(e5, n5).reduce((u5, [s5, [o5, c5]]) => {\n    let m6 = E(t5, r5, o5, c5);\n    return u5.push(...m6.map((b6) => l2(`${s5} ${b6.message}`, ...b6.points))), u5;\n  }, []).filter((u5) => u5.didIntersect);\n}\nfunction H(e5, n5, t5, r5, i4, u5) {\n  return I(e5, n5).reduce((o5, [c5, [m6, b6]]) => {\n    let f5 = O(t5, r5, i4, u5, m6, b6);\n    return f5 && o5.push(T(g({}, f5), { message: c5 })), o5;\n  }, []).filter((o5) => o5.didIntersect);\n}\nfunction C2(e5, n5, t5, r5) {\n  return I(e5, n5).reduce((u5, [s5, [o5, c5]]) => {\n    let m6 = R2(o5, c5, t5, r5);\n    return m6 && u5.push(T(g({}, m6), { message: s5 })), u5;\n  }, []).filter((u5) => u5.didIntersect);\n}\nfunction J(e5, n5, t5, r5, i4, u5 = 0) {\n  return I(e5, n5).reduce((o5, [c5, [m6, b6]]) => {\n    let f5 = y(m6, b6, t5, r5, i4, u5);\n    return f5 && o5.push(T(g({}, f5), { message: c5 })), o5;\n  }, []).filter((o5) => o5.didIntersect);\n}\nfunction w(e5, n5, t5) {\n  return I(e5, n5).reduce((i4, [u5, [s5, o5]]) => {\n    let c5 = S(s5, o5, t5);\n    return c5.didIntersect && i4.push(l2(u5, ...c5.points)), i4;\n  }, []).filter((i4) => i4.didIntersect);\n}\nfunction K2(e5, n5, t5) {\n  return I(e5, n5).reduce((i4, [u5, [s5, o5]]) => {\n    let c5 = D(s5, o5, t5);\n    return c5.didIntersect && i4.push(l2(u5, ...c5.points)), i4;\n  }, []).filter((i4) => i4.didIntersect);\n}\nfunction O(e5, n5, t5, r5, i4, u5) {\n  return k(i4, u5, e5, n5, t5, r5);\n}\nfunction _(e5, n5, t5, r5, i4, u5) {\n  return H(i4, u5, e5, n5, t5, r5);\n}\nfunction be(e5, n5, t5, r5, i4) {\n  let { minX: u5, minY: s5, width: o5, height: c5 } = i4;\n  return _(e5, n5, t5, r5, [u5, s5], [o5, c5]);\n}\nfunction de2(e5, n5, t5, r5) {\n  return R2(t5, r5, e5, n5);\n}\nfunction le(e5, n5, t5, r5) {\n  let i4 = t5[0] - e5[0], u5 = t5[1] - e5[1], s5 = Math.sqrt(i4 * i4 + u5 * u5), o5 = (s5 * s5 - r5 * r5 + n5 * n5) / (2 * s5), c5 = Math.sqrt(n5 * n5 - o5 * o5);\n  return i4 /= s5, u5 /= s5, l2(\"intersection\", [e5[0] + i4 * o5 - u5 * c5, e5[1] + u5 * o5 + i4 * c5], [e5[0] + i4 * o5 + u5 * c5, e5[1] + u5 * o5 - i4 * c5]);\n}\nfunction U(e5, n5, t5, r5 = 0, i4, u5) {\n  return n5 === t5 ? R2(i4, u5, e5, n5) : y(i4, u5, e5, n5, t5, r5);\n}\nfunction W(e5, n5, t5, r5 = 0, i4, u5) {\n  return n5 === t5 ? C2(i4, u5, e5, n5) : J(i4, u5, e5, n5, t5, r5);\n}\nfunction pe2(e5, n5, t5, r5, i4) {\n  let { minX: u5, minY: s5, width: o5, height: c5 } = i4;\n  return W(e5, n5, t5, r5, [u5, s5], [o5, c5]);\n}\nfunction z(e5, n5, t5) {\n  let { minX: r5, minY: i4, width: u5, height: s5 } = e5;\n  return j(n5, t5, [r5, i4], [u5, s5]);\n}\nfunction Te(e5, n5) {\n  return a2([e5.minX, e5.minY], [e5.width, e5.height], [n5.minX, n5.minY], [n5.width, n5.height]);\n}\nfunction ye(e5, n5) {\n  return Q(n5, e5);\n}\nfunction Se(e5, n5) {\n  return ee2(n5, e5);\n}\nfunction Q(e5, n5) {\n  return w([n5.minX, n5.minY], [n5.width, n5.height], e5);\n}\nfunction ee2(e5, n5) {\n  return K2([n5.minX, n5.minY], [n5.width, n5.height], e5);\n}\n\n// node_modules/@tldraw/core/dist/index.mjs\nvar Ae = __toESM(require(\"react\"), 1);\nvar qt = Object.defineProperty;\nvar Qt = Object.defineProperties;\nvar Jt = Object.getOwnPropertyDescriptors;\nvar Ce = Object.getOwnPropertySymbols;\nvar Ze = Object.prototype.hasOwnProperty;\nvar qe = Object.prototype.propertyIsEnumerable;\nvar Oe = (r5, e5, t5) => e5 in r5 ? qt(r5, e5, { enumerable: true, configurable: true, writable: true, value: t5 }) : r5[e5] = t5;\nvar g2 = (r5, e5) => {\n  for (var t5 in e5 || (e5 = {}))\n    Ze.call(e5, t5) && Oe(r5, t5, e5[t5]);\n  if (Ce)\n    for (var t5 of Ce(e5))\n      qe.call(e5, t5) && Oe(r5, t5, e5[t5]);\n  return r5;\n};\nvar U2 = (r5, e5) => Qt(r5, Jt(e5));\nvar O2 = (r5, e5) => {\n  var t5 = {};\n  for (var n5 in r5)\n    Ze.call(r5, n5) && e5.indexOf(n5) < 0 && (t5[n5] = r5[n5]);\n  if (r5 != null && Ce)\n    for (var n5 of Ce(r5))\n      e5.indexOf(n5) < 0 && qe.call(r5, n5) && (t5[n5] = r5[n5]);\n  return t5;\n};\nvar E2 = (r5, e5, t5) => (Oe(r5, typeof e5 != \"symbol\" ? e5 + \"\" : e5, t5), t5);\nvar Le = Se2.createContext({});\nfunction R3() {\n  return Se2.useContext(Le);\n}\nvar Qe = ((o5) => (o5.TransformSelected = \"transform_selected\", o5.TranslateSelected = \"translate_selected\", o5.TransformAll = \"transform_all\", o5.TranslateAll = \"translate_all\", o5))(Qe || {});\nvar we = ((o5) => (o5.Top = \"top_edge\", o5.Right = \"right_edge\", o5.Bottom = \"bottom_edge\", o5.Left = \"left_edge\", o5))(we || {});\nvar He = ((o5) => (o5.TopLeft = \"top_left_corner\", o5.TopRight = \"top_right_corner\", o5.BottomRight = \"bottom_right_corner\", o5.BottomLeft = \"bottom_left_corner\", o5))(He || {});\nvar Je = ((s5) => (s5.minX = \"minX\", s5.midX = \"midX\", s5.maxX = \"maxX\", s5.minY = \"minY\", s5.midY = \"midY\", s5.maxY = \"maxY\", s5))(Je || {});\nString.prototype.replaceAll || (String.prototype.replaceAll = function(r5, e5) {\n  return Object.prototype.toString.call(r5).toLowerCase() === \"[object regexp]\" ? this.replace(r5, e5) : this.replace(new RegExp(r5, \"g\"), e5);\n});\nvar Ie = Math.PI * 2;\nvar k2 = class {\n  static lerp(e5, t5, n5) {\n    return n5 = k2.clamp(n5, 0, 1), e5 * (1 - n5) + t5 * n5;\n  }\n  static lerpColor(e5, t5, n5 = 0.5) {\n    function o5(l7) {\n      let c5 = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(l7);\n      return [parseInt(c5[1], 16), parseInt(c5[2], 16), parseInt(c5[3], 16)];\n    }\n    function i4(l7) {\n      return \"#\" + ((1 << 24) + (l7[0] << 16) + (l7[1] << 8) + l7[2]).toString(16).slice(1);\n    }\n    let s5 = o5(e5) || [0, 0, 0], a7 = o5(t5) || [0, 0, 0], d6 = s5.slice();\n    for (let l7 = 0; l7 < 3; l7++)\n      d6[l7] = Math.round(d6[l7] + n5 * (a7[l7] - s5[l7]));\n    return i4(d6);\n  }\n  static modulate(e5, t5, n5, o5 = false) {\n    let [i4, s5] = t5, [a7, d6] = n5, l7 = a7 + (e5 - i4) / (s5 - i4) * (d6 - a7);\n    return o5 ? a7 < d6 ? Math.max(Math.min(l7, d6), a7) : Math.max(Math.min(l7, a7), d6) : l7;\n  }\n  static clamp(e5, t5, n5) {\n    return Math.max(t5, typeof n5 != \"undefined\" ? Math.min(e5, n5) : e5);\n  }\n  static deepClone(e5) {\n    if (e5 === null)\n      return e5;\n    if (Array.isArray(e5))\n      return [...e5];\n    if (typeof e5 == \"object\") {\n      let t5 = g2({}, e5);\n      return Object.keys(t5).forEach((n5) => t5[n5] = typeof e5[n5] == \"object\" ? k2.deepClone(e5[n5]) : e5[n5]), t5;\n    }\n    return e5;\n  }\n  static rng(e5 = \"\") {\n    let t5 = 0, n5 = 0, o5 = 0, i4 = 0;\n    function s5() {\n      let a7 = t5 ^ t5 << 11;\n      return t5 = n5, n5 = o5, o5 = i4, i4 ^= (i4 >>> 19 ^ a7 ^ a7 >>> 8) >>> 0, i4 / 4294967296;\n    }\n    for (let a7 = 0; a7 < e5.length + 64; a7++)\n      t5 ^= e5.charCodeAt(a7) | 0, s5();\n    return s5;\n  }\n  static pointsToLineSegments(e5, t5 = false) {\n    let n5 = [];\n    for (let o5 = 1; o5 < e5.length; o5++)\n      n5.push([e5[o5 - 1], e5[o5]]);\n    return t5 && n5.push([e5[e5.length - 1], e5[0]]), n5;\n  }\n  static getRectangleSides(e5, t5, n5 = 0) {\n    let o5 = [e5[0] + t5[0] / 2, e5[1] + t5[1] / 2], i4 = e.rotWith(e5, o5, n5), s5 = e.rotWith(e.add(e5, [t5[0], 0]), o5, n5), a7 = e.rotWith(e.add(e5, t5), o5, n5), d6 = e.rotWith(e.add(e5, [0, t5[1]]), o5, n5);\n    return [[\"top\", [i4, s5]], [\"right\", [s5, a7]], [\"bottom\", [a7, d6]], [\"left\", [d6, i4]]];\n  }\n  static circleFromThreePoints(e5, t5, n5) {\n    let [o5, i4] = e5, [s5, a7] = t5, [d6, l7] = n5, c5 = o5 * (a7 - l7) - i4 * (s5 - d6) + s5 * l7 - d6 * a7, m6 = (o5 * o5 + i4 * i4) * (l7 - a7) + (s5 * s5 + a7 * a7) * (i4 - l7) + (d6 * d6 + l7 * l7) * (a7 - i4), p6 = (o5 * o5 + i4 * i4) * (s5 - d6) + (s5 * s5 + a7 * a7) * (d6 - o5) + (d6 * d6 + l7 * l7) * (o5 - s5), u5 = -m6 / (2 * c5), y6 = -p6 / (2 * c5);\n    return [u5, y6, Math.hypot(u5 - o5, y6 - i4)];\n  }\n  static perimeterOfEllipse(e5, t5) {\n    let n5 = Math.pow(e5 - t5, 2) / Math.pow(e5 + t5, 2);\n    return Math.PI * (e5 + t5) * (1 + 3 * n5 / (10 + Math.sqrt(4 - 3 * n5)));\n  }\n  static shortAngleDist(e5, t5) {\n    let n5 = Math.PI * 2, o5 = (t5 - e5) % n5;\n    return 2 * o5 % n5 - o5;\n  }\n  static longAngleDist(e5, t5) {\n    return Math.PI * 2 - k2.shortAngleDist(e5, t5);\n  }\n  static lerpAngles(e5, t5, n5) {\n    return e5 + k2.shortAngleDist(e5, t5) * n5;\n  }\n  static angleDelta(e5, t5) {\n    return k2.shortAngleDist(e5, t5);\n  }\n  static getSweep(e5, t5, n5) {\n    return k2.angleDelta(e.angle(e5, t5), e.angle(e5, n5));\n  }\n  static clampRadians(e5) {\n    return (Math.PI * 2 + e5) % (Math.PI * 2);\n  }\n  static snapAngleToSegments(e5, t5) {\n    let n5 = Math.PI * 2 / t5;\n    return Math.floor((k2.clampRadians(e5) + n5 / 2) / n5) * n5;\n  }\n  static isAngleBetween(e5, t5, n5) {\n    if (n5 === e5 || n5 === t5)\n      return true;\n    let o5 = (t5 - e5 + Ie) % Ie, i4 = (n5 - e5 + Ie) % Ie;\n    return o5 <= Math.PI != i4 > o5;\n  }\n  static degreesToRadians(e5) {\n    return e5 * Math.PI / 180;\n  }\n  static radiansToDegrees(e5) {\n    return e5 * 180 / Math.PI;\n  }\n  static getArcLength(e5, t5, n5, o5) {\n    let i4 = k2.getSweep(e5, n5, o5);\n    return t5 * (2 * Math.PI) * (i4 / (2 * Math.PI));\n  }\n  static getSweepFlag(e5, t5, n5) {\n    let o5 = e.angle(e5, n5);\n    return (e.angle(e5, t5) - o5 + 3 * Math.PI) % (2 * Math.PI) - Math.PI > 0 ? 0 : 1;\n  }\n  static getLargeArcFlag(e5, t5, n5) {\n    let o5 = e.angle(n5, e5), s5 = (e.angle(n5, t5) - o5 + 3 * Math.PI) % (2 * Math.PI) - Math.PI;\n    return Math.abs(s5) > Math.PI / 2 ? 0 : 1;\n  }\n  static getArcDashOffset(e5, t5, n5, o5, i4) {\n    let s5 = k2.getSweepFlag(e5, n5, o5), a7 = k2.getArcLength(e5, t5, n5, o5);\n    return -(s5 < 0 ? a7 : 2 * Math.PI * e5[2] - a7) / 2 + i4;\n  }\n  static getEllipseDashOffset(e5, t5) {\n    return -(2 * Math.PI * e5[2]) / 2 + -t5;\n  }\n  static pointInCircle(e5, t5, n5) {\n    return e.dist(e5, t5) <= n5;\n  }\n  static pointInEllipse(e5, t5, n5, o5, i4 = 0) {\n    i4 = i4 || 0;\n    let s5 = Math.cos(i4), a7 = Math.sin(i4), d6 = e.sub(e5, t5), l7 = s5 * d6[0] + a7 * d6[1], c5 = a7 * d6[0] - s5 * d6[1];\n    return l7 * l7 / (n5 * n5) + c5 * c5 / (o5 * o5) <= 1;\n  }\n  static pointInRect(e5, t5) {\n    return !(e5[0] < t5[0] || e5[0] > e5[0] + t5[0] || e5[1] < t5[1] || e5[1] > e5[1] + t5[1]);\n  }\n  static pointInPolygon(e5, t5) {\n    let n5 = 0;\n    return t5.forEach((o5, i4) => {\n      let s5 = t5[(i4 + 1) % t5.length];\n      o5[1] <= e5[1] ? s5[1] > e5[1] && e.cross(o5, s5, e5) > 0 && (n5 += 1) : s5[1] <= e5[1] && e.cross(o5, s5, e5) < 0 && (n5 -= 1);\n    }), n5 !== 0;\n  }\n  static pointInBounds(e5, t5) {\n    return !(e5[0] < t5.minX || e5[0] > t5.maxX || e5[1] < t5.minY || e5[1] > t5.maxY);\n  }\n  static pointInPolyline(e5, t5, n5 = 3) {\n    for (let o5 = 1; o5 < t5.length; o5++)\n      if (e.distanceToLineSegment(t5[o5 - 1], t5[o5], e5) < n5)\n        return true;\n    return false;\n  }\n  static getBoundsSides(e5) {\n    return this.getRectangleSides([e5.minX, e5.minY], [e5.width, e5.height]);\n  }\n  static expandBounds(e5, t5) {\n    return { minX: e5.minX - t5, minY: e5.minY - t5, maxX: e5.maxX + t5, maxY: e5.maxY + t5, width: e5.width + t5 * 2, height: e5.height + t5 * 2 };\n  }\n  static boundsCollide(e5, t5) {\n    return !(e5.maxX < t5.minX || e5.minX > t5.maxX || e5.maxY < t5.minY || e5.minY > t5.maxY);\n  }\n  static boundsContain(e5, t5) {\n    return e5.minX < t5.minX && e5.minY < t5.minY && e5.maxY > t5.maxY && e5.maxX > t5.maxX;\n  }\n  static boundsContained(e5, t5) {\n    return k2.boundsContain(t5, e5);\n  }\n  static boundsAreEqual(e5, t5) {\n    return !(t5.maxX !== e5.maxX || t5.minX !== e5.minX || t5.maxY !== e5.maxY || t5.minY !== e5.minY);\n  }\n  static getBoundsFromPoints(e5, t5 = 0) {\n    let n5 = 1 / 0, o5 = 1 / 0, i4 = -1 / 0, s5 = -1 / 0;\n    if (e5.length < 2)\n      n5 = 0, o5 = 0, i4 = 1, s5 = 1;\n    else\n      for (let [a7, d6] of e5)\n        n5 = Math.min(a7, n5), o5 = Math.min(d6, o5), i4 = Math.max(a7, i4), s5 = Math.max(d6, s5);\n    return t5 !== 0 ? k2.getBoundsFromPoints(e5.map((a7) => e.rotWith(a7, [(n5 + i4) / 2, (o5 + s5) / 2], t5))) : { minX: n5, minY: o5, maxX: i4, maxY: s5, width: Math.max(1, i4 - n5), height: Math.max(1, s5 - o5) };\n  }\n  static centerBounds(e5, t5) {\n    let n5 = this.getBoundsCenter(e5), o5 = t5[0] - n5[0], i4 = t5[1] - n5[1];\n    return this.translateBounds(e5, [o5, i4]);\n  }\n  static snapBoundsToGrid(e5, t5) {\n    let n5 = Math.round(e5.minX / t5) * t5, o5 = Math.round(e5.minY / t5) * t5, i4 = Math.round(e5.maxX / t5) * t5, s5 = Math.round(e5.maxY / t5) * t5;\n    return { minX: n5, minY: o5, maxX: i4, maxY: s5, width: Math.max(1, i4 - n5), height: Math.max(1, s5 - o5) };\n  }\n  static translateBounds(e5, t5) {\n    return { minX: e5.minX + t5[0], minY: e5.minY + t5[1], maxX: e5.maxX + t5[0], maxY: e5.maxY + t5[1], width: e5.width, height: e5.height };\n  }\n  static rotateBounds(e5, t5, n5) {\n    let [o5, i4] = e.rotWith([e5.minX, e5.minY], t5, n5), [s5, a7] = e.rotWith([e5.maxX, e5.maxY], t5, n5);\n    return { minX: o5, minY: i4, maxX: s5, maxY: a7, width: e5.width, height: e5.height };\n  }\n  static getRotatedEllipseBounds(e5, t5, n5, o5, i4 = 0) {\n    let s5 = Math.cos(i4), a7 = Math.sin(i4), d6 = Math.hypot(n5 * s5, o5 * a7), l7 = Math.hypot(n5 * a7, o5 * s5);\n    return { minX: e5 + n5 - d6, minY: t5 + o5 - l7, maxX: e5 + n5 + d6, maxY: t5 + o5 + l7, width: d6 * 2, height: l7 * 2 };\n  }\n  static getExpandedBounds(e5, t5) {\n    let n5 = Math.min(e5.minX, t5.minX), o5 = Math.min(e5.minY, t5.minY), i4 = Math.max(e5.maxX, t5.maxX), s5 = Math.max(e5.maxY, t5.maxY), a7 = Math.abs(i4 - n5), d6 = Math.abs(s5 - o5);\n    return { minX: n5, minY: o5, maxX: i4, maxY: s5, width: a7, height: d6 };\n  }\n  static getCommonBounds(e5) {\n    if (e5.length < 2)\n      return e5[0];\n    let t5 = e5[0];\n    for (let n5 = 1; n5 < e5.length; n5++)\n      t5 = k2.getExpandedBounds(t5, e5[n5]);\n    return t5;\n  }\n  static getRotatedCorners(e5, t5 = 0) {\n    let n5 = [e5.minX + e5.width / 2, e5.minY + e5.height / 2];\n    return [[e5.minX, e5.minY], [e5.maxX, e5.minY], [e5.maxX, e5.maxY], [e5.minX, e5.maxY]].map((o5) => e.rotWith(o5, n5, t5));\n  }\n  static getTransformedBoundingBox(e5, t5, n5, o5 = 0, i4 = false) {\n    let [s5, a7] = [e5.minX, e5.minY], [d6, l7] = [e5.maxX, e5.maxY], [c5, m6] = [e5.minX, e5.minY], [p6, u5] = [e5.maxX, e5.maxY];\n    if (t5 === \"center\")\n      return { minX: c5 + n5[0], minY: m6 + n5[1], maxX: p6 + n5[0], maxY: u5 + n5[1], width: p6 - c5, height: u5 - m6, scaleX: 1, scaleY: 1 };\n    let [y6, T5] = e.rot(n5, -o5);\n    switch (t5) {\n      case \"top_edge\":\n      case \"top_left_corner\":\n      case \"top_right_corner\": {\n        m6 += T5;\n        break;\n      }\n      case \"bottom_edge\":\n      case \"bottom_left_corner\":\n      case \"bottom_right_corner\": {\n        u5 += T5;\n        break;\n      }\n    }\n    switch (t5) {\n      case \"left_edge\":\n      case \"top_left_corner\":\n      case \"bottom_left_corner\": {\n        c5 += y6;\n        break;\n      }\n      case \"right_edge\":\n      case \"top_right_corner\":\n      case \"bottom_right_corner\": {\n        p6 += y6;\n        break;\n      }\n    }\n    let v6 = d6 - s5, x5 = l7 - a7, f5 = (p6 - c5) / v6, L5 = (u5 - m6) / x5, Y3 = f5 < 0, X3 = L5 < 0, S4 = Math.abs(p6 - c5), b6 = Math.abs(u5 - m6);\n    if (i4) {\n      let P4 = v6 / x5, B4 = P4 < S4 / b6, M3 = S4 * (L5 < 0 ? 1 : -1) * (1 / P4), I3 = b6 * (f5 < 0 ? 1 : -1) * P4;\n      switch (t5) {\n        case \"top_left_corner\": {\n          B4 ? m6 = u5 + M3 : c5 = p6 + I3;\n          break;\n        }\n        case \"top_right_corner\": {\n          B4 ? m6 = u5 + M3 : p6 = c5 - I3;\n          break;\n        }\n        case \"bottom_right_corner\": {\n          B4 ? u5 = m6 - M3 : p6 = c5 - I3;\n          break;\n        }\n        case \"bottom_left_corner\": {\n          B4 ? u5 = m6 - M3 : c5 = p6 + I3;\n          break;\n        }\n        case \"bottom_edge\":\n        case \"top_edge\": {\n          let A5 = (c5 + p6) / 2, J3 = b6 * P4;\n          c5 = A5 - J3 / 2, p6 = A5 + J3 / 2;\n          break;\n        }\n        case \"left_edge\":\n        case \"right_edge\": {\n          let A5 = (m6 + u5) / 2, J3 = S4 / P4;\n          m6 = A5 - J3 / 2, u5 = A5 + J3 / 2;\n          break;\n        }\n      }\n    }\n    if (o5 % (Math.PI * 2) !== 0) {\n      let P4 = [0, 0], B4 = e.med([s5, a7], [d6, l7]), M3 = e.med([c5, m6], [p6, u5]);\n      switch (t5) {\n        case \"top_left_corner\": {\n          P4 = e.sub(e.rotWith([p6, u5], M3, o5), e.rotWith([d6, l7], B4, o5));\n          break;\n        }\n        case \"top_right_corner\": {\n          P4 = e.sub(e.rotWith([c5, u5], M3, o5), e.rotWith([s5, l7], B4, o5));\n          break;\n        }\n        case \"bottom_right_corner\": {\n          P4 = e.sub(e.rotWith([c5, m6], M3, o5), e.rotWith([s5, a7], B4, o5));\n          break;\n        }\n        case \"bottom_left_corner\": {\n          P4 = e.sub(e.rotWith([p6, m6], M3, o5), e.rotWith([d6, a7], B4, o5));\n          break;\n        }\n        case \"top_edge\": {\n          P4 = e.sub(e.rotWith(e.med([c5, u5], [p6, u5]), M3, o5), e.rotWith(e.med([s5, l7], [d6, l7]), B4, o5));\n          break;\n        }\n        case \"left_edge\": {\n          P4 = e.sub(e.rotWith(e.med([p6, m6], [p6, u5]), M3, o5), e.rotWith(e.med([d6, a7], [d6, l7]), B4, o5));\n          break;\n        }\n        case \"bottom_edge\": {\n          P4 = e.sub(e.rotWith(e.med([c5, m6], [p6, m6]), M3, o5), e.rotWith(e.med([s5, a7], [d6, a7]), B4, o5));\n          break;\n        }\n        case \"right_edge\": {\n          P4 = e.sub(e.rotWith(e.med([c5, m6], [c5, u5]), M3, o5), e.rotWith(e.med([s5, a7], [s5, l7]), B4, o5));\n          break;\n        }\n      }\n      [c5, m6] = e.sub([c5, m6], P4), [p6, u5] = e.sub([p6, u5], P4);\n    }\n    return p6 < c5 && ([p6, c5] = [c5, p6]), u5 < m6 && ([u5, m6] = [m6, u5]), { minX: c5, minY: m6, maxX: p6, maxY: u5, width: p6 - c5, height: u5 - m6, scaleX: (p6 - c5) / (d6 - s5 || 1) * (Y3 ? -1 : 1), scaleY: (u5 - m6) / (l7 - a7 || 1) * (X3 ? -1 : 1) };\n  }\n  static getTransformAnchor(e5, t5, n5) {\n    let o5 = e5;\n    switch (e5) {\n      case \"top_left_corner\": {\n        t5 && n5 ? o5 = \"bottom_right_corner\" : t5 ? o5 = \"top_right_corner\" : n5 ? o5 = \"bottom_left_corner\" : o5 = \"bottom_right_corner\";\n        break;\n      }\n      case \"top_right_corner\": {\n        t5 && n5 ? o5 = \"bottom_left_corner\" : t5 ? o5 = \"top_left_corner\" : n5 ? o5 = \"bottom_right_corner\" : o5 = \"bottom_left_corner\";\n        break;\n      }\n      case \"bottom_right_corner\": {\n        t5 && n5 ? o5 = \"top_left_corner\" : t5 ? o5 = \"bottom_left_corner\" : n5 ? o5 = \"top_right_corner\" : o5 = \"top_left_corner\";\n        break;\n      }\n      case \"bottom_left_corner\": {\n        t5 && n5 ? o5 = \"top_right_corner\" : t5 ? o5 = \"bottom_right_corner\" : n5 ? o5 = \"top_left_corner\" : o5 = \"top_right_corner\";\n        break;\n      }\n    }\n    return o5;\n  }\n  static getRelativeTransformedBoundingBox(e5, t5, n5, o5, i4) {\n    let s5 = (o5 ? t5.maxX - n5.maxX : n5.minX - t5.minX) / t5.width, a7 = (i4 ? t5.maxY - n5.maxY : n5.minY - t5.minY) / t5.height, d6 = n5.width / t5.width, l7 = n5.height / t5.height, c5 = e5.minX + e5.width * s5, m6 = e5.minY + e5.height * a7, p6 = e5.width * d6, u5 = e5.height * l7;\n    return { minX: c5, minY: m6, maxX: c5 + p6, maxY: m6 + u5, width: p6, height: u5 };\n  }\n  static getRotatedSize(e5, t5) {\n    let n5 = e.div(e5, 2), o5 = [[0, 0], [e5[0], 0], e5, [0, e5[1]]].map((s5) => e.rotWith(s5, n5, t5)), i4 = k2.getBoundsFromPoints(o5);\n    return [i4.width, i4.height];\n  }\n  static getBoundsCenter(e5) {\n    return [e5.minX + e5.width / 2, e5.minY + e5.height / 2];\n  }\n  static getBoundsWithCenter(e5) {\n    let t5 = k2.getBoundsCenter(e5);\n    return U2(g2({}, e5), { midX: t5[0], midY: t5[1] });\n  }\n  static getCommonTopLeft(e5) {\n    let t5 = [1 / 0, 1 / 0];\n    return e5.forEach((n5) => {\n      t5[0] = Math.min(t5[0], n5[0]), t5[1] = Math.min(t5[1], n5[1]);\n    }), t5;\n  }\n  static getFromCache(e5, t5, n5) {\n    let o5 = e5.get(t5);\n    if (o5 === void 0 && (e5.set(t5, n5()), o5 = e5.get(t5), o5 === void 0))\n      throw Error(\"Cache did not include item!\");\n    return o5;\n  }\n  static uniqueId(e5 = \"\") {\n    return e5 ? ((Number(e5) ^ Math.random() * 16) >> Number(e5) / 4).toString(16) : `${1e7}-${1e3}-${4e3}-${8e3}-${1e11}`.replace(/[018]/g, k2.uniqueId);\n  }\n  static rotateArray(e5, t5) {\n    return e5.map((n5, o5) => e5[(o5 + t5) % e5.length]);\n  }\n  static debounce(e5, t5 = 0) {\n    let n5;\n    return function(...o5) {\n      clearTimeout(n5), n5 = setTimeout(() => e5.apply(o5), t5);\n    };\n  }\n  static getSvgPathFromStroke(e5, t5 = true) {\n    let n5 = e5.length;\n    if (n5 < 4)\n      return \"\";\n    let o5 = e5[0], i4 = e5[1], s5 = e5[2], a7 = `M${o5[0].toFixed(2)},${o5[1].toFixed(2)} Q${i4[0].toFixed(2)},${i4[1].toFixed(2)} ${ee3(i4[0], s5[0]).toFixed(2)},${ee3(i4[1], s5[1]).toFixed(2)} T`;\n    for (let d6 = 2, l7 = n5 - 1; d6 < l7; d6++)\n      o5 = e5[d6], i4 = e5[d6 + 1], a7 += `${ee3(o5[0], i4[0]).toFixed(2)},${ee3(o5[1], i4[1]).toFixed(2)} `;\n    return t5 && (a7 += \"Z\"), a7;\n  }\n  static getSvgPathFromStrokePoints(e5, t5 = false) {\n    let n5 = e5.length;\n    if (n5 < 4)\n      return \"\";\n    let o5 = e5[0].point, i4 = e5[1].point, s5 = e5[2].point, a7 = `M${o5[0].toFixed(2)},${o5[1].toFixed(2)} Q${i4[0].toFixed(2)},${i4[1].toFixed(2)} ${ee3(i4[0], s5[0]).toFixed(2)},${ee3(i4[1], s5[1]).toFixed(2)} T`;\n    for (let d6 = 2, l7 = n5 - 1; d6 < l7; d6++)\n      o5 = e5[d6].point, i4 = e5[d6 + 1].point, a7 += `${ee3(o5[0], i4[0]).toFixed(2)},${ee3(o5[1], i4[1]).toFixed(2)} `;\n    return t5 && (a7 += \"Z\"), a7;\n  }\n  static getPerfectDashProps(e5, t5, n5, o5 = 1, i4 = true, s5 = 2) {\n    let a7, d6, l7;\n    if (n5.toLowerCase() === \"dashed\")\n      a7 = t5 * s5, l7 = 1, d6 = i4 ? (a7 / 2).toString() : \"0\";\n    else if (n5.toLowerCase() === \"dotted\")\n      a7 = t5 / 100, l7 = 100, d6 = \"0\";\n    else\n      return { strokeDasharray: \"none\", strokeDashoffset: \"none\" };\n    let c5 = Math.floor(e5 / a7 / (2 * l7));\n    c5 -= c5 % o5, c5 = Math.max(c5, 4);\n    let m6 = Math.max(a7, (e5 - c5 * a7) / (i4 ? c5 : c5 - 1));\n    return { strokeDasharray: [a7, m6].join(\" \"), strokeDashoffset: d6 };\n  }\n  static isMobileSafari() {\n    if (typeof window == \"undefined\")\n      return false;\n    let e5 = window.navigator.userAgent, t5 = !!e5.match(/iPad/i) || !!e5.match(/iPhone/i), n5 = !!e5.match(/WebKit/i);\n    return t5 && n5 && !e5.match(/CriOS/i);\n  }\n  static throttle(e5, t5) {\n    let n5, o5;\n    return function(...i4) {\n      return n5 || (n5 = true, setTimeout(() => n5 = false, t5), o5 = e5(...i4)), o5;\n    };\n  }\n  static isDarwin() {\n    return /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);\n  }\n  static metaKey(e5) {\n    return k2.isDarwin() ? e5.metaKey : e5.ctrlKey;\n  }\n  static lns(e5) {\n    let t5 = e5.split(\"\");\n    return t5.push(...t5.splice(0, Math.round(t5.length / 5))), t5.push(...t5.splice(0, Math.round(t5.length / 4))), t5.push(...t5.splice(0, Math.round(t5.length / 3))), t5.push(...t5.splice(0, Math.round(t5.length / 2))), t5.reverse().map((n5) => +n5 ? +n5 < 5 ? 5 + +n5 : +n5 > 5 ? +n5 - 5 : n5 : n5).join(\"\");\n  }\n};\nvar C3 = k2;\nE2(C3, \"getSnapPoints\", (e5, t5, n5) => {\n  let o5 = g2({}, e5), i4 = [0, 0], s5 = [], a7 = { [\"minX\"]: { id: \"minX\", isSnapped: false }, [\"midX\"]: { id: \"midX\", isSnapped: false }, [\"maxX\"]: { id: \"maxX\", isSnapped: false }, [\"minY\"]: { id: \"minY\", isSnapped: false }, [\"midY\"]: { id: \"midY\", isSnapped: false }, [\"maxY\"]: { id: \"maxY\", isSnapped: false } }, d6 = [\"midX\", \"minX\", \"maxX\"], l7 = [\"midY\", \"minY\", \"maxY\"], c5 = t5.map((T5) => {\n    let v6 = d6.flatMap((f5, L5) => d6.map((Y3, X3) => {\n      let S4 = o5[f5] - T5[Y3], b6 = Math.abs(S4);\n      return { f: f5, t: Y3, gap: S4, distance: b6, isCareful: L5 === 0 || L5 + X3 === 3 };\n    })), x5 = l7.flatMap((f5, L5) => l7.map((Y3, X3) => {\n      let S4 = o5[f5] - T5[Y3], b6 = Math.abs(S4);\n      return { f: f5, t: Y3, gap: S4, distance: b6, isCareful: L5 === 0 || L5 + X3 === 3 };\n    }));\n    return [T5, v6, x5];\n  }), m6 = 1 / 0, p6 = 1 / 0, u5 = 1 / 0, y6 = 1 / 0;\n  return c5.forEach(([T5, v6, x5]) => {\n    v6.forEach((f5) => {\n      f5.distance < n5 && f5.distance < u5 && (u5 = f5.distance, m6 = f5.gap);\n    }), x5.forEach((f5) => {\n      f5.distance < n5 && f5.distance < y6 && (y6 = f5.distance, p6 = f5.gap);\n    });\n  }), c5.forEach(([T5, v6, x5]) => {\n    m6 !== 1 / 0 && v6.forEach((f5) => {\n      Math.abs(f5.gap - m6) < 2 && (a7[f5.f] = U2(g2({}, a7[f5.f]), { isSnapped: true, to: T5[f5.t], B: T5, distance: f5.distance }));\n    }), p6 !== 1 / 0 && x5.forEach((f5) => {\n      Math.abs(f5.gap - p6) < 2 && (a7[f5.f] = U2(g2({}, a7[f5.f]), { isSnapped: true, to: T5[f5.t], B: T5, distance: f5.distance }));\n    });\n  }), i4[0] = m6 === 1 / 0 ? 0 : m6, i4[1] = p6 === 1 / 0 ? 0 : p6, o5.minX -= i4[0], o5.midX -= i4[0], o5.maxX -= i4[0], o5.minY -= i4[1], o5.midY -= i4[1], o5.maxY -= i4[1], d6.forEach((T5) => {\n    let v6 = a7[T5];\n    if (!v6.isSnapped)\n      return;\n    let { id: x5, B: f5 } = v6, L5 = o5[x5];\n    s5.push(x5 === \"minX\" ? [[L5, o5.midY], [L5, f5.minY], [L5, f5.maxY]] : [[L5, o5.minY], [L5, o5.maxY], [L5, f5.minY], [L5, f5.maxY]]);\n  }), l7.forEach((T5) => {\n    let v6 = a7[T5];\n    if (!v6.isSnapped)\n      return;\n    let { id: x5, B: f5 } = v6, L5 = o5[x5];\n    s5.push(x5 === \"midY\" ? [[o5.midX, L5], [f5.minX, L5], [f5.maxX, L5]] : [[o5.minX, L5], [o5.maxX, L5], [f5.minX, L5], [f5.maxX, L5]]);\n  }), { offset: i4, snapLines: s5 };\n}), E2(C3, \"deepMerge\", (e5, t5) => {\n  let n5 = g2({}, e5), o5 = Object.entries(t5);\n  for (let [i4, s5] of o5)\n    n5[i4] = s5 === Object(s5) && !Array.isArray(s5) ? k2.deepMerge(n5[i4], s5) : s5;\n  return n5;\n});\nfunction ee3(r5, e5) {\n  return (r5 + e5) / 2;\n}\nvar w2 = C3;\nfunction tt(r5, e5) {\n  let t5 = V4.useRef(void 0), n5 = V4.useRef(void 0), o5 = V4.useRef([0, 0]), i4 = V4.useRef(0), { inputs: s5, bounds: a7, callbacks: d6 } = R3();\n  V4.useEffect(() => {\n    let u5 = (y6) => y6.preventDefault();\n    return document.addEventListener(\"gesturestart\", u5), document.addEventListener(\"gesturechange\", u5), () => {\n      document.removeEventListener(\"gesturestart\", u5), document.removeEventListener(\"gesturechange\", u5);\n    };\n  }, []);\n  let l7 = V4.useCallback(({ event: u5 }) => {\n    var L5, Y3, X3, S4;\n    if (u5.preventDefault(), s5.isPinching || u5.timeStamp <= i4.current)\n      return;\n    i4.current = u5.timeStamp;\n    let [y6, T5, v6] = tn(u5);\n    if ((u5.altKey || u5.ctrlKey || u5.metaKey) && u5.buttons === 0) {\n      let P4 = [...(Y3 = (L5 = s5.pointer) == null ? void 0 : L5.point) != null ? Y3 : [a7.width / 2, a7.height / 2], v6 * 0.618], B4 = s5.pan(P4, u5);\n      (X3 = d6.onZoom) == null || X3.call(d6, U2(g2({}, B4), { delta: P4 }), u5);\n      return;\n    }\n    let x5 = e.mul(u5.shiftKey && !w2.isDarwin() ? [T5, 0] : [y6, T5], 0.5);\n    if (e.isEqual(x5, [0, 0]))\n      return;\n    let f5 = s5.pan(x5, u5);\n    (S4 = d6.onPan) == null || S4.call(d6, f5, u5);\n  }, [d6, s5, a7]), c5 = V4.useCallback(({ origin: u5, event: y6 }) => {\n    var x5;\n    if (y6 instanceof WheelEvent)\n      return;\n    let T5 = e5.current;\n    if (!T5 || !(y6.target === T5 || T5.contains(y6.target)))\n      return;\n    let v6 = s5.pinch(u5, u5);\n    s5.isPinching = true, (x5 = d6.onPinchStart) == null || x5.call(d6, v6, y6), n5.current = v6.point, t5.current = v6.origin, o5.current = [0, 0];\n  }, [d6, s5, a7]), m6 = V4.useCallback(({ origin: u5, offset: y6, event: T5 }) => {\n    var L5;\n    if (T5 instanceof WheelEvent)\n      return;\n    let v6 = e5.current;\n    if (!(T5.target === v6 || (v6 == null ? void 0 : v6.contains(T5.target))) || !t5.current)\n      return;\n    let x5 = s5.pinch(u5, t5.current), f5 = e.sub(x5.delta, o5.current);\n    o5.current = x5.delta, (L5 = d6.onPinch) == null || L5.call(d6, U2(g2({}, x5), { point: x5.point, origin: t5.current, delta: [...f5, y6[0]] }), T5), n5.current = u5;\n  }, [d6, s5, a7]), p6 = V4.useCallback(({ origin: u5, event: y6 }) => {\n    var x5;\n    let T5 = e5.current;\n    if (!(y6.target === T5 || (T5 == null ? void 0 : T5.contains(y6.target))))\n      return;\n    let v6 = s5.pinch(u5, u5);\n    s5.isPinching = false, (x5 = d6.onPinchEnd) == null || x5.call(d6, v6, y6), n5.current = void 0, t5.current = void 0, o5.current = [0, 0];\n  }, []);\n  useGesture({ onWheel: l7, onPinchStart: c5, onPinch: m6, onPinchEnd: p6 }, { target: e5, eventOptions: { passive: false }, pinch: { from: [r5.current, 0], scaleBounds: () => ({ from: r5.current, max: 5, min: 0.1 }) } });\n}\nvar et = 10;\nfunction tn(r5) {\n  let { deltaY: e5, deltaX: t5 } = r5, n5 = 0;\n  if (r5.ctrlKey || r5.metaKey) {\n    let o5 = Math.sign(r5.deltaY), i4 = Math.abs(r5.deltaY), s5 = e5;\n    i4 > et && (s5 = et * o5), n5 = s5;\n  }\n  return [t5, e5, n5];\n}\nfunction nt() {\n  let { callbacks: r5 } = R3();\n  (0, import_react6.useEffect)(() => {\n    function e5() {\n      var t5;\n      (t5 = r5.onShapeBlur) == null || t5.call(r5);\n    }\n    return w2.isMobileSafari() ? (document.addEventListener(\"focusout\", e5), () => document.removeEventListener(\"focusout\", e5)) : () => null;\n  }, [r5]);\n}\nfunction rt() {\n  let { callbacks: r5, inputs: e5 } = R3();\n  return ot.useMemo(() => ({ onPointerDown: (t5) => {\n    var o5, i4, s5;\n    if (t5.dead || (t5.dead = true, !e5.pointerIsValid(t5)))\n      return;\n    if (t5.currentTarget.setPointerCapture(t5.pointerId), t5.button === 2) {\n      (o5 = r5.onRightPointCanvas) == null || o5.call(r5, e5.pointerDown(t5, \"canvas\"), t5);\n      return;\n    }\n    let n5 = e5.pointerDown(t5, \"canvas\");\n    t5.button === 0 && ((i4 = r5.onPointCanvas) == null || i4.call(r5, n5, t5)), (s5 = r5.onPointerDown) == null || s5.call(r5, n5, t5);\n  }, onPointerMove: (t5) => {\n    var o5, i4;\n    if (t5.dead || (t5.dead = true, !e5.pointerIsValid(t5)))\n      return;\n    let n5 = e5.pointerMove(t5, \"canvas\");\n    t5.buttons === 1 && t5.currentTarget.hasPointerCapture(t5.pointerId) && ((o5 = r5.onDragCanvas) == null || o5.call(r5, n5, t5)), (i4 = r5.onPointerMove) == null || i4.call(r5, n5, t5);\n  }, onPointerUp: (t5) => {\n    var i4, s5, a7, d6, l7;\n    if (t5.dead || (t5.dead = true, e5.activePointer = void 0, !e5.pointerIsValid(t5)))\n      return;\n    let n5 = e5.isDoubleClick(), o5 = e5.pointerUp(t5, \"canvas\");\n    if (t5.button === 2) {\n      (i4 = r5.onPointerUp) == null || i4.call(r5, o5, t5);\n      return;\n    }\n    t5.currentTarget.hasPointerCapture(t5.pointerId) && ((s5 = t5.currentTarget) == null || s5.releasePointerCapture(t5.pointerId)), t5.button === 0 && (n5 && !(o5.altKey || o5.metaKey) && ((a7 = r5.onDoubleClickCanvas) == null || a7.call(r5, o5, t5)), (d6 = r5.onReleaseCanvas) == null || d6.call(r5, o5, t5)), (l7 = r5.onPointerUp) == null || l7.call(r5, o5, t5);\n  }, onDrop: r5.onDrop, onDragOver: r5.onDragOver }), [r5, e5]);\n}\nfunction it(r5) {\n  let { rPageState: e5, rSelectionBounds: t5, callbacks: n5, inputs: o5 } = Me.useContext(Le);\n  return Me.useMemo(() => ({ onPointerDown: (i4) => {\n    var a7, d6, l7, c5, m6, p6, u5;\n    if (i4.dead || (i4.dead = true, !o5.pointerIsValid(i4)))\n      return;\n    if (i4.button === 2) {\n      (a7 = n5.onRightPointShape) == null || a7.call(n5, o5.pointerDown(i4, r5), i4);\n      return;\n    }\n    let s5 = o5.pointerDown(i4, r5);\n    if ((d6 = i4.currentTarget) == null || d6.setPointerCapture(i4.pointerId), t5.current && C3.pointInBounds(s5.point, t5.current) && !e5.current.selectedIds.includes(r5)) {\n      i4.button === 0 && ((l7 = n5.onPointBounds) == null || l7.call(n5, o5.pointerDown(i4, \"bounds\"), i4), (c5 = n5.onPointShape) == null || c5.call(n5, s5, i4)), (m6 = n5.onPointerDown) == null || m6.call(n5, s5, i4);\n      return;\n    }\n    i4.button === 0 && ((p6 = n5.onPointShape) == null || p6.call(n5, s5, i4)), (u5 = n5.onPointerDown) == null || u5.call(n5, s5, i4);\n  }, onPointerUp: (i4) => {\n    var d6, l7, c5, m6;\n    if (i4.dead || (i4.dead = true, !o5.pointerIsValid(i4)) || i4.button === 2)\n      return;\n    o5.activePointer = void 0;\n    let s5 = o5.isDoubleClick(), a7 = o5.pointerUp(i4, r5);\n    i4.pointerId && i4.currentTarget.hasPointerCapture(i4.pointerId) && ((d6 = i4.currentTarget) == null || d6.releasePointerCapture(i4.pointerId)), i4.button === 0 && (s5 && !(a7.altKey || a7.metaKey) && ((l7 = n5.onDoubleClickShape) == null || l7.call(n5, a7, i4)), (c5 = n5.onReleaseShape) == null || c5.call(n5, a7, i4)), (m6 = n5.onPointerUp) == null || m6.call(n5, a7, i4);\n  }, onPointerMove: (i4) => {\n    var a7, d6;\n    if (i4.dead || (i4.dead = true, i4.buttons === 2 || !o5.pointerIsValid(i4) || o5.pointer && i4.pointerId !== o5.pointer.pointerId))\n      return;\n    let s5 = o5.pointerMove(i4, r5);\n    i4.buttons === 1 && i4.currentTarget.hasPointerCapture(i4.pointerId) && ((a7 = n5.onDragShape) == null || a7.call(n5, s5, i4)), (d6 = n5.onPointerMove) == null || d6.call(n5, s5, i4);\n  }, onPointerEnter: (i4) => {\n    var a7;\n    if (!o5.pointerIsValid(i4))\n      return;\n    let s5 = o5.pointerEnter(i4, r5);\n    (a7 = n5.onHoverShape) == null || a7.call(n5, s5, i4);\n  }, onPointerLeave: (i4) => {\n    var a7;\n    if (!o5.pointerIsValid(i4))\n      return;\n    let s5 = o5.pointerEnter(i4, r5);\n    (a7 = n5.onUnhoverShape) == null || a7.call(n5, s5, i4);\n  } }), [o5, n5, r5]);\n}\nfunction st(r5, e5, t5, n5, o5, i4 = false, s5 = false, a7, d6) {\n  let l7 = { shape: r5, asset: r5.assetId ? o5[r5.assetId] : void 0, meta: a7, isChildOfSelected: s5, isGhost: r5.isGhost || i4, isEditing: n5.editingId === r5.id, isBinding: d6 === r5.id, isSelected: n5.selectedIds.includes(r5.id), isHovered: n5.hoveredId === r5.id || r5.children !== void 0 && (n5.hoveredId && r5.children.includes(n5.hoveredId) || r5.children.some((c5) => n5.selectedIds.includes(c5))) };\n  e5.push(l7), r5.children && (l7.children = [], r5.children.map((c5) => t5[c5]).filter((c5) => t5[c5.id]).sort((c5, m6) => c5.childIndex - m6.childIndex).forEach((c5) => st(c5, l7.children, t5, n5, o5, l7.isGhost, l7.isSelected || l7.isChildOfSelected, a7)));\n}\nfunction on(r5, e5) {\n  return C3.boundsContain(e5, r5) || C3.boundsCollide(e5, r5);\n}\nfunction at(r5, e5, t5, n5) {\n  let { callbacks: o5, shapeUtils: i4, bounds: s5 } = R3(), a7 = ye2.useRef(), d6 = ye2.useRef(-1), l7 = ye2.useRef(/* @__PURE__ */ new Set()), c5 = ye2.useRef(/* @__PURE__ */ new Set()), { selectedIds: m6, camera: p6 } = e5, [u5, y6] = e.sub(e.div([0, 0], p6.zoom), p6.point), [T5, v6] = e.sub(e.div([s5.width, s5.height], p6.zoom), p6.point), x5 = { minX: u5, minY: y6, maxX: T5, maxY: v6, height: T5 - u5, width: v6 - y6 }, f5 = c5.current, L5 = l7.current;\n  f5.clear(), L5.clear(), Object.values(r5.shapes).filter((b6) => i4[b6.type].isStateful || m6.includes(b6.id) || on(i4[b6.type].getBounds(b6), x5)).forEach((b6) => {\n    if (b6.parentId === r5.id) {\n      L5.add(b6.id), f5.add(b6);\n      return;\n    }\n    let P4 = r5.shapes[b6.parentId];\n    if (P4 === void 0)\n      throw Error(`A shape (${b6.id}) has a parent (${b6.parentId}) that does not exist!`);\n    L5.add(P4.id), f5.add(P4);\n  }), f5.size !== d6.current && (a7.current && clearTimeout(a7.current), a7.current = requestAnimationFrame(() => {\n    var b6;\n    (b6 = o5.onRenderCountChange) == null || b6.call(o5, Array.from(L5.values()));\n  }), d6.current = f5.size);\n  let X3 = e5.bindingId ? r5.bindings[e5.bindingId].toId : void 0, S4 = [];\n  return f5.forEach((b6) => {\n    if (b6 === void 0)\n      throw Error(\"Rendered shapes included a missing shape\");\n    st(b6, S4, r5.shapes, e5, t5, b6.isGhost, false, n5, X3);\n  }), S4.sort((b6, P4) => b6.shape.childIndex - P4.shape.childIndex), S4;\n}\nvar ze = /* @__PURE__ */ new Map();\nfunction rn(r5, e5) {\n  return Object.keys(e5).reduce((t5, n5) => {\n    let o5 = e5[n5];\n    return o5 ? t5 + `${`--${r5}-${n5}`}: ${o5};\n` : t5;\n  }, \"\");\n}\nfunction sn(r5, e5, t5 = \":root\") {\n  ve.useLayoutEffect(() => {\n    let n5 = document.createElement(\"style\"), o5 = rn(r5, e5);\n    return n5.setAttribute(\"id\", `${r5}-theme`), n5.setAttribute(\"data-selector\", t5), n5.innerHTML = `\n        ${t5} {\n          ${o5}\n        }\n      `, document.head.appendChild(n5), () => {\n      n5 && document.head.contains(n5) && document.head.removeChild(n5);\n    };\n  }, [r5, e5, t5]);\n}\nfunction an(r5, e5) {\n  ve.useLayoutEffect(() => {\n    if (ze.get(r5))\n      return () => {\n      };\n    let t5 = document.createElement(\"style\");\n    return t5.innerHTML = e5, t5.setAttribute(\"id\", r5), document.head.appendChild(t5), ze.set(r5, t5), () => {\n      t5 && document.head.contains(t5) && (document.head.removeChild(t5), ze.delete(r5));\n    };\n  }, [r5, e5]);\n}\nvar dn = (r5, ...e5) => r5.reduce((t5, n5, o5) => t5 + n5 + (o5 < e5.length ? e5[o5] : \"\"), \"\");\nvar ln = { accent: \"rgb(255, 0, 0)\", brushFill: \"rgba(0,0,0,.05)\", brushStroke: \"rgba(0,0,0,.25)\", brushDashStroke: \"rgba(0,0,0,.6)\", selectStroke: \"rgb(66, 133, 244)\", selectFill: \"rgba(65, 132, 244, 0.05)\", binding: \"rgba(65, 132, 244, 0.12)\", background: \"rgb(248, 249, 250)\", foreground: \"rgb(51, 51, 51)\", grid: \"rgba(144, 144, 144, 1)\" };\nvar cn = dn`\n  .tl-container {\n    --tl-zoom: 1;\n    --tl-scale: calc(1 / var(--tl-zoom));\n    --tl-padding: calc(64px * max(1, var(--tl-scale)));\n    --tl-performance-all: auto;\n    --tl-performance-selected: auto;\n    position: relative;\n    top: 0px;\n    left: 0px;\n    width: 100%;\n    height: 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n    padding: 0px;\n    margin: 0px;\n    z-index: 100;\n    overflow: hidden;\n    touch-action: none;\n    overscroll-behavior: none;\n    background-color: var(--tl-background);\n  }\n  .tl-container * {\n    box-sizing: border-box;\n  }\n  .tl-overlay {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    touch-action: none;\n    pointer-events: none;\n  }\n  .tl-grid {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    touch-action: none;\n    pointer-events: none;\n    user-select: none;\n  }\n  .tl-snap-line {\n    stroke: var(--tl-accent);\n    stroke-width: calc(1px * var(--tl-scale));\n  }\n  .tl-snap-point {\n    stroke: var(--tl-accent);\n    stroke-width: calc(1px * var(--tl-scale));\n  }\n  .tl-canvas {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    touch-action: none;\n    pointer-events: all;\n    overflow: clip;\n  }\n  .tl-layer {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    height: 0px;\n    width: 0px;\n    contain: layout style size;\n  }\n  .tl-absolute {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    transform-origin: center center;\n    contain: layout style size;\n  }\n  .tl-positioned {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    transform-origin: center center;\n    pointer-events: none;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    contain: layout style size;\n    will-change: var(--tl-performance-all);\n  }\n  .tl-positioned-svg {\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    contain: layout style size;\n  }\n  .tl-positioned-div {\n    position: relative;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    padding: var(--tl-padding);\n    overflow: hidden;\n    contain: layout style size;\n  }\n  .tl-positioned-selected {\n    will-change: var(--tl-performance-selected);\n  }\n  .tl-inner-div {\n    position: relative;\n    width: 100%;\n    height: 100%;\n  }\n  .tl-stroke-hitarea {\n    fill: none;\n    stroke: transparent;\n    stroke-width: calc(24px * var(--tl-scale));\n    pointer-events: stroke;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n  }\n  .tl-fill-hitarea {\n    fill: transparent;\n    stroke: transparent;\n    stroke-width: calc(24px * var(--tl-scale));\n    pointer-events: all;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n  }\n  .tl-counter-scaled {\n    transform: scale(var(--tl-scale));\n  }\n  .tl-dashed {\n    stroke-dasharray: calc(2px * var(--tl-scale)), calc(2px * var(--tl-scale));\n  }\n  .tl-transparent {\n    fill: transparent;\n    stroke: transparent;\n  }\n  .tl-cursor-ns {\n    cursor: ns-resize;\n  }\n  .tl-cursor-ew {\n    cursor: ew-resize;\n  }\n  .tl-cursor-nesw {\n    cursor: nesw-resize;\n  }\n  .tl-cursor-nwse {\n    cursor: nwse-resize;\n  }\n  .tl-corner-handle {\n    stroke: var(--tl-selectStroke);\n    fill: var(--tl-background);\n    stroke-width: calc(1.5px * var(--tl-scale));\n  }\n  .tl-rotate-handle {\n    stroke: var(--tl-selectStroke);\n    fill: var(--tl-background);\n    stroke-width: calc(1.5px * var(--tl-scale));\n    cursor: grab;\n  }\n  .tl-binding {\n    fill: var(--tl-selectFill);\n    stroke: var(--tl-selectStroke);\n    stroke-width: calc(1px * var(--tl-scale));\n    pointer-events: none;\n  }\n  .tl-user {\n    left: calc(-15px * var(--tl-scale));\n    top: calc(-15px * var(--tl-scale));\n    height: calc(35px * var(--tl-scale));\n    width: calc(35px * var(--tl-scale));\n    transform: scale(var(--tl-scale));\n    pointer-events: none;\n    will-change: transform;\n  }\n  .tl-animated {\n    transition: transform 200ms linear;\n  }\n  .tl-indicator {\n    fill: transparent;\n    stroke-width: calc(1.5px * var(--tl-scale));\n    pointer-events: none;\n  }\n  .tl-user-indicator-bounds {\n    border-style: solid;\n    border-width: calc(1px * var(--tl-scale));\n  }\n  .tl-hovered {\n    stroke: var(--tl-selectStroke);\n  }\n  .tl-selected {\n    stroke: var(--tl-selectStroke);\n  }\n  .tl-locked {\n    stroke-dasharray: calc(3px * var(--tl-scale)) calc(3px * var(--tl-scale));\n  }\n  .tl-editing {\n    stroke-width: calc(2.5px * min(5, var(--tl-scale)));\n  }\n  .tl-performance {\n    will-change: transform, contents;\n  }\n  .tl-clone-target {\n    pointer-events: all;\n  }\n  .tl-clone-target:hover .tl-clone-button {\n    opacity: 1;\n  }\n  .tl-clone-button-target {\n    cursor: pointer;\n    pointer-events: all;\n  }\n  .tl-clone-button-target:hover .tl-clone-button {\n    fill: var(--tl-selectStroke);\n  }\n  .tl-clone-button {\n    opacity: 0;\n    r: calc(8px * var(--tl-scale));\n    stroke-width: calc(1.5px * var(--tl-scale));\n    stroke: var(--tl-selectStroke);\n    fill: var(--tl-background);\n  }\n  .tl-bounds {\n    pointer-events: none;\n    contain: layout style size;\n  }\n  .tl-bounds-bg {\n    stroke: none;\n    fill: var(--tl-selectFill);\n    pointer-events: all;\n    contain: layout style size;\n  }\n  .tl-bounds-center {\n    fill: transparent;\n    stroke: var(--tl-selectStroke);\n    stroke-width: calc(1.5px * var(--tl-scale));\n  }\n  .tl-brush {\n    fill: var(--tl-brushFill);\n    stroke: var(--tl-brushStroke);\n    stroke-width: calc(1px * var(--tl-scale));\n    pointer-events: none;\n    contain: layout style size;\n  }\n  .tl-dashed-brush-line {\n    fill: none;\n    stroke: var(--tl-brushDashStroke);\n    stroke-width: calc(1px * var(--tl-scale));\n    pointer-events: none;\n  }\n  .tl-brush.dashed {\n    stroke: none;\n  }\n  .tl-handle {\n    pointer-events: all;\n    cursor: grab;\n  }\n  .tl-handle:hover .tl-handle-bg {\n    fill: var(--tl-selectFill);\n  }\n  .tl-handle:hover .tl-handle-bg > * {\n    stroke: var(--tl-selectFill);\n  }\n  .tl-handle:active .tl-handle-bg {\n    cursor: grabbing;\n    fill: var(--tl-selectFill);\n  }\n  .tl-handle:active .tl-handle-bg > * {\n    stroke: var(--tl-selectFill);\n  }\n  .tl-handle {\n    fill: var(--tl-background);\n    stroke: var(--tl-selectStroke);\n    stroke-width: 1.5px;\n  }\n  .tl-handle-bg {\n    fill: transparent;\n    stroke: none;\n    pointer-events: all;\n    r: calc(16px / max(1, var(--tl-zoom)));\n  }\n  .tl-binding-indicator {\n    fill: transparent;\n    stroke: var(--tl-binding);\n  }\n  .tl-centered-g {\n    transform: translate(var(--tl-padding), var(--tl-padding));\n  }\n  .tl-current-parent > *[data-shy='true'] {\n    opacity: 1;\n  }\n  .tl-binding {\n    fill: none;\n    stroke: var(--tl-selectStroke);\n    stroke-width: calc(2px * var(--tl-scale));\n  }\n  .tl-grid-dot {\n    fill: var(--tl-grid);\n  }\n  .tl-erase-line {\n    stroke-linejoin: round;\n    stroke-linecap: round;\n    pointer-events: none;\n    fill: var(--tl-grid);\n    opacity: 0.32;\n  }\n`;\nfunction dt(r5, e5) {\n  let t5 = ve.useMemo(() => g2(g2({}, ln), r5), [r5]);\n  sn(\"tl\", t5, e5), an(\"tl-canvas\", cn);\n}\nfunction _2(r5) {\n  let { callbacks: e5, inputs: t5 } = R3(), n5 = pe3.useCallback((d6) => {\n    var c5, m6, p6, u5;\n    if (d6.dead || (d6.dead = true, !t5.pointerIsValid(d6)))\n      return;\n    (c5 = d6.currentTarget) == null || c5.setPointerCapture(d6.pointerId);\n    let l7 = t5.pointerDown(d6, r5);\n    if (d6.button === 2) {\n      (m6 = e5.onRightPointBoundsHandle) == null || m6.call(e5, l7, d6);\n      return;\n    }\n    d6.button === 0 && ((p6 = e5.onPointBoundsHandle) == null || p6.call(e5, l7, d6)), (u5 = e5.onPointerDown) == null || u5.call(e5, l7, d6);\n  }, [t5, e5, r5]), o5 = pe3.useCallback((d6) => {\n    var m6, p6, u5;\n    if (d6.dead || (d6.dead = true, d6.button === 2 || !t5.pointerIsValid(d6)))\n      return;\n    let l7 = t5.pointerUp(d6, r5), c5 = t5.isDoubleClick();\n    d6.button === 0 && (c5 && !(l7.altKey || l7.metaKey) && ((m6 = e5.onDoubleClickBoundsHandle) == null || m6.call(e5, l7, d6)), (p6 = e5.onReleaseBoundsHandle) == null || p6.call(e5, l7, d6)), (u5 = e5.onPointerUp) == null || u5.call(e5, l7, d6);\n  }, [t5, e5, r5]), i4 = pe3.useCallback((d6) => {\n    var c5, m6;\n    if (d6.dead || (d6.dead = true, !t5.pointerIsValid(d6)) || d6.buttons === 2)\n      return;\n    let l7 = t5.pointerMove(d6, r5);\n    d6.buttons === 1 && d6.currentTarget.hasPointerCapture(d6.pointerId) && ((c5 = e5.onDragBoundsHandle) == null || c5.call(e5, l7, d6)), (m6 = e5.onPointerMove) == null || m6.call(e5, l7, d6);\n  }, [t5, e5, r5]), s5 = pe3.useCallback((d6) => {\n    var l7;\n    !t5.pointerIsValid(d6) || (l7 = e5.onHoverBoundsHandle) == null || l7.call(e5, t5.pointerEnter(d6, r5), d6);\n  }, [t5, e5, r5]), a7 = pe3.useCallback((d6) => {\n    var l7;\n    !t5.pointerIsValid(d6) || (l7 = e5.onUnhoverBoundsHandle) == null || l7.call(e5, t5.pointerEnter(d6, r5), d6);\n  }, [t5, e5, r5]);\n  return { onPointerDown: n5, onPointerUp: o5, onPointerEnter: s5, onPointerMove: i4, onPointerLeave: a7 };\n}\nfunction lt(r5, e5, t5) {\n  let n5 = xe2.useRef(), o5 = xe2.useRef();\n  xe2.useLayoutEffect(() => {\n    let { zoom: i4, point: s5 } = t5.camera, a7 = i4 !== n5.current, d6 = s5 !== o5.current;\n    if (n5.current = i4, o5.current = s5, a7 || d6) {\n      let l7 = r5.current;\n      if (e5 && \"current\" in e5) {\n        let c5 = e5.current;\n        a7 && c5 && c5.style.setProperty(\"--tl-zoom\", i4.toString()), l7 && l7.style.setProperty(\"transform\", `scale(${i4}) translateX(${s5[0]}px) translateY(${s5[1]}px)`);\n      }\n    }\n  }, [t5.camera.zoom, t5.camera.point]);\n}\nfunction ct(r5, e5) {\n  return [(r5[0] + e5.point[0]) * e5.zoom, (r5[1] + e5.point[1]) * e5.zoom];\n}\nfunction Fe(r5, e5) {\n  return r5[e5.type];\n}\nfunction mt(r5, e5, t5) {\n  let { rSelectionBounds: n5 } = R3(), { selectedIds: o5 } = e5, i4 = ut.useRef(), s5, a7 = 0, d6 = false, l7 = false;\n  if (o5.length === 1) {\n    let m6 = o5[0], p6 = r5.shapes[m6];\n    if (!p6)\n      throw Error(`selectedIds is set to the id of a shape that doesn't exist: ${m6}`);\n    a7 = p6.rotation || 0, d6 = p6.isLocked || false;\n    let u5 = Fe(t5, p6);\n    s5 = u5.hideBounds ? void 0 : u5.getBounds(p6);\n  } else if (o5.length > 1) {\n    let m6 = o5.map((p6) => r5.shapes[p6]);\n    a7 = 0, d6 = m6.every((p6) => p6.isLocked), s5 = m6.reduce((p6, u5, y6) => y6 === 0 ? Fe(t5, u5).getRotatedBounds(u5) : w2.getExpandedBounds(p6, Fe(t5, u5).getRotatedBounds(u5)), {});\n  }\n  if (s5) {\n    let [m6, p6] = ct([s5.minX, s5.minY], e5.camera), [u5, y6] = ct([s5.maxX, s5.maxY], e5.camera);\n    l7 = !!Object.values(r5.bindings).find((T5) => o5.includes(T5.toId) || o5.includes(T5.fromId)), n5.current = { minX: m6, minY: p6, maxX: u5, maxY: y6, width: u5 - m6, height: y6 - p6 };\n  } else\n    n5.current = null;\n  let c5 = i4.current;\n  return !c5 || !s5 ? i4.current = s5 : s5 && c5.minX === s5.minX && c5.minY === s5.minY && c5.maxX === s5.maxX && c5.maxY === s5.maxY && (s5 = i4.current), { bounds: s5, rotation: a7, isLocked: d6, isLinked: l7 };\n}\nfunction ht(r5) {\n  let { inputs: e5, callbacks: t5 } = R3();\n  return pt.useMemo(() => ({ onPointerDown: (n5) => {\n    var i4, s5, a7;\n    if (n5.dead || (n5.dead = true, !e5.pointerIsValid(n5)) || n5.button === 2)\n      return;\n    (i4 = n5.currentTarget) == null || i4.setPointerCapture(n5.pointerId);\n    let o5 = e5.pointerDown(n5, r5);\n    n5.button === 0 && ((s5 = t5.onPointHandle) == null || s5.call(t5, o5, n5)), (a7 = t5.onPointerDown) == null || a7.call(t5, o5, n5);\n  }, onPointerUp: (n5) => {\n    var s5, a7, d6, l7;\n    if (n5.dead || (n5.dead = true, !e5.pointerIsValid(n5)) || n5.button === 2)\n      return;\n    let o5 = e5.isDoubleClick(), i4 = e5.pointerUp(n5, r5);\n    n5.currentTarget.hasPointerCapture(n5.pointerId) && ((s5 = n5.currentTarget) == null || s5.releasePointerCapture(n5.pointerId), n5.button === 0 && (o5 && !(i4.altKey || i4.metaKey) && ((a7 = t5.onDoubleClickHandle) == null || a7.call(t5, i4, n5)), (d6 = t5.onReleaseHandle) == null || d6.call(t5, i4, n5))), (l7 = t5.onPointerUp) == null || l7.call(t5, i4, n5);\n  }, onPointerMove: (n5) => {\n    var i4, s5;\n    if (n5.dead || (n5.dead = true, !e5.pointerIsValid(n5)) || n5.buttons === 2)\n      return;\n    let o5 = e5.pointerMove(n5, r5);\n    n5.buttons === 1 && n5.currentTarget.hasPointerCapture(n5.pointerId) && ((i4 = t5.onDragHandle) == null || i4.call(t5, o5, n5)), (s5 = t5.onPointerMove) == null || s5.call(t5, o5, n5);\n  }, onPointerEnter: (n5) => {\n    var i4;\n    if (!e5.pointerIsValid(n5))\n      return;\n    let o5 = e5.pointerEnter(n5, r5);\n    (i4 = t5.onHoverHandle) == null || i4.call(t5, o5, n5);\n  }, onPointerLeave: (n5) => {\n    var i4;\n    if (!e5.pointerIsValid(n5))\n      return;\n    let o5 = e5.pointerEnter(n5, r5);\n    (i4 = t5.onUnhoverHandle) == null || i4.call(t5, o5, n5);\n  } }), [e5, t5, r5]);\n}\nfunction Tt(r5) {\n  let { bounds: e5 } = R3();\n  ft.useEffect(() => {\n    let t5 = (i4) => {\n      i4.preventDefault();\n    }, n5 = (i4) => {\n      let s5 = i4.touches[0].pageX, a7 = i4.touches[0].radiusX || 0;\n      (s5 - a7 < 10 || s5 + a7 > e5.width - 10) && i4.preventDefault();\n    }, o5 = r5.current;\n    return o5 ? (o5.addEventListener(\"gestureend\", t5), o5.addEventListener(\"gesturechange\", t5), o5.addEventListener(\"gesturestart\", t5), o5.addEventListener(\"touchstart\", n5), () => {\n      o5 && (o5.removeEventListener(\"gestureend\", t5), o5.removeEventListener(\"gesturechange\", t5), o5.removeEventListener(\"gesturestart\", t5), o5.removeEventListener(\"touchstart\", n5));\n    }) : () => {\n    };\n  }, [r5, e5.width]);\n}\nfunction Lt() {\n  let { callbacks: r5, inputs: e5 } = R3();\n  return gt.useMemo(() => ({ onPointerDown: (t5) => {\n    var o5, i4, s5, a7;\n    if (t5.dead || (t5.dead = true, !e5.pointerIsValid(t5)))\n      return;\n    if (t5.button === 2) {\n      (o5 = r5.onRightPointBounds) == null || o5.call(r5, e5.pointerDown(t5, \"bounds\"), t5);\n      return;\n    }\n    let n5 = e5.pointerDown(t5, \"bounds\");\n    (i4 = t5.currentTarget) == null || i4.setPointerCapture(t5.pointerId), t5.button === 0 && ((s5 = r5.onPointBounds) == null || s5.call(r5, n5, t5)), (a7 = r5.onPointerDown) == null || a7.call(r5, n5, t5);\n  }, onPointerUp: (t5) => {\n    var i4, s5, a7, d6;\n    if (t5.dead || (t5.dead = true, t5.button === 2) || (e5.activePointer = void 0, !e5.pointerIsValid(t5)))\n      return;\n    let n5 = e5.isDoubleClick(), o5 = e5.pointerUp(t5, \"bounds\");\n    t5.currentTarget.hasPointerCapture(t5.pointerId) && ((i4 = t5.currentTarget) == null || i4.releasePointerCapture(t5.pointerId)), t5.button === 0 && (n5 && !(o5.altKey || o5.metaKey) && ((s5 = r5.onDoubleClickBounds) == null || s5.call(r5, o5, t5)), (a7 = r5.onReleaseBounds) == null || a7.call(r5, o5, t5)), (d6 = r5.onPointerUp) == null || d6.call(r5, o5, t5);\n  }, onPointerMove: (t5) => {\n    var o5, i4;\n    if (t5.dead || (t5.dead = true, !e5.pointerIsValid(t5)))\n      return;\n    t5.buttons === 1 && t5.currentTarget.hasPointerCapture(t5.pointerId) && ((o5 = r5.onDragBounds) == null || o5.call(r5, e5.pointerMove(t5, \"bounds\"), t5));\n    let n5 = e5.pointerMove(t5, \"bounds\");\n    (i4 = r5.onPointerMove) == null || i4.call(r5, n5, t5);\n  }, onPointerEnter: (t5) => {\n    var n5;\n    !e5.pointerIsValid(t5) || (n5 = r5.onHoverBounds) == null || n5.call(r5, e5.pointerEnter(t5, \"bounds\"), t5);\n  }, onPointerLeave: (t5) => {\n    var n5;\n    !e5.pointerIsValid(t5) || (n5 = r5.onUnhoverBounds) == null || n5.call(r5, e5.pointerEnter(t5, \"bounds\"), t5);\n  } }), [e5, r5]);\n}\nfunction De(r5, e5 = 0) {\n  let t5 = Ke.useRef(null);\n  return Ke.useLayoutEffect(() => {\n    let n5 = t5.current, o5 = `\n    translate(\n      calc(${r5.minX}px - var(--tl-padding)),\n      calc(${r5.minY}px - var(--tl-padding))\n    )\n    rotate(${e5 + (r5.rotation || 0)}rad)`;\n    n5.style.setProperty(\"transform\", o5), n5.style.setProperty(\"width\", `calc(${Math.floor(r5.width)}px + (var(--tl-padding) * 2))`), n5.style.setProperty(\"height\", `calc(${Math.floor(r5.height)}px + (var(--tl-padding) * 2))`);\n  }, [r5, e5]), t5;\n}\nfunction vt() {\n  let { inputs: r5, callbacks: e5 } = R3();\n  yt.useEffect(() => {\n    let t5 = (o5) => {\n      var i4;\n      (i4 = e5.onKeyDown) == null || i4.call(e5, o5.key, r5.keydown(o5), o5);\n    }, n5 = (o5) => {\n      var i4;\n      r5.keyup(o5), (i4 = e5.onKeyUp) == null || i4.call(e5, o5.key, r5.keyup(o5), o5);\n    };\n    return window.addEventListener(\"keydown\", t5), window.addEventListener(\"keyup\", n5), () => {\n      window.removeEventListener(\"keydown\", t5), window.removeEventListener(\"keyup\", n5);\n    };\n  }, [r5, e5]);\n}\nfunction bt(r5, e5) {\n  xt.useLayoutEffect(() => {\n    if (e5 && \"current\" in e5) {\n      let t5 = e5 == null ? void 0 : e5.current;\n      if (!t5)\n        return;\n      switch (r5) {\n        case \"transform_selected\": {\n          t5.style.setProperty(\"--tl-performance-all\", \"auto\"), t5.style.setProperty(\"--tl-performance-selected\", \"transform, contents\");\n          break;\n        }\n        case \"transform_all\": {\n          t5.style.setProperty(\"--tl-performance-all\", \"transform, contents\"), t5.style.setProperty(\"--tl-performance-selected\", \"transform, contents\");\n          break;\n        }\n        case \"translate_selected\": {\n          t5.style.setProperty(\"--tl-performance-all\", \"auto\"), t5.style.setProperty(\"--tl-performance-selected\", \"transform\");\n          break;\n        }\n        case \"translate_all\": {\n          t5.style.setProperty(\"--tl-performance-all\", \"transform\"), t5.style.setProperty(\"--tl-performance-selected\", \"transform\");\n          break;\n        }\n        default:\n          t5.style.setProperty(\"--tl-performance-all\", \"auto\"), t5.style.setProperty(\"--tl-performance-selected\", \"auto\");\n      }\n    }\n  }, [r5]);\n}\nfunction un(a7) {\n  var d6 = a7, { id: r5, bounds: e5, rotation: t5 = 0, isGhost: n5 = false, isSelected: o5 = false, children: i4 } = d6, s5 = O2(d6, [\"id\", \"bounds\", \"rotation\", \"isGhost\", \"isSelected\", \"children\"]);\n  let l7 = De(e5, t5);\n  return Ye.createElement(\"div\", g2({ id: r5, ref: l7, className: `tl-positioned${n5 ? \" tl-ghost\" : \"\"}${o5 ? \" tl-positioned-selected\" : \"\"}`, \"aria-label\": \"container\", \"data-testid\": \"container\" }, s5), i4);\n}\nvar Z = Ye.memo(un);\nfunction mn({ brush: r5, zoom: e5, dashed: t5 }) {\n  return z2.createElement(Z, { bounds: r5, rotation: 0 }, z2.createElement(te, null, z2.createElement(\"rect\", { className: \"tl-brush\" + (t5 ? \" dashed\" : \"\"), opacity: 1, x: 0, y: 0, width: r5.width, height: r5.height, \"aria-label\": \"brush\" }), t5 && z2.createElement(\"g\", { className: \"tl-dashed-brush-line\" }, z2.createElement(Xe, { x1: 0, y1: 0, x2: r5.width, y2: 0, zoom: e5 }), z2.createElement(Xe, { x1: r5.width, y1: 0, x2: r5.width, y2: r5.height, zoom: e5 }), z2.createElement(Xe, { x1: 0, y1: r5.height, x2: r5.width, y2: r5.height, zoom: e5 }), z2.createElement(Xe, { x1: 0, y1: 0, x2: 0, y2: r5.height, zoom: e5 }))));\n}\nvar Pt = z2.memo(mn);\nfunction Xe({ x1: r5, y1: e5, x2: t5, y2: n5, zoom: o5 }) {\n  let i4 = w2.getPerfectDashProps(Math.hypot(t5 - r5, n5 - e5), 1 / o5, \"dashed\", 1, true, 3);\n  return z2.createElement(\"line\", { x1: r5, y1: e5, x2: t5, y2: n5, strokeWidth: 1 / o5, strokeDasharray: i4.strokeDasharray, strokeDashoffset: i4.strokeDashoffset });\n}\nvar Rt = W2.memo(({ color: r5 }) => W2.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", viewBox: \"0 0 35 35\", fill: \"none\", fillRule: \"evenodd\" }, W2.createElement(\"g\", { fill: \"rgba(0,0,0,.2)\", transform: \"translate(1,1)\" }, W2.createElement(\"path\", { d: \"m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z\" }), W2.createElement(\"path\", { d: \"m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z\" })), W2.createElement(\"g\", { fill: \"white\" }, W2.createElement(\"path\", { d: \"m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z\" }), W2.createElement(\"path\", { d: \"m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z\" })), W2.createElement(\"g\", { fill: r5 }, W2.createElement(\"path\", { d: \"m19.751 24.4155-1.844.774-3.1-7.374 1.841-.775z\" }), W2.createElement(\"path\", { d: \"m13 10.814v11.188l2.969-2.866.428-.139h4.768z\" }))));\nfunction hn({ points: r5, zoom: e5 }) {\n  if (r5.length === 0)\n    return null;\n  let t5 = w2.getSvgPathFromStroke(_e(r5, { size: 16 / e5, start: { taper: true } }));\n  return Ue.createElement(\"path\", { d: t5, className: \"tl-erase-line\" });\n}\nvar Et = Ue.memo(hn);\nvar Bt = [[-1, 0.15, 64], [0.05, 0.375, 16], [0.15, 1, 4], [0.7, 2.5, 1]];\nfunction Ct({ grid: r5, camera: e5 }) {\n  return he2.createElement(\"svg\", { className: \"tl-grid\", version: \"1.1\", xmlns: \"http://www.w3.org/2000/svg\" }, he2.createElement(\"defs\", null, Bt.map(([t5, n5, o5], i4) => {\n    let s5 = o5 * r5 * e5.zoom, a7 = e5.point[0] * e5.zoom, d6 = e5.point[1] * e5.zoom, l7 = a7 > 0 ? a7 % s5 : s5 + a7 % s5, c5 = d6 > 0 ? d6 % s5 : s5 + d6 % s5, m6 = e5.zoom < n5 ? w2.modulate(e5.zoom, [t5, n5], [0, 1]) : 1;\n    return he2.createElement(\"pattern\", { key: `grid-pattern-${i4}`, id: `grid-${i4}`, width: s5, height: s5, patternUnits: \"userSpaceOnUse\" }, he2.createElement(\"circle\", { className: \"tl-grid-dot\", cx: l7, cy: c5, r: 1, opacity: m6 }));\n  })), Bt.map((t5, n5) => he2.createElement(\"rect\", { key: `grid-rect-${n5}`, width: \"100%\", height: \"100%\", fill: `url(#grid-${n5})` })));\n}\nfunction fn({ camera: { zoom: r5, point: e5 }, children: t5 }) {\n  let n5 = 2.5 / r5;\n  return ne.createElement(\"svg\", { className: \"tl-overlay\" }, ne.createElement(\"defs\", null, ne.createElement(\"g\", { id: \"tl-snap-point\" }, ne.createElement(\"path\", { className: \"tl-snap-point\", d: `M ${-n5},${-n5} L ${n5},${n5} M ${-n5},${n5} L ${n5},${-n5}` }))), ne.createElement(\"g\", { transform: `scale(${r5}) translate(${e5})` }, t5));\n}\nvar St = ne.memo(fn);\nvar te = ae2.memo(ae2.forwardRef(function(s5, i4) {\n  var a7 = s5, { id: e5, className: t5 = \"\", children: n5 } = a7, o5 = O2(a7, [\"id\", \"className\", \"children\"]);\n  return ae2.createElement(\"svg\", g2({ ref: i4, className: `tl-positioned-svg ${t5}` }, o5), ae2.createElement(\"g\", { id: e5, className: \"tl-centered-g\" }, n5));\n}));\nfunction Tn({ bounds: r5, isLocked: e5, isHidden: t5 }) {\n  return $e.createElement(\"rect\", { className: [\"tl-bounds-center\", e5 ? \"tl-dashed\" : \"\"].join(\" \"), x: -1, y: -1, width: r5.width + 2, height: r5.height + 2, opacity: t5 ? 0 : 1, pointerEvents: \"none\", \"aria-label\": \"center handle\" });\n}\nvar wt = $e.memo(Tn);\nvar gn = { right: 0, bottomRight: 45, bottom: 90, bottomLeft: 135, left: 180, topLeft: 225, top: 270, topRight: 315 };\nfunction Ln({ bounds: r5, side: e5, targetSize: t5, size: n5 }) {\n  let o5 = t5 * 2, i4 = { left: -o5, topLeft: -o5, bottomLeft: -o5, right: r5.width, topRight: r5.width, bottomRight: r5.width, top: r5.width / 2 - o5 / 2, bottom: r5.width / 2 - o5 / 2 }[e5], s5 = { left: r5.height / 2 - o5 / 2, right: r5.height / 2 - o5 / 2, top: -o5 * 2, topLeft: -o5, topRight: -o5, bottom: r5.height, bottomLeft: r5.height, bottomRight: r5.height }[e5], { callbacks: a7, inputs: d6 } = R3(), l7 = q2.useCallback((c5) => {\n    var p6;\n    c5.stopPropagation();\n    let m6 = d6.pointerDown(c5, e5);\n    (p6 = a7.onShapeClone) == null || p6.call(a7, m6, c5);\n  }, [a7.onShapeClone]);\n  return q2.createElement(\"g\", { className: \"tl-clone-target\", transform: `translate(${i4}, ${s5})`, \"aria-label\": \"clone button\" }, q2.createElement(\"rect\", { className: \"tl-transparent\", width: t5 * 2, height: t5 * 2 }), q2.createElement(\"g\", { className: \"tl-clone-button-target\", onPointerDown: l7, transform: `translate(${t5}, ${t5}) rotate(${gn[e5]})` }, q2.createElement(\"circle\", { className: \"tl-transparent \", r: t5 }), q2.createElement(\"path\", { className: \"tl-clone-button\", d: `M -${n5 / 2},-${n5 / 2} L ${n5 / 2},0 -${n5 / 2},${n5 / 2} Z`, strokeLinejoin: \"round\" })));\n}\nvar Q2 = q2.memo(Ln);\nfunction yn({ targetSize: r5, size: e5, bounds: t5 }) {\n  return $3.createElement($3.Fragment, null, $3.createElement(Q2, { targetSize: r5, size: e5, bounds: t5, side: \"top\" }), $3.createElement(Q2, { targetSize: r5, size: e5, bounds: t5, side: \"right\" }), $3.createElement(Q2, { targetSize: r5, size: e5, bounds: t5, side: \"bottom\" }), $3.createElement(Q2, { targetSize: r5, size: e5, bounds: t5, side: \"left\" }), $3.createElement(Q2, { targetSize: r5, size: e5, bounds: t5, side: \"topLeft\" }), $3.createElement(Q2, { targetSize: r5, size: e5, bounds: t5, side: \"topRight\" }), $3.createElement(Q2, { targetSize: r5, size: e5, bounds: t5, side: \"bottomLeft\" }), $3.createElement(Q2, { targetSize: r5, size: e5, bounds: t5, side: \"bottomRight\" }));\n}\nvar Ht = $3.memo(yn);\nvar vn = { [\"top_left_corner\"]: \"tl-cursor-nwse\", [\"top_right_corner\"]: \"tl-cursor-nesw\", [\"bottom_right_corner\"]: \"tl-cursor-nwse\", [\"bottom_left_corner\"]: \"tl-cursor-nesw\" };\nfunction xn({ size: r5, targetSize: e5, isHidden: t5, corner: n5, bounds: o5 }) {\n  let i4 = _2(n5), s5 = n5 === \"top_left_corner\" || n5 === \"top_right_corner\", a7 = n5 === \"top_left_corner\" || n5 === \"bottom_left_corner\";\n  return fe.createElement(\"g\", { opacity: t5 ? 0 : 1 }, fe.createElement(\"rect\", g2({ className: \"tl-transparent \" + (t5 ? \"\" : vn[n5]), \"aria-label\": \"corner transparent\", x: (a7 ? -1 : o5.width + 1) - e5, y: (s5 ? -1 : o5.height + 1) - e5, width: e5 * 2, height: e5 * 2, pointerEvents: t5 ? \"none\" : \"all\" }, i4)), fe.createElement(\"rect\", { className: \"tl-corner-handle\", \"aria-label\": \"corner handle\", x: (a7 ? -1 : o5.width + 1) - r5 / 2, y: (s5 ? -1 : o5.height + 1) - r5 / 2, width: r5, height: r5, pointerEvents: \"none\" }));\n}\nvar be2 = fe.memo(xn);\nvar bn = { [\"top_edge\"]: \"tl-cursor-ns\", [\"right_edge\"]: \"tl-cursor-ew\", [\"bottom_edge\"]: \"tl-cursor-ns\", [\"left_edge\"]: \"tl-cursor-ew\" };\nfunction Pn({ size: r5, isHidden: e5, bounds: t5, edge: n5 }) {\n  let o5 = _2(n5), i4 = n5 === \"top_edge\" || n5 === \"bottom_edge\", s5 = n5 === \"right_edge\" || n5 === \"bottom_edge\", { height: a7, width: d6 } = t5;\n  return Ne.createElement(\"rect\", g2({ pointerEvents: e5 ? \"none\" : \"all\", className: \"tl-transparent tl-edge-handle \" + (e5 ? \"\" : bn[n5]), \"aria-label\": `${n5} handle`, opacity: e5 ? 0 : 1, x: i4 ? r5 / 2 : (s5 ? d6 + 1 : -1) - r5 / 2, y: i4 ? (s5 ? a7 + 1 : -1) - r5 / 2 : r5 / 2, width: i4 ? Math.max(0, d6 + 1 - r5) : r5, height: i4 ? r5 : Math.max(0, a7 + 1 - r5) }, o5));\n}\nvar Pe = Ne.memo(Pn);\nfunction Rn({ size: r5, bounds: e5, isHidden: t5 }) {\n  let n5 = _2(\"left\"), o5 = _2(\"center\"), i4 = _2(\"right\");\n  return F2.createElement(\"g\", { cursor: \"grab\", transform: `translate(${e5.width / 2 - r5 * 4}, ${e5.height + r5 * 2})`, \"aria-label\": \"link handle\" }, F2.createElement(\"g\", { className: \"tl-transparent\", pointerEvents: t5 ? \"none\" : \"all\" }, F2.createElement(\"rect\", g2({ x: 0, y: 0, width: r5 * 2, height: r5 * 2 }, n5)), F2.createElement(\"rect\", g2({ x: r5 * 3, y: 0, width: r5 * 2, height: r5 * 2 }, o5)), F2.createElement(\"rect\", g2({ x: r5 * 6, y: 0, width: r5 * 2, height: r5 * 2 }, i4))), F2.createElement(\"g\", { className: \"tl-rotate-handle\", transform: `translate(${r5 / 2}, ${r5 / 2})`, \"aria-label\": \"link rotate handle\" }, F2.createElement(\"path\", { d: `M 0,${r5 / 2} L ${r5},${r5} ${r5},0 Z`, pointerEvents: \"none\", opacity: t5 ? 0 : 1 }), F2.createElement(\"path\", { transform: `translate(${r5 * 3}, 0)`, d: `M 0,0 L ${r5},0 ${r5 / 2},${r5} Z`, pointerEvents: \"none\", opacity: t5 ? 0 : 1 }), F2.createElement(\"path\", { transform: `translate(${r5 * 6}, 0)`, d: `M ${r5},${r5 / 2} L 0,0 0,${r5} Z`, pointerEvents: \"none\", opacity: t5 ? 0 : 1 })));\n}\nvar It = F2.memo(Rn);\nfunction En({ bounds: r5, targetSize: e5, size: t5, isHidden: n5 }) {\n  let o5 = _2(\"rotate\");\n  return Te2.createElement(\"g\", { cursor: \"grab\", opacity: n5 ? 0 : 1 }, Te2.createElement(\"circle\", g2({ className: \"tl-transparent\", \"aria-label\": \"rotate handle transparent\", cx: r5.width / 2, cy: t5 * -2, r: e5, pointerEvents: n5 ? \"none\" : \"all\" }, o5)), Te2.createElement(\"circle\", { className: \"tl-rotate-handle\", \"aria-label\": \"rotate handle\", cx: r5.width / 2, cy: t5 * -2, r: t5 / 2, pointerEvents: \"none\" }));\n}\nvar Mt = Te2.memo(En);\nvar Bn = function({ zoom: e5, bounds: t5, viewportWidth: n5, rotation: o5, isHidden: i4, isLocked: s5, hideCloneHandles: a7, hideResizeHandles: d6, hideRotateHandle: l7, hideBindingHandles: c5 }) {\n  let m6 = (n5 < 768 ? 16 : 8) / e5, p6 = 8 / e5, u5 = Math.min(t5.width, t5.height) * e5, y6 = !l7 && !i4 && !s5 && u5 > 32, T5 = !i4 && !s5 && u5 > 24, v6 = !i4 && !s5 && u5 > 20, x5 = !a7 && u5 > 24;\n  return K3.createElement(Z, { bounds: t5, rotation: o5 }, K3.createElement(te, null, K3.createElement(wt, { bounds: t5, isLocked: s5, isHidden: i4 }), !d6 && !s5 ? K3.createElement(K3.Fragment, null, K3.createElement(Pe, { targetSize: m6, size: p6, bounds: t5, edge: \"top_edge\", isHidden: !T5 }), K3.createElement(Pe, { targetSize: m6, size: p6, bounds: t5, edge: \"right_edge\", isHidden: !T5 }), K3.createElement(Pe, { targetSize: m6, size: p6, bounds: t5, edge: \"bottom_edge\", isHidden: !T5 }), K3.createElement(Pe, { targetSize: m6, size: p6, bounds: t5, edge: \"left_edge\", isHidden: !T5 }), K3.createElement(be2, { targetSize: m6, size: p6, bounds: t5, isHidden: i4 || !v6, corner: \"top_left_corner\" }), K3.createElement(be2, { targetSize: m6, size: p6, bounds: t5, isHidden: i4 || !v6, corner: \"top_right_corner\" }), K3.createElement(be2, { targetSize: m6, size: p6, bounds: t5, isHidden: i4 || !v6, corner: \"bottom_right_corner\" }), K3.createElement(be2, { targetSize: m6, size: p6, bounds: t5, isHidden: i4 || !v6, corner: \"bottom_left_corner\" })) : null, y6 && K3.createElement(Mt, { targetSize: m6, size: p6, bounds: t5, isHidden: !T5 }), x5 && K3.createElement(Ht, { bounds: t5, targetSize: m6, size: p6 }), !c5 && K3.createElement(It, { targetSize: m6, size: p6, bounds: t5, isHidden: !T5 })));\n};\nvar kt = K3.memo(Bn);\nfunction Cn({ bounds: r5, rotation: e5, isHidden: t5 }) {\n  let n5 = Lt();\n  return ge2.createElement(Z, { bounds: r5, rotation: e5 }, ge2.createElement(te, null, ge2.createElement(\"rect\", g2({ className: \"tl-bounds-bg\", \"aria-label\": \"bounds bg\", width: r5.width, height: r5.height, opacity: t5 ? 0 : 1 }, n5))));\n}\nvar Kt = ge2.memo(Cn);\nfunction Sn({ id: r5, point: e5 }) {\n  let t5 = ht(r5);\n  return oe.createElement(Z, { bounds: w2.translateBounds({ minX: 0, minY: 0, maxX: 0, maxY: 0, width: 0, height: 0 }, e5) }, oe.createElement(te, null, oe.createElement(\"g\", g2({ className: \"tl-handle\", \"aria-label\": \"handle\" }, t5), oe.createElement(\"circle\", { className: \"tl-handle-bg\", pointerEvents: \"all\" }), oe.createElement(\"circle\", { className: \"tl-counter-scaled tl-handle\", pointerEvents: \"none\", r: 4 }))));\n}\nvar Dt = oe.memo(Sn);\nfunction wn({ shape: r5, zoom: e5 }) {\n  if (r5.handles === void 0)\n    return null;\n  let t5 = null, n5 = Object.values(r5.handles).reduce((o5, i4) => {\n    let s5 = e.add(i4.point, r5.point);\n    return (!t5 || e.dist(s5, t5) * e5 >= 32) && (o5.push(i4), t5 = s5), o5;\n  }, []);\n  return n5.length === 1 ? null : de3.createElement(de3.Fragment, null, n5.map((o5) => de3.createElement(Dt, { key: r5.id + \"_\" + o5.id, id: o5.id, point: e.add(o5.point, r5.point) })));\n}\nvar Yt = de3.memo(wn);\nfunction Hn(r5) {\n  let e5 = r5.utils.getRef(r5.shape);\n  return We.createElement(r5.utils.Component, g2({ ref: e5 }, r5));\n}\nvar Xt = We.memo(Hn, (r5, e5) => r5.isHovered !== e5.isHovered || r5.isSelected !== e5.isSelected || r5.isEditing !== e5.isEditing || r5.isBinding !== e5.isBinding || r5.isGhost !== e5.isGhost || r5.meta !== e5.meta ? false : e5.shape !== r5.shape ? !e5.utils.shouldRender(e5.shape, r5.shape) : true);\nfunction In(o5) {\n  var i4 = o5, { shape: r5, utils: e5, meta: t5 } = i4, n5 = O2(i4, [\"shape\", \"utils\", \"meta\"]);\n  let { callbacks: s5 } = R3(), a7 = e5.getBounds(r5), d6 = it(r5.id);\n  return Re.createElement(Z, { id: r5.id, bounds: a7, rotation: r5.rotation, \"data-shape\": r5.type, isGhost: n5.isGhost, isSelected: n5.isSelected }, Re.createElement(Xt, g2({ shape: r5, utils: e5, meta: t5, events: d6, bounds: a7, onShapeChange: s5.onShapeChange, onShapeBlur: s5.onShapeBlur }, n5)));\n}\nvar Ut = Re.memo(In);\nfunction Mn(i4) {\n  var s5 = i4, { shape: r5, utils: e5, meta: t5, children: n5 } = s5, o5 = O2(s5, [\"shape\", \"utils\", \"meta\", \"children\"]);\n  return re.createElement(re.Fragment, null, re.createElement(Ut, g2({ shape: r5, utils: e5[r5.type], meta: t5 }, o5)), n5 && n5.map((a7) => re.createElement(je, g2({ key: a7.shape.id, utils: e5 }, a7))));\n}\nvar je = re.memo(Mn);\nfunction kn({ isHovered: r5 = false, isSelected: e5 = false, isEditing: t5 = false, shape: n5, user: o5, meta: i4 }) {\n  let { shapeUtils: s5 } = R3(), a7 = s5[n5.type], d6 = a7.getBounds(n5), l7 = De(d6, n5.rotation);\n  return le2.createElement(\"div\", { ref: l7, draggable: false, className: [\"tl-indicator\", \"tl-absolute\", e5 && !o5 ? \"tl-selected\" : \"tl-hovered\", t5 ? \"tl-editing\" : \"\", n5.isLocked ? \"tl-locked\" : \"\"].join(\" \") }, le2.createElement(\"svg\", { width: \"100%\", height: \"100%\" }, le2.createElement(\"g\", { className: \"tl-centered-g\", stroke: o5 == null ? void 0 : o5.color }, le2.createElement(a7.Indicator, { shape: n5, meta: i4, user: o5, bounds: d6, isSelected: e5, isHovered: r5 }))));\n}\nvar Ee = le2.memo(kn);\nfunction Kn({ page: r5, pageState: e5, assets: t5, hideBounds: n5, hideHandles: o5, hideIndicators: i4, hideBindingHandles: s5, hideCloneHandles: a7, hideRotateHandle: d6, hideResizeHandles: l7, meta: c5 }) {\n  let { bounds: m6, shapeUtils: p6 } = R3(), u5 = at(r5, e5, t5, c5), { bounds: y6, isLinked: T5, isLocked: v6, rotation: x5 } = mt(r5, e5, p6), { selectedIds: f5, hoveredId: L5, editingId: Y3, camera: { zoom: X3 } } = e5, S4 = i4, b6 = true, P4 = false, B4, M3 = f5.map((I3) => r5.shapes[I3]);\n  if (M3.length === 1) {\n    let I3 = M3[0];\n    P4 = Y3 === I3.id, P4 && (S4 = true);\n    let A5 = p6[I3.type];\n    b6 = a7 || !A5.showCloneHandles, I3.handles !== void 0 && !P4 && (B4 = I3);\n  }\n  return G3.createElement(G3.Fragment, null, y6 && G3.createElement(Kt, { bounds: y6, rotation: x5, isHidden: n5 }), u5.map((I3) => G3.createElement(je, g2({ key: I3.shape.id, utils: p6 }, I3))), !S4 && M3.map((I3) => G3.createElement(Ee, { key: \"selected_\" + I3.id, shape: I3, meta: c5, isSelected: true, isEditing: P4 })), !S4 && L5 && L5 !== Y3 && G3.createElement(Ee, { key: \"hovered_\" + L5, shape: r5.shapes[L5], meta: c5, isHovered: true }), y6 && G3.createElement(kt, { zoom: X3, bounds: y6, viewportWidth: m6.width, isLocked: v6, rotation: x5, isHidden: n5, hideRotateHandle: d6, hideResizeHandles: l7, hideBindingHandles: s5 || !T5, hideCloneHandles: b6 }), !o5 && B4 && G3.createElement(Yt, { shape: B4, zoom: X3 }));\n}\nvar $t = G3.memo(Kn);\nfunction Dn({ snapLines: r5 }) {\n  return j2.createElement(j2.Fragment, null, r5.map((e5, t5) => j2.createElement(Xn, { key: t5, snapLine: e5 })));\n}\nfunction Yn({ snapLine: r5 }) {\n  let e5 = w2.getBoundsFromPoints(r5);\n  return j2.createElement(j2.Fragment, null, j2.createElement(\"line\", { className: \"tl-snap-line\", x1: e5.minX, y1: e5.minY, x2: e5.maxX, y2: e5.maxY }), r5.map(([t5, n5], o5) => j2.createElement(\"use\", { key: o5, href: \"#tl-snap-point\", x: t5, y: n5 })));\n}\nvar Xn = j2.memo(Yn);\nvar Nt = j2.memo(Dn);\nfunction Wt({ user: r5, Cursor: e5 }) {\n  let t5 = ce3.useRef(null);\n  return ce3.useLayoutEffect(() => {\n    t5.current && (t5.current.style.transform = `translate(${r5.point[0]}px, ${r5.point[1]}px)`);\n  }, [r5.point]), ce3.createElement(\"div\", { ref: t5, className: `tl-absolute tl-user tl-counter-scaled ${r5.session ? \"\" : \"tl-animated\"}` }, ce3.createElement(e5, { id: r5.id, color: r5.color, metadata: r5.metadata }));\n}\nfunction At({ userId: r5, users: e5, Cursor: t5 }) {\n  return Be.createElement(Be.Fragment, null, Object.values(e5).filter((n5) => n5 && n5.id !== r5).map((n5) => Be.createElement(Wt, { key: n5.id, user: n5, Cursor: t5 })));\n}\nfunction Ot({ userId: r5, users: e5, meta: t5, page: n5 }) {\n  let { shapeUtils: o5 } = R3();\n  return ie3.createElement(ie3.Fragment, null, Object.values(e5).filter(Boolean).filter((i4) => i4.id !== r5 && i4.selectedIds.length > 0).map((i4) => {\n    let s5 = i4.selectedIds.map((d6) => n5.shapes[d6]).filter(Boolean);\n    if (s5.length === 0)\n      return null;\n    let a7 = w2.getCommonBounds(s5.map((d6) => o5[d6.type].getBounds(d6)));\n    return ie3.createElement(ie3.Fragment, { key: i4.id + \"_shapes\" }, ie3.createElement(\"div\", { className: \"tl-absolute tl-user-indicator-bounds\", style: { backgroundColor: i4.color + \"0d\", borderColor: i4.color + \"78\", transform: `translate(${a7.minX}px, ${a7.minY}px)`, width: a7.width, height: a7.height, pointerEvents: \"none\" } }), s5.map((d6) => ie3.createElement(Ee, { key: `${i4.id}_${d6.id}_indicator`, shape: d6, user: i4, meta: t5, isHovered: true })));\n  }));\n}\nvar Un = (r5) => {\n  let e5 = r5.parentElement;\n  for (; e5; ) {\n    if (e5 === document.body)\n      return document;\n    let { overflowY: t5 } = window.getComputedStyle(e5);\n    if (e5.scrollHeight > e5.clientHeight && (t5 === \"auto\" || t5 === \"scroll\" || t5 === \"overlay\"))\n      return e5;\n    e5 = e5.parentElement;\n  }\n  return document;\n};\nfunction Vt(r5, e5) {\n  let { inputs: t5, callbacks: n5 } = R3(), o5 = se3.useRef(false), i4 = se3.useCallback(() => {\n    var s5, a7;\n    if (o5.current) {\n      let d6 = (s5 = r5.current) == null ? void 0 : s5.getBoundingClientRect();\n      if (d6) {\n        let l7 = { minX: d6.left, maxX: d6.left + d6.width, minY: d6.top, maxY: d6.top + d6.height, width: d6.width, height: d6.height };\n        t5.bounds = l7, e5(l7), (a7 = n5.onBoundsChange) == null || a7.call(n5, l7);\n      }\n    } else\n      o5.current = true;\n  }, [r5, t5, n5.onBoundsChange]);\n  se3.useEffect(() => {\n    let s5 = r5.current ? Un(r5.current) : document, a7 = C3.debounce(i4, 100);\n    return s5.addEventListener(\"scroll\", a7), window.addEventListener(\"resize\", a7), () => {\n      s5.removeEventListener(\"scroll\", a7), window.removeEventListener(\"resize\", a7);\n    };\n  }, []), se3.useEffect(() => {\n    let s5 = new ResizeObserver((a7) => {\n      t5.isPinching || a7[0].contentRect && i4();\n    });\n    return r5.current && s5.observe(r5.current), () => {\n      s5.disconnect();\n    };\n  }, [r5, t5]), se3.useEffect(() => {\n    i4();\n  }, [r5]);\n}\nfunction $n({ id: r5, page: e5, pageState: t5, assets: n5, snapLines: o5, eraseLine: i4, grid: s5, users: a7, userId: d6, components: l7 = {}, meta: c5, performanceMode: m6, showDashedBrush: p6, hideHandles: u5, hideBounds: y6, hideIndicators: T5, hideBindingHandles: v6, hideCloneHandles: x5, hideResizeHandles: f5, hideRotateHandle: L5, hideGrid: Y3, onBoundsChange: X3, hideCursors: S4 }) {\n  var A5;\n  let b6 = D2.useRef(null), P4 = D2.useRef(t5.camera.zoom);\n  P4.current = t5.camera.zoom, tt(P4, b6), Vt(b6, X3), nt(), Tt(b6);\n  let B4 = D2.useRef(null), M3 = D2.useRef(null);\n  lt(M3, B4, t5), bt(m6, B4), vt();\n  let I3 = rt();\n  return D2.createElement(\"div\", { id: r5, className: \"tl-container\", ref: B4 }, D2.createElement(\"div\", g2({ id: \"canvas\", className: \"tl-absolute tl-canvas\", ref: b6 }, I3), !Y3 && s5 && D2.createElement(Ct, { grid: s5, camera: t5.camera }), D2.createElement(\"div\", { ref: M3, className: \"tl-absolute tl-layer\", \"data-testid\": \"layer\" }, D2.createElement($t, { page: e5, pageState: t5, assets: n5, hideBounds: y6, hideIndicators: T5, hideHandles: u5, hideBindingHandles: v6, hideCloneHandles: x5, hideResizeHandles: f5, hideRotateHandle: L5, meta: c5 }), a7 && d6 && D2.createElement(Ot, { userId: d6, users: a7, page: e5, meta: c5 }), t5.brush && D2.createElement(Pt, { brush: t5.brush, dashed: p6, zoom: t5.camera.zoom }), a7 && !S4 && D2.createElement(At, { userId: d6, users: a7, Cursor: (A5 = l7 == null ? void 0 : l7.Cursor) != null ? A5 : Rt })), D2.createElement(St, { camera: t5.camera }, i4 && D2.createElement(Et, { points: i4, zoom: t5.camera.zoom }), o5 && D2.createElement(Nt, { snapLines: o5 }))));\n}\nvar zt = D2.memo($n);\nvar Nn = 250;\nvar H2 = class {\n  constructor() {\n    E2(this, \"pointer\");\n    E2(this, \"keyboard\");\n    E2(this, \"keys\", {});\n    E2(this, \"isPinching\", false);\n    E2(this, \"bounds\", { minX: 0, maxX: 640, minY: 0, maxY: 480, width: 640, height: 480 });\n    E2(this, \"pointerUpTime\", 0);\n    E2(this, \"activePointer\");\n    E2(this, \"panStart\", (e5) => {\n      var a7, d6;\n      let { shiftKey: t5, ctrlKey: n5, metaKey: o5, altKey: i4 } = e5, s5 = { target: \"wheel\", pointerId: ((a7 = this.pointer) == null ? void 0 : a7.pointerId) || 0, origin: ((d6 = this.pointer) == null ? void 0 : d6.origin) || [0, 0], delta: [0, 0], pressure: 0.5, point: H2.getPoint(e5, this.bounds), shiftKey: t5, ctrlKey: n5, metaKey: o5, altKey: i4, spaceKey: this.keys[\" \"] };\n      return this.pointer = s5, s5;\n    });\n    E2(this, \"pan\", (e5, t5) => {\n      if (!this.pointer || this.pointer.target !== \"wheel\")\n        return this.panStart(t5);\n      let { shiftKey: n5, ctrlKey: o5, metaKey: i4, altKey: s5 } = t5, a7 = this.pointer, d6 = H2.getPoint(t5, this.bounds), l7 = U2(g2({}, a7), { target: \"wheel\", delta: e5, point: d6, shiftKey: n5, ctrlKey: o5, metaKey: i4, altKey: s5, spaceKey: this.keys[\" \"] });\n      return this.pointer = l7, l7;\n    });\n    E2(this, \"keydown\", (e5) => {\n      var s5, a7;\n      let { shiftKey: t5, ctrlKey: n5, metaKey: o5, altKey: i4 } = e5;\n      return this.keys[e5.key] = true, { point: ((s5 = this.pointer) == null ? void 0 : s5.point) || [0, 0], origin: ((a7 = this.pointer) == null ? void 0 : a7.origin) || [0, 0], key: e5.key, keys: Object.keys(this.keys), shiftKey: t5, ctrlKey: n5, metaKey: C3.isDarwin() ? o5 : n5, altKey: i4 };\n    });\n    E2(this, \"keyup\", (e5) => {\n      var s5, a7;\n      let { shiftKey: t5, ctrlKey: n5, metaKey: o5, altKey: i4 } = e5;\n      return delete this.keys[e5.key], { point: ((s5 = this.pointer) == null ? void 0 : s5.point) || [0, 0], origin: ((a7 = this.pointer) == null ? void 0 : a7.origin) || [0, 0], key: e5.key, keys: Object.keys(this.keys), shiftKey: t5, ctrlKey: n5, metaKey: C3.isDarwin() ? o5 : n5, altKey: i4 };\n    });\n  }\n  pointerIsValid(e5) {\n    if (\"pointerId\" in e5 && this.activePointer && this.activePointer !== e5.pointerId)\n      return false;\n    if (\"touches\" in e5) {\n      let t5 = e5.changedTouches[0];\n      if (this.activePointer && this.activePointer !== t5.identifier)\n        return false;\n    }\n    return true;\n  }\n  touchStart(e5, t5) {\n    let { shiftKey: n5, ctrlKey: o5, metaKey: i4, altKey: s5 } = e5, a7 = e5.changedTouches[0];\n    this.activePointer = a7.identifier;\n    let d6 = { target: t5, pointerId: a7.identifier, origin: H2.getPoint(a7, this.bounds), delta: [0, 0], point: H2.getPoint(a7, this.bounds), pressure: H2.getPressure(a7), shiftKey: n5, ctrlKey: o5, metaKey: C3.isDarwin() ? i4 : o5, altKey: s5, spaceKey: this.keys[\" \"] };\n    return this.pointer = d6, d6;\n  }\n  touchEnd(e5, t5) {\n    let { shiftKey: n5, ctrlKey: o5, metaKey: i4, altKey: s5 } = e5, a7 = e5.changedTouches[0], d6 = { target: t5, pointerId: a7.identifier, origin: H2.getPoint(a7, this.bounds), delta: [0, 0], point: H2.getPoint(a7, this.bounds), pressure: H2.getPressure(a7), shiftKey: n5, ctrlKey: o5, metaKey: C3.isDarwin() ? i4 : o5, altKey: s5, spaceKey: this.keys[\" \"] };\n    return this.pointer = d6, this.activePointer = void 0, d6;\n  }\n  touchMove(e5, t5) {\n    let { shiftKey: n5, ctrlKey: o5, metaKey: i4, altKey: s5 } = e5, a7 = e5.changedTouches[0], d6 = this.pointer, l7 = H2.getPoint(a7, this.bounds), c5 = (d6 == null ? void 0 : d6.point) ? e.sub(l7, d6.point) : [0, 0], m6 = U2(g2({ origin: l7 }, d6), { target: t5, pointerId: a7.identifier, point: l7, delta: c5, pressure: H2.getPressure(a7), shiftKey: n5, ctrlKey: o5, metaKey: C3.isDarwin() ? i4 : o5, altKey: s5, spaceKey: this.keys[\" \"] });\n    return this.pointer = m6, m6;\n  }\n  pointerDown(e5, t5) {\n    let { shiftKey: n5, ctrlKey: o5, metaKey: i4, altKey: s5 } = e5, a7 = H2.getPoint(e5, this.bounds);\n    this.activePointer = e5.pointerId;\n    let d6 = { target: t5, pointerId: e5.pointerId, origin: a7, point: a7, delta: [0, 0], pressure: H2.getPressure(e5), shiftKey: n5, ctrlKey: o5, metaKey: C3.isDarwin() ? i4 : o5, altKey: s5, spaceKey: this.keys[\" \"] };\n    return this.pointer = d6, d6;\n  }\n  pointerEnter(e5, t5) {\n    let { shiftKey: n5, ctrlKey: o5, metaKey: i4, altKey: s5 } = e5, a7 = H2.getPoint(e5, this.bounds), d6 = { target: t5, pointerId: e5.pointerId, origin: a7, delta: [0, 0], point: a7, pressure: H2.getPressure(e5), shiftKey: n5, ctrlKey: o5, metaKey: C3.isDarwin() ? i4 : o5, altKey: s5, spaceKey: this.keys[\" \"] };\n    return this.pointer = d6, d6;\n  }\n  pointerMove(e5, t5) {\n    let { shiftKey: n5, ctrlKey: o5, metaKey: i4, altKey: s5 } = e5, a7 = this.pointer, d6 = H2.getPoint(e5, this.bounds), l7 = (a7 == null ? void 0 : a7.point) ? e.sub(d6, a7.point) : [0, 0], c5 = U2(g2({ origin: d6 }, a7), { target: t5, pointerId: e5.pointerId, point: d6, delta: l7, pressure: H2.getPressure(e5), shiftKey: n5, ctrlKey: o5, metaKey: C3.isDarwin() ? i4 : o5, altKey: s5, spaceKey: this.keys[\" \"] });\n    return this.pointer = c5, c5;\n  }\n  pointerUp(e5, t5) {\n    let { shiftKey: n5, ctrlKey: o5, metaKey: i4, altKey: s5 } = e5, a7 = this.pointer, d6 = H2.getPoint(e5, this.bounds), l7 = (a7 == null ? void 0 : a7.point) ? e.sub(d6, a7.point) : [0, 0];\n    this.activePointer = void 0;\n    let c5 = U2(g2({ origin: d6 }, a7), { target: t5, pointerId: e5.pointerId, point: d6, delta: l7, pressure: H2.getPressure(e5), shiftKey: n5, ctrlKey: o5, metaKey: C3.isDarwin() ? i4 : o5, altKey: s5, spaceKey: this.keys[\" \"] });\n    return this.pointer = c5, this.pointerUpTime = performance.now(), c5;\n  }\n  isDoubleClick() {\n    if (!this.pointer)\n      return false;\n    let { origin: e5, point: t5 } = this.pointer, n5 = performance.now() - this.pointerUpTime < Nn && e.dist(e5, t5) < 4;\n    return n5 && (this.activePointer = void 0), n5;\n  }\n  clear() {\n    this.pointer = void 0;\n  }\n  resetDoubleClick() {\n    this.pointerUpTime = 0;\n  }\n  pinch(e5, t5) {\n    let { shiftKey: n5, ctrlKey: o5, metaKey: i4, altKey: s5 } = this.keys, a7 = e.sub(t5, e5), d6 = { pointerId: 0, target: \"pinch\", origin: t5, delta: a7, point: e.sub(e.toFixed(e5), [this.bounds.minX, this.bounds.minY]), pressure: 0.5, shiftKey: n5, ctrlKey: o5, metaKey: C3.isDarwin() ? i4 : o5, altKey: s5, spaceKey: this.keys[\" \"] };\n    return this.pointer = d6, d6;\n  }\n  reset() {\n    this.pointerUpTime = 0, this.pointer = void 0, this.keyboard = void 0, this.activePointer = void 0, this.keys = {};\n  }\n  static getPoint(e5, t5) {\n    return [+e5.clientX.toFixed(2) - t5.minX, +e5.clientY.toFixed(2) - t5.minY];\n  }\n  static getPressure(e5) {\n    return \"pressure\" in e5 && +e5.pressure.toFixed(2) || 0.5;\n  }\n  static commandKey() {\n    return C3.isDarwin() ? \"\\u2318\" : \"Ctrl\";\n  }\n};\nvar Cs = new H2();\nvar Wn = Object.freeze({});\nfunction An(M3) {\n  var I3 = M3, { id: r5 = \"tl\", shapeUtils: e5, page: t5, pageState: n5, assets: o5 = Wn, users: i4, userId: s5, theme: a7, meta: d6, snapLines: l7, eraseLine: c5, grid: m6, containerRef: p6, performanceMode: u5, components: y6, hideHandles: T5 = false, hideIndicators: v6 = false, hideCloneHandles: x5 = false, hideBindingHandles: f5 = false, hideResizeHandles: L5 = false, hideRotateHandles: Y3 = false, hideBounds: X3 = false, hideGrid: S4 = true, showDashedBrush: b6 = false, hideCursors: P4 } = I3, B4 = O2(I3, [\"id\", \"shapeUtils\", \"page\", \"pageState\", \"assets\", \"users\", \"userId\", \"theme\", \"meta\", \"snapLines\", \"eraseLine\", \"grid\", \"containerRef\", \"performanceMode\", \"components\", \"hideHandles\", \"hideIndicators\", \"hideCloneHandles\", \"hideBindingHandles\", \"hideResizeHandles\", \"hideRotateHandles\", \"hideBounds\", \"hideGrid\", \"showDashedBrush\", \"hideCursors\"]);\n  dt(a7, \"#\" + r5);\n  let A5 = N2.useRef(null), J3 = N2.useRef(n5);\n  N2.useEffect(() => {\n    J3.current = n5;\n  }, [n5]);\n  let [Ft, Gt] = N2.useState(() => ({ callbacks: B4, shapeUtils: e5, rSelectionBounds: A5, rPageState: J3, bounds: { minX: 0, minY: 0, maxX: 1 / 0, maxY: 1 / 0, width: 1 / 0, height: 1 / 0 }, inputs: new H2() })), jt = N2.useCallback((_t) => {\n    Gt((Zt) => U2(g2({}, Zt), { bounds: _t }));\n  }, []);\n  return N2.createElement(Le.Provider, { value: Ft }, N2.createElement(zt, { id: r5, page: t5, pageState: n5, assets: o5, snapLines: l7, eraseLine: c5, grid: m6, users: i4, userId: s5, externalContainerRef: p6, hideBounds: X3, hideIndicators: v6, hideHandles: T5, hideCloneHandles: x5, hideBindingHandles: f5, hideRotateHandle: Y3, hideResizeHandles: L5, hideGrid: S4, showDashedBrush: b6, onBoundsChange: jt, performanceMode: u5, components: y6, meta: d6, hideCursors: P4 }));\n}\nvar ks = N2.memo(An);\nvar Xs = me2.memo(me2.forwardRef(function(i4, o5) {\n  var s5 = i4, { children: e5, className: t5 = \"\" } = s5, n5 = O2(s5, [\"children\", \"className\"]);\n  return me2.createElement(\"div\", g2({ ref: o5, className: `tl-positioned-div ${t5}`, draggable: false }, n5), me2.createElement(\"div\", { className: \"tl-inner-div\" }, e5));\n}));\nvar _e2 = class {\n  constructor() {\n    E2(this, \"refMap\", /* @__PURE__ */ new Map());\n    E2(this, \"boundsCache\", /* @__PURE__ */ new WeakMap());\n    E2(this, \"showCloneHandles\", false);\n    E2(this, \"hideBounds\", false);\n    E2(this, \"isStateful\", false);\n    E2(this, \"shouldRender\", (e5, t5) => true);\n    E2(this, \"getRef\", (e5) => (this.refMap.has(e5.id) || this.refMap.set(e5.id, Ae.createRef()), this.refMap.get(e5.id)));\n    E2(this, \"hitTestBounds\", (e5, t5) => {\n      let n5 = this.getBounds(e5), o5 = w2.getRotatedCorners(n5, e5.rotation);\n      return o5.every((i4) => w2.pointInBounds(i4, t5)) || ee2(o5, t5).length > 0;\n    });\n    E2(this, \"getRotatedBounds\", (e5) => w2.getBoundsFromPoints(w2.getRotatedCorners(this.getBounds(e5), e5.rotation)));\n  }\n};\nE2(_e2, \"Component\", (e5) => Ae.forwardRef(e5)), E2(_e2, \"Indicator\", (e5) => e5);\n\n// node_modules/@babel/runtime/helpers/esm/extends.js\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function(target) {\n    for (var i4 = 1; i4 < arguments.length; i4++) {\n      var source = arguments[i4];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n// node_modules/@radix-ui/react-context-menu/dist/index.module.js\nvar import_react29 = require(\"react\");\n\n// node_modules/@radix-ui/primitive/dist/index.module.js\nfunction $e42e1063c40fb3ef$export$b9ecd428b558ff10(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {\n  return function handleEvent(event) {\n    originalEventHandler === null || originalEventHandler === void 0 || originalEventHandler(event);\n    if (checkForDefaultPrevented === false || !event.defaultPrevented)\n      return ourEventHandler === null || ourEventHandler === void 0 ? void 0 : ourEventHandler(event);\n  };\n}\n\n// node_modules/@radix-ui/react-context/dist/index.module.js\nvar import_react7 = require(\"react\");\nfunction $c512c27ab02ef895$export$fd42f52fd3ae1109(rootComponentName, defaultContext) {\n  const Context = /* @__PURE__ */ (0, import_react7.createContext)(defaultContext);\n  function Provider(props) {\n    const { children, ...context } = props;\n    const value = (0, import_react7.useMemo)(\n      () => context,\n      Object.values(context)\n    );\n    return /* @__PURE__ */ (0, import_react7.createElement)(Context.Provider, {\n      value\n    }, children);\n  }\n  function useContext5(consumerName) {\n    const context = (0, import_react7.useContext)(Context);\n    if (context)\n      return context;\n    if (defaultContext !== void 0)\n      return defaultContext;\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${rootComponentName}\\``);\n  }\n  Provider.displayName = rootComponentName + \"Provider\";\n  return [\n    Provider,\n    useContext5\n  ];\n}\nfunction $c512c27ab02ef895$export$50c7b4e9d9f19c1(scopeName, createContextScopeDeps = []) {\n  let defaultContexts = [];\n  function $c512c27ab02ef895$export$fd42f52fd3ae11092(rootComponentName, defaultContext) {\n    const BaseContext = /* @__PURE__ */ (0, import_react7.createContext)(defaultContext);\n    const index2 = defaultContexts.length;\n    defaultContexts = [\n      ...defaultContexts,\n      defaultContext\n    ];\n    function Provider(props) {\n      const { scope, children, ...context } = props;\n      const Context = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index2]) || BaseContext;\n      const value = (0, import_react7.useMemo)(\n        () => context,\n        Object.values(context)\n      );\n      return /* @__PURE__ */ (0, import_react7.createElement)(Context.Provider, {\n        value\n      }, children);\n    }\n    function useContext5(consumerName, scope) {\n      const Context = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index2]) || BaseContext;\n      const context = (0, import_react7.useContext)(Context);\n      if (context)\n        return context;\n      if (defaultContext !== void 0)\n        return defaultContext;\n      throw new Error(`\\`${consumerName}\\` must be used within \\`${rootComponentName}\\``);\n    }\n    Provider.displayName = rootComponentName + \"Provider\";\n    return [\n      Provider,\n      useContext5\n    ];\n  }\n  const createScope = () => {\n    const scopeContexts = defaultContexts.map((defaultContext) => {\n      return /* @__PURE__ */ (0, import_react7.createContext)(defaultContext);\n    });\n    return function useScope(scope) {\n      const contexts = (scope === null || scope === void 0 ? void 0 : scope[scopeName]) || scopeContexts;\n      return (0, import_react7.useMemo)(\n        () => ({\n          [`__scope${scopeName}`]: {\n            ...scope,\n            [scopeName]: contexts\n          }\n        }),\n        [\n          scope,\n          contexts\n        ]\n      );\n    };\n  };\n  createScope.scopeName = scopeName;\n  return [\n    $c512c27ab02ef895$export$fd42f52fd3ae11092,\n    $c512c27ab02ef895$var$composeContextScopes(createScope, ...createContextScopeDeps)\n  ];\n}\nfunction $c512c27ab02ef895$var$composeContextScopes(...scopes) {\n  const baseScope = scopes[0];\n  if (scopes.length === 1)\n    return baseScope;\n  const createScope1 = () => {\n    const scopeHooks = scopes.map(\n      (createScope) => ({\n        useScope: createScope(),\n        scopeName: createScope.scopeName\n      })\n    );\n    return function useComposedScopes(overrideScopes) {\n      const nextScopes1 = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {\n        const scopeProps = useScope(overrideScopes);\n        const currentScope = scopeProps[`__scope${scopeName}`];\n        return {\n          ...nextScopes,\n          ...currentScope\n        };\n      }, {});\n      return (0, import_react7.useMemo)(\n        () => ({\n          [`__scope${baseScope.scopeName}`]: nextScopes1\n        }),\n        [\n          nextScopes1\n        ]\n      );\n    };\n  };\n  createScope1.scopeName = baseScope.scopeName;\n  return createScope1;\n}\n\n// node_modules/@radix-ui/react-primitive/dist/index.module.js\nvar import_react10 = require(\"react\");\nvar import_react_dom = require(\"react-dom\");\n\n// node_modules/@radix-ui/react-slot/dist/index.module.js\nvar import_react9 = require(\"react\");\n\n// node_modules/@radix-ui/react-compose-refs/dist/index.module.js\nvar import_react8 = require(\"react\");\nfunction $6ed0406888f73fc4$var$setRef(ref, value) {\n  if (typeof ref === \"function\")\n    ref(value);\n  else if (ref !== null && ref !== void 0)\n    ref.current = value;\n}\nfunction $6ed0406888f73fc4$export$43e446d32b3d21af(...refs) {\n  return (node) => refs.forEach(\n    (ref) => $6ed0406888f73fc4$var$setRef(ref, node)\n  );\n}\nfunction $6ed0406888f73fc4$export$c7b2cbe3552a0d05(...refs) {\n  return (0, import_react8.useCallback)($6ed0406888f73fc4$export$43e446d32b3d21af(...refs), refs);\n}\n\n// node_modules/@radix-ui/react-slot/dist/index.module.js\nvar $5e63c961fc1ce211$export$8c6ed5c666ac1360 = /* @__PURE__ */ (0, import_react9.forwardRef)((props, forwardedRef) => {\n  const { children, ...slotProps } = props;\n  const childrenArray = import_react9.Children.toArray(children);\n  const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable);\n  if (slottable) {\n    const newElement = slottable.props.children;\n    const newChildren = childrenArray.map((child) => {\n      if (child === slottable) {\n        if (import_react9.Children.count(newElement) > 1)\n          return import_react9.Children.only(null);\n        return /* @__PURE__ */ (0, import_react9.isValidElement)(newElement) ? newElement.props.children : null;\n      } else\n        return child;\n    });\n    return /* @__PURE__ */ (0, import_react9.createElement)($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {\n      ref: forwardedRef\n    }), /* @__PURE__ */ (0, import_react9.isValidElement)(newElement) ? /* @__PURE__ */ (0, import_react9.cloneElement)(newElement, void 0, newChildren) : null);\n  }\n  return /* @__PURE__ */ (0, import_react9.createElement)($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {\n    ref: forwardedRef\n  }), children);\n});\n$5e63c961fc1ce211$export$8c6ed5c666ac1360.displayName = \"Slot\";\nvar $5e63c961fc1ce211$var$SlotClone = /* @__PURE__ */ (0, import_react9.forwardRef)((props, forwardedRef) => {\n  const { children, ...slotProps } = props;\n  if (/* @__PURE__ */ (0, import_react9.isValidElement)(children))\n    return /* @__PURE__ */ (0, import_react9.cloneElement)(children, {\n      ...$5e63c961fc1ce211$var$mergeProps(slotProps, children.props),\n      ref: $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, children.ref)\n    });\n  return import_react9.Children.count(children) > 1 ? import_react9.Children.only(null) : null;\n});\n$5e63c961fc1ce211$var$SlotClone.displayName = \"SlotClone\";\nvar $5e63c961fc1ce211$export$d9f1ccf0bdb05d45 = ({ children }) => {\n  return /* @__PURE__ */ (0, import_react9.createElement)(import_react9.Fragment, null, children);\n};\nfunction $5e63c961fc1ce211$var$isSlottable(child) {\n  return /* @__PURE__ */ (0, import_react9.isValidElement)(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d45;\n}\nfunction $5e63c961fc1ce211$var$mergeProps(slotProps, childProps) {\n  const overrideProps = {\n    ...childProps\n  };\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n    const isHandler = /^on[A-Z]/.test(propName);\n    if (isHandler) {\n      if (slotPropValue && childPropValue)\n        overrideProps[propName] = (...args) => {\n          childPropValue(...args);\n          slotPropValue(...args);\n        };\n      else if (slotPropValue)\n        overrideProps[propName] = slotPropValue;\n    } else if (propName === \"style\")\n      overrideProps[propName] = {\n        ...slotPropValue,\n        ...childPropValue\n      };\n    else if (propName === \"className\")\n      overrideProps[propName] = [\n        slotPropValue,\n        childPropValue\n      ].filter(Boolean).join(\" \");\n  }\n  return {\n    ...slotProps,\n    ...overrideProps\n  };\n}\n\n// node_modules/@radix-ui/react-primitive/dist/index.module.js\nvar $8927f6f2acc4f386$var$NODES = [\n  \"a\",\n  \"button\",\n  \"div\",\n  \"h2\",\n  \"h3\",\n  \"img\",\n  \"label\",\n  \"li\",\n  \"nav\",\n  \"ol\",\n  \"p\",\n  \"span\",\n  \"svg\",\n  \"ul\"\n];\nvar $8927f6f2acc4f386$export$250ffa63cdc0d034 = $8927f6f2acc4f386$var$NODES.reduce((primitive, node) => {\n  const Node = /* @__PURE__ */ (0, import_react10.forwardRef)((props, forwardedRef) => {\n    const { asChild, ...primitiveProps } = props;\n    const Comp = asChild ? $5e63c961fc1ce211$export$8c6ed5c666ac1360 : node;\n    (0, import_react10.useEffect)(() => {\n      window[Symbol.for(\"radix-ui\")] = true;\n    }, []);\n    return /* @__PURE__ */ (0, import_react10.createElement)(Comp, _extends({}, primitiveProps, {\n      ref: forwardedRef\n    }));\n  });\n  Node.displayName = `Primitive.${node}`;\n  return {\n    ...primitive,\n    [node]: Node\n  };\n}, {});\nfunction $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event) {\n  if (target)\n    (0, import_react_dom.flushSync)(\n      () => target.dispatchEvent(event)\n    );\n}\n\n// node_modules/@radix-ui/react-menu/dist/index.module.js\nvar import_react28 = require(\"react\");\n\n// node_modules/@radix-ui/react-collection/dist/index.module.js\nvar import_react11 = __toESM(require(\"react\"));\nfunction $e02a7d9cb1dc128c$export$c74125a8e3af6bb2(name) {\n  const PROVIDER_NAME = name + \"CollectionProvider\";\n  const [createCollectionContext, createCollectionScope] = $c512c27ab02ef895$export$50c7b4e9d9f19c1(PROVIDER_NAME);\n  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(PROVIDER_NAME, {\n    collectionRef: {\n      current: null\n    },\n    itemMap: /* @__PURE__ */ new Map()\n  });\n  const CollectionProvider = (props) => {\n    const { scope, children } = props;\n    const ref = import_react11.default.useRef(null);\n    const itemMap = import_react11.default.useRef(/* @__PURE__ */ new Map()).current;\n    return /* @__PURE__ */ import_react11.default.createElement(CollectionProviderImpl, {\n      scope,\n      itemMap,\n      collectionRef: ref\n    }, children);\n  };\n  /* @__PURE__ */ Object.assign(CollectionProvider, {\n    displayName: PROVIDER_NAME\n  });\n  const COLLECTION_SLOT_NAME = name + \"CollectionSlot\";\n  const CollectionSlot = /* @__PURE__ */ import_react11.default.forwardRef((props, forwardedRef) => {\n    const { scope, children } = props;\n    const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);\n    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.collectionRef);\n    return /* @__PURE__ */ import_react11.default.createElement($5e63c961fc1ce211$export$8c6ed5c666ac1360, {\n      ref: composedRefs\n    }, children);\n  });\n  /* @__PURE__ */ Object.assign(CollectionSlot, {\n    displayName: COLLECTION_SLOT_NAME\n  });\n  const ITEM_SLOT_NAME = name + \"CollectionItemSlot\";\n  const ITEM_DATA_ATTR = \"data-radix-collection-item\";\n  const CollectionItemSlot = /* @__PURE__ */ import_react11.default.forwardRef((props, forwardedRef) => {\n    const { scope, children, ...itemData } = props;\n    const ref = import_react11.default.useRef(null);\n    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);\n    const context = useCollectionContext(ITEM_SLOT_NAME, scope);\n    import_react11.default.useEffect(() => {\n      context.itemMap.set(ref, {\n        ref,\n        ...itemData\n      });\n      return () => void context.itemMap.delete(ref);\n    });\n    return /* @__PURE__ */ import_react11.default.createElement($5e63c961fc1ce211$export$8c6ed5c666ac1360, {\n      [ITEM_DATA_ATTR]: \"\",\n      ref: composedRefs\n    }, children);\n  });\n  /* @__PURE__ */ Object.assign(CollectionItemSlot, {\n    displayName: ITEM_SLOT_NAME\n  });\n  function useCollection(scope) {\n    const context = useCollectionContext(name + \"CollectionConsumer\", scope);\n    const getItems = import_react11.default.useCallback(() => {\n      const collectionNode = context.collectionRef.current;\n      if (!collectionNode)\n        return [];\n      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));\n      const items = Array.from(context.itemMap.values());\n      const orderedItems = items.sort(\n        (a7, b6) => orderedNodes.indexOf(a7.ref.current) - orderedNodes.indexOf(b6.ref.current)\n      );\n      return orderedItems;\n    }, [\n      context.collectionRef,\n      context.itemMap\n    ]);\n    return getItems;\n  }\n  return [\n    {\n      Provider: CollectionProvider,\n      Slot: CollectionSlot,\n      ItemSlot: CollectionItemSlot\n    },\n    useCollection,\n    createCollectionScope\n  ];\n}\n\n// node_modules/@radix-ui/react-direction/dist/index.module.js\nvar import_react12 = require(\"react\");\nvar $f631663db3294ace$var$DirectionContext = /* @__PURE__ */ (0, import_react12.createContext)(void 0);\nfunction $f631663db3294ace$export$b39126d51d94e6f3(localDir) {\n  const globalDir = (0, import_react12.useContext)($f631663db3294ace$var$DirectionContext);\n  return localDir || globalDir || \"ltr\";\n}\n\n// node_modules/@radix-ui/react-dismissable-layer/dist/index.module.js\nvar import_react15 = require(\"react\");\n\n// node_modules/@radix-ui/react-use-callback-ref/dist/index.module.js\nvar import_react13 = require(\"react\");\nfunction $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(callback) {\n  const callbackRef = (0, import_react13.useRef)(callback);\n  (0, import_react13.useEffect)(() => {\n    callbackRef.current = callback;\n  });\n  return (0, import_react13.useMemo)(\n    () => (...args) => {\n      var _callbackRef$current;\n      return (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 ? void 0 : _callbackRef$current.call(callbackRef, ...args);\n    },\n    []\n  );\n}\n\n// node_modules/@radix-ui/react-use-escape-keydown/dist/index.module.js\nvar import_react14 = require(\"react\");\nfunction $addc16e1bbe58fd0$export$3a72a57244d6e765(onEscapeKeyDownProp, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {\n  const onEscapeKeyDown = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onEscapeKeyDownProp);\n  (0, import_react14.useEffect)(() => {\n    const handleKeyDown = (event) => {\n      if (event.key === \"Escape\")\n        onEscapeKeyDown(event);\n    };\n    ownerDocument.addEventListener(\"keydown\", handleKeyDown);\n    return () => ownerDocument.removeEventListener(\"keydown\", handleKeyDown);\n  }, [\n    onEscapeKeyDown,\n    ownerDocument\n  ]);\n}\n\n// node_modules/@radix-ui/react-dismissable-layer/dist/index.module.js\nvar $5cb92bef7577960e$var$CONTEXT_UPDATE = \"dismissableLayer.update\";\nvar $5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE = \"dismissableLayer.pointerDownOutside\";\nvar $5cb92bef7577960e$var$FOCUS_OUTSIDE = \"dismissableLayer.focusOutside\";\nvar $5cb92bef7577960e$var$originalBodyPointerEvents;\nvar $5cb92bef7577960e$var$DismissableLayerContext = /* @__PURE__ */ (0, import_react15.createContext)({\n  layers: /* @__PURE__ */ new Set(),\n  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),\n  branches: /* @__PURE__ */ new Set()\n});\nvar $5cb92bef7577960e$export$177fb62ff3ec1f22 = /* @__PURE__ */ (0, import_react15.forwardRef)((props, forwardedRef) => {\n  var _node$ownerDocument;\n  const { disableOutsidePointerEvents = false, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, onDismiss, ...layerProps } = props;\n  const context = (0, import_react15.useContext)($5cb92bef7577960e$var$DismissableLayerContext);\n  const [node1, setNode] = (0, import_react15.useState)(null);\n  const ownerDocument = (_node$ownerDocument = node1 === null || node1 === void 0 ? void 0 : node1.ownerDocument) !== null && _node$ownerDocument !== void 0 ? _node$ownerDocument : globalThis === null || globalThis === void 0 ? void 0 : globalThis.document;\n  const [, force] = (0, import_react15.useState)({});\n  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(\n    forwardedRef,\n    (node) => setNode(node)\n  );\n  const layers = Array.from(context.layers);\n  const [highestLayerWithOutsidePointerEventsDisabled] = [\n    ...context.layersWithOutsidePointerEventsDisabled\n  ].slice(-1);\n  const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);\n  const index2 = node1 ? layers.indexOf(node1) : -1;\n  const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;\n  const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;\n  const pointerDownOutside = $5cb92bef7577960e$var$usePointerDownOutside((event) => {\n    const target = event.target;\n    const isPointerDownOnBranch = [\n      ...context.branches\n    ].some(\n      (branch) => branch.contains(target)\n    );\n    if (!isPointerEventsEnabled || isPointerDownOnBranch)\n      return;\n    onPointerDownOutside === null || onPointerDownOutside === void 0 || onPointerDownOutside(event);\n    onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);\n    if (!event.defaultPrevented)\n      onDismiss === null || onDismiss === void 0 || onDismiss();\n  }, ownerDocument);\n  const focusOutside = $5cb92bef7577960e$var$useFocusOutside((event) => {\n    const target = event.target;\n    const isFocusInBranch = [\n      ...context.branches\n    ].some(\n      (branch) => branch.contains(target)\n    );\n    if (isFocusInBranch)\n      return;\n    onFocusOutside === null || onFocusOutside === void 0 || onFocusOutside(event);\n    onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);\n    if (!event.defaultPrevented)\n      onDismiss === null || onDismiss === void 0 || onDismiss();\n  }, ownerDocument);\n  $addc16e1bbe58fd0$export$3a72a57244d6e765((event) => {\n    const isHighestLayer = index2 === context.layers.size - 1;\n    if (!isHighestLayer)\n      return;\n    onEscapeKeyDown === null || onEscapeKeyDown === void 0 || onEscapeKeyDown(event);\n    if (!event.defaultPrevented && onDismiss) {\n      event.preventDefault();\n      onDismiss();\n    }\n  }, ownerDocument);\n  (0, import_react15.useEffect)(() => {\n    if (!node1)\n      return;\n    if (disableOutsidePointerEvents) {\n      if (context.layersWithOutsidePointerEventsDisabled.size === 0) {\n        $5cb92bef7577960e$var$originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;\n        ownerDocument.body.style.pointerEvents = \"none\";\n      }\n      context.layersWithOutsidePointerEventsDisabled.add(node1);\n    }\n    context.layers.add(node1);\n    $5cb92bef7577960e$var$dispatchUpdate();\n    return () => {\n      if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1)\n        ownerDocument.body.style.pointerEvents = $5cb92bef7577960e$var$originalBodyPointerEvents;\n    };\n  }, [\n    node1,\n    ownerDocument,\n    disableOutsidePointerEvents,\n    context\n  ]);\n  (0, import_react15.useEffect)(() => {\n    return () => {\n      if (!node1)\n        return;\n      context.layers.delete(node1);\n      context.layersWithOutsidePointerEventsDisabled.delete(node1);\n      $5cb92bef7577960e$var$dispatchUpdate();\n    };\n  }, [\n    node1,\n    context\n  ]);\n  (0, import_react15.useEffect)(() => {\n    const handleUpdate = () => force({});\n    document.addEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate);\n    return () => document.removeEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate);\n  }, []);\n  return /* @__PURE__ */ (0, import_react15.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, layerProps, {\n    ref: composedRefs,\n    style: {\n      pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? \"auto\" : \"none\" : void 0,\n      ...props.style\n    },\n    onFocusCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocusCapture, focusOutside.onFocusCapture),\n    onBlurCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlurCapture, focusOutside.onBlurCapture),\n    onPointerDownCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownCapture, pointerDownOutside.onPointerDownCapture)\n  }));\n});\nfunction $5cb92bef7577960e$var$usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {\n  const handlePointerDownOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onPointerDownOutside);\n  const isPointerInsideReactTreeRef = (0, import_react15.useRef)(false);\n  const handleClickRef = (0, import_react15.useRef)(() => {\n  });\n  (0, import_react15.useEffect)(() => {\n    const handlePointerDown = (event) => {\n      if (event.target && !isPointerInsideReactTreeRef.current) {\n        let handleAndDispatchPointerDownOutsideEvent = function() {\n          $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE, handlePointerDownOutside, eventDetail, {\n            discrete: true\n          });\n        };\n        const eventDetail = {\n          originalEvent: event\n        };\n        if (event.pointerType === \"touch\") {\n          ownerDocument.removeEventListener(\"click\", handleClickRef.current);\n          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent;\n          ownerDocument.addEventListener(\"click\", handleClickRef.current, {\n            once: true\n          });\n        } else\n          handleAndDispatchPointerDownOutsideEvent();\n      }\n      isPointerInsideReactTreeRef.current = false;\n    };\n    const timerId = window.setTimeout(() => {\n      ownerDocument.addEventListener(\"pointerdown\", handlePointerDown);\n    }, 0);\n    return () => {\n      window.clearTimeout(timerId);\n      ownerDocument.removeEventListener(\"pointerdown\", handlePointerDown);\n      ownerDocument.removeEventListener(\"click\", handleClickRef.current);\n    };\n  }, [\n    ownerDocument,\n    handlePointerDownOutside\n  ]);\n  return {\n    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true\n  };\n}\nfunction $5cb92bef7577960e$var$useFocusOutside(onFocusOutside, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {\n  const handleFocusOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onFocusOutside);\n  const isFocusInsideReactTreeRef = (0, import_react15.useRef)(false);\n  (0, import_react15.useEffect)(() => {\n    const handleFocus = (event) => {\n      if (event.target && !isFocusInsideReactTreeRef.current) {\n        const eventDetail = {\n          originalEvent: event\n        };\n        $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {\n          discrete: false\n        });\n      }\n    };\n    ownerDocument.addEventListener(\"focusin\", handleFocus);\n    return () => ownerDocument.removeEventListener(\"focusin\", handleFocus);\n  }, [\n    ownerDocument,\n    handleFocusOutside\n  ]);\n  return {\n    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,\n    onBlurCapture: () => isFocusInsideReactTreeRef.current = false\n  };\n}\nfunction $5cb92bef7577960e$var$dispatchUpdate() {\n  const event = new CustomEvent($5cb92bef7577960e$var$CONTEXT_UPDATE);\n  document.dispatchEvent(event);\n}\nfunction $5cb92bef7577960e$var$handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {\n  const target = detail.originalEvent.target;\n  const event = new CustomEvent(name, {\n    bubbles: false,\n    cancelable: true,\n    detail\n  });\n  if (handler)\n    target.addEventListener(name, handler, {\n      once: true\n    });\n  if (discrete)\n    $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event);\n  else\n    target.dispatchEvent(event);\n}\n\n// node_modules/@radix-ui/react-focus-guards/dist/index.module.js\nvar import_react16 = require(\"react\");\nvar $3db38b7d1fb3fe6a$var$count = 0;\nfunction $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c() {\n  (0, import_react16.useEffect)(() => {\n    var _edgeGuards$, _edgeGuards$2;\n    const edgeGuards = document.querySelectorAll(\"[data-radix-focus-guard]\");\n    document.body.insertAdjacentElement(\"afterbegin\", (_edgeGuards$ = edgeGuards[0]) !== null && _edgeGuards$ !== void 0 ? _edgeGuards$ : $3db38b7d1fb3fe6a$var$createFocusGuard());\n    document.body.insertAdjacentElement(\"beforeend\", (_edgeGuards$2 = edgeGuards[1]) !== null && _edgeGuards$2 !== void 0 ? _edgeGuards$2 : $3db38b7d1fb3fe6a$var$createFocusGuard());\n    $3db38b7d1fb3fe6a$var$count++;\n    return () => {\n      if ($3db38b7d1fb3fe6a$var$count === 1)\n        document.querySelectorAll(\"[data-radix-focus-guard]\").forEach(\n          (node) => node.remove()\n        );\n      $3db38b7d1fb3fe6a$var$count--;\n    };\n  }, []);\n}\nfunction $3db38b7d1fb3fe6a$var$createFocusGuard() {\n  const element = document.createElement(\"span\");\n  element.setAttribute(\"data-radix-focus-guard\", \"\");\n  element.tabIndex = 0;\n  element.style.cssText = \"outline: none; opacity: 0; position: fixed; pointer-events: none\";\n  return element;\n}\n\n// node_modules/@radix-ui/react-focus-scope/dist/index.module.js\nvar import_react17 = require(\"react\");\nvar $d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT = \"focusScope.autoFocusOnMount\";\nvar $d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT = \"focusScope.autoFocusOnUnmount\";\nvar $d3863c46a17e8a28$var$EVENT_OPTIONS = {\n  bubbles: false,\n  cancelable: true\n};\nvar $d3863c46a17e8a28$export$20e40289641fbbb6 = /* @__PURE__ */ (0, import_react17.forwardRef)((props, forwardedRef) => {\n  const { loop = false, trapped = false, onMountAutoFocus: onMountAutoFocusProp, onUnmountAutoFocus: onUnmountAutoFocusProp, ...scopeProps } = props;\n  const [container1, setContainer] = (0, import_react17.useState)(null);\n  const onMountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onMountAutoFocusProp);\n  const onUnmountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onUnmountAutoFocusProp);\n  const lastFocusedElementRef = (0, import_react17.useRef)(null);\n  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(\n    forwardedRef,\n    (node) => setContainer(node)\n  );\n  const focusScope = (0, import_react17.useRef)({\n    paused: false,\n    pause() {\n      this.paused = true;\n    },\n    resume() {\n      this.paused = false;\n    }\n  }).current;\n  (0, import_react17.useEffect)(() => {\n    if (trapped) {\n      let handleFocusIn = function(event) {\n        if (focusScope.paused || !container1)\n          return;\n        const target = event.target;\n        if (container1.contains(target))\n          lastFocusedElementRef.current = target;\n        else\n          $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {\n            select: true\n          });\n      }, handleFocusOut = function(event) {\n        if (focusScope.paused || !container1)\n          return;\n        if (!container1.contains(event.relatedTarget))\n          $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {\n            select: true\n          });\n      };\n      document.addEventListener(\"focusin\", handleFocusIn);\n      document.addEventListener(\"focusout\", handleFocusOut);\n      return () => {\n        document.removeEventListener(\"focusin\", handleFocusIn);\n        document.removeEventListener(\"focusout\", handleFocusOut);\n      };\n    }\n  }, [\n    trapped,\n    container1,\n    focusScope.paused\n  ]);\n  (0, import_react17.useEffect)(() => {\n    if (container1) {\n      $d3863c46a17e8a28$var$focusScopesStack.add(focusScope);\n      const previouslyFocusedElement = document.activeElement;\n      const hasFocusedCandidate = container1.contains(previouslyFocusedElement);\n      if (!hasFocusedCandidate) {\n        const mountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);\n        container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        container1.dispatchEvent(mountEvent);\n        if (!mountEvent.defaultPrevented) {\n          $d3863c46a17e8a28$var$focusFirst($d3863c46a17e8a28$var$removeLinks($d3863c46a17e8a28$var$getTabbableCandidates(container1)), {\n            select: true\n          });\n          if (document.activeElement === previouslyFocusedElement)\n            $d3863c46a17e8a28$var$focus(container1);\n        }\n      }\n      return () => {\n        container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        setTimeout(() => {\n          const unmountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);\n          container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          container1.dispatchEvent(unmountEvent);\n          if (!unmountEvent.defaultPrevented)\n            $d3863c46a17e8a28$var$focus(previouslyFocusedElement !== null && previouslyFocusedElement !== void 0 ? previouslyFocusedElement : document.body, {\n              select: true\n            });\n          container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          $d3863c46a17e8a28$var$focusScopesStack.remove(focusScope);\n        }, 0);\n      };\n    }\n  }, [\n    container1,\n    onMountAutoFocus,\n    onUnmountAutoFocus,\n    focusScope\n  ]);\n  const handleKeyDown = (0, import_react17.useCallback)((event) => {\n    if (!loop && !trapped)\n      return;\n    if (focusScope.paused)\n      return;\n    const isTabKey = event.key === \"Tab\" && !event.altKey && !event.ctrlKey && !event.metaKey;\n    const focusedElement = document.activeElement;\n    if (isTabKey && focusedElement) {\n      const container = event.currentTarget;\n      const [first, last] = $d3863c46a17e8a28$var$getTabbableEdges(container);\n      const hasTabbableElementsInside = first && last;\n      if (!hasTabbableElementsInside) {\n        if (focusedElement === container)\n          event.preventDefault();\n      } else {\n        if (!event.shiftKey && focusedElement === last) {\n          event.preventDefault();\n          if (loop)\n            $d3863c46a17e8a28$var$focus(first, {\n              select: true\n            });\n        } else if (event.shiftKey && focusedElement === first) {\n          event.preventDefault();\n          if (loop)\n            $d3863c46a17e8a28$var$focus(last, {\n              select: true\n            });\n        }\n      }\n    }\n  }, [\n    loop,\n    trapped,\n    focusScope.paused\n  ]);\n  return /* @__PURE__ */ (0, import_react17.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({\n    tabIndex: -1\n  }, scopeProps, {\n    ref: composedRefs,\n    onKeyDown: handleKeyDown\n  }));\n});\nfunction $d3863c46a17e8a28$var$focusFirst(candidates, { select = false } = {}) {\n  const previouslyFocusedElement = document.activeElement;\n  for (const candidate of candidates) {\n    $d3863c46a17e8a28$var$focus(candidate, {\n      select\n    });\n    if (document.activeElement !== previouslyFocusedElement)\n      return;\n  }\n}\nfunction $d3863c46a17e8a28$var$getTabbableEdges(container) {\n  const candidates = $d3863c46a17e8a28$var$getTabbableCandidates(container);\n  const first = $d3863c46a17e8a28$var$findVisible(candidates, container);\n  const last = $d3863c46a17e8a28$var$findVisible(candidates.reverse(), container);\n  return [\n    first,\n    last\n  ];\n}\nfunction $d3863c46a17e8a28$var$getTabbableCandidates(container) {\n  const nodes = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node) => {\n      const isHiddenInput = node.tagName === \"INPUT\" && node.type === \"hidden\";\n      if (node.disabled || node.hidden || isHiddenInput)\n        return NodeFilter.FILTER_SKIP;\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  while (walker.nextNode())\n    nodes.push(walker.currentNode);\n  return nodes;\n}\nfunction $d3863c46a17e8a28$var$findVisible(elements, container) {\n  for (const element of elements) {\n    if (!$d3863c46a17e8a28$var$isHidden(element, {\n      upTo: container\n    }))\n      return element;\n  }\n}\nfunction $d3863c46a17e8a28$var$isHidden(node, { upTo }) {\n  if (getComputedStyle(node).visibility === \"hidden\")\n    return true;\n  while (node) {\n    if (upTo !== void 0 && node === upTo)\n      return false;\n    if (getComputedStyle(node).display === \"none\")\n      return true;\n    node = node.parentElement;\n  }\n  return false;\n}\nfunction $d3863c46a17e8a28$var$isSelectableInput(element) {\n  return element instanceof HTMLInputElement && \"select\" in element;\n}\nfunction $d3863c46a17e8a28$var$focus(element, { select = false } = {}) {\n  if (element && element.focus) {\n    const previouslyFocusedElement = document.activeElement;\n    element.focus({\n      preventScroll: true\n    });\n    if (element !== previouslyFocusedElement && $d3863c46a17e8a28$var$isSelectableInput(element) && select)\n      element.select();\n  }\n}\nvar $d3863c46a17e8a28$var$focusScopesStack = $d3863c46a17e8a28$var$createFocusScopesStack();\nfunction $d3863c46a17e8a28$var$createFocusScopesStack() {\n  let stack = [];\n  return {\n    add(focusScope) {\n      const activeFocusScope = stack[0];\n      if (focusScope !== activeFocusScope)\n        activeFocusScope === null || activeFocusScope === void 0 || activeFocusScope.pause();\n      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);\n      stack.unshift(focusScope);\n    },\n    remove(focusScope) {\n      var _stack$;\n      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);\n      (_stack$ = stack[0]) === null || _stack$ === void 0 || _stack$.resume();\n    }\n  };\n}\nfunction $d3863c46a17e8a28$var$arrayRemove(array, item) {\n  const updatedArray = [\n    ...array\n  ];\n  const index2 = updatedArray.indexOf(item);\n  if (index2 !== -1)\n    updatedArray.splice(index2, 1);\n  return updatedArray;\n}\nfunction $d3863c46a17e8a28$var$removeLinks(items) {\n  return items.filter(\n    (item) => item.tagName !== \"A\"\n  );\n}\n\n// node_modules/@radix-ui/react-id/dist/index.module.js\nvar $2AODx$react = __toESM(require(\"react\"));\n\n// node_modules/@radix-ui/react-use-layout-effect/dist/index.module.js\nvar import_react18 = require(\"react\");\nvar $9f79659886946c16$export$e5c5a5f917a5871c = Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) ? import_react18.useLayoutEffect : () => {\n};\n\n// node_modules/@radix-ui/react-id/dist/index.module.js\nvar $1746a345f3d73bb7$var$useReactId = $2AODx$react[\"useId\".toString()] || (() => void 0);\nvar $1746a345f3d73bb7$var$count = 0;\nfunction $1746a345f3d73bb7$export$f680877a34711e37(deterministicId) {\n  const [id, setId] = $2AODx$react.useState($1746a345f3d73bb7$var$useReactId());\n  $9f79659886946c16$export$e5c5a5f917a5871c(() => {\n    if (!deterministicId)\n      setId(\n        (reactId) => reactId !== null && reactId !== void 0 ? reactId : String($1746a345f3d73bb7$var$count++)\n      );\n  }, [\n    deterministicId\n  ]);\n  return deterministicId || (id ? `radix-${id}` : \"\");\n}\n\n// node_modules/@radix-ui/react-popper/dist/index.module.js\nvar import_react22 = require(\"react\");\n\n// node_modules/@floating-ui/core/dist/floating-ui.core.browser.min.mjs\nfunction t2(t5) {\n  return t5.split(\"-\")[0];\n}\nfunction e2(t5) {\n  return t5.split(\"-\")[1];\n}\nfunction n(e5) {\n  return [\"top\", \"bottom\"].includes(t2(e5)) ? \"x\" : \"y\";\n}\nfunction r(t5) {\n  return \"y\" === t5 ? \"height\" : \"width\";\n}\nfunction i(i4, o5, a7) {\n  let { reference: l7, floating: s5 } = i4;\n  const c5 = l7.x + l7.width / 2 - s5.width / 2, f5 = l7.y + l7.height / 2 - s5.height / 2, u5 = n(o5), m6 = r(u5), g6 = l7[m6] / 2 - s5[m6] / 2, d6 = \"x\" === u5;\n  let p6;\n  switch (t2(o5)) {\n    case \"top\":\n      p6 = { x: c5, y: l7.y - s5.height };\n      break;\n    case \"bottom\":\n      p6 = { x: c5, y: l7.y + l7.height };\n      break;\n    case \"right\":\n      p6 = { x: l7.x + l7.width, y: f5 };\n      break;\n    case \"left\":\n      p6 = { x: l7.x - s5.width, y: f5 };\n      break;\n    default:\n      p6 = { x: l7.x, y: l7.y };\n  }\n  switch (e2(o5)) {\n    case \"start\":\n      p6[u5] -= g6 * (a7 && d6 ? -1 : 1);\n      break;\n    case \"end\":\n      p6[u5] += g6 * (a7 && d6 ? -1 : 1);\n  }\n  return p6;\n}\nvar o = async (t5, e5, n5) => {\n  const { placement: r5 = \"bottom\", strategy: o5 = \"absolute\", middleware: a7 = [], platform: l7 } = n5, s5 = await (null == l7.isRTL ? void 0 : l7.isRTL(e5));\n  let c5 = await l7.getElementRects({ reference: t5, floating: e5, strategy: o5 }), { x: f5, y: u5 } = i(c5, r5, s5), m6 = r5, g6 = {}, d6 = 0;\n  for (let n6 = 0; n6 < a7.length; n6++) {\n    const { name: p6, fn: h6 } = a7[n6], { x: y6, y: x5, data: w7, reset: v6 } = await h6({ x: f5, y: u5, initialPlacement: r5, placement: m6, strategy: o5, middlewareData: g6, rects: c5, platform: l7, elements: { reference: t5, floating: e5 } });\n    f5 = null != y6 ? y6 : f5, u5 = null != x5 ? x5 : u5, g6 = { ...g6, [p6]: { ...g6[p6], ...w7 } }, v6 && d6 <= 50 && (d6++, \"object\" == typeof v6 && (v6.placement && (m6 = v6.placement), v6.rects && (c5 = true === v6.rects ? await l7.getElementRects({ reference: t5, floating: e5, strategy: o5 }) : v6.rects), { x: f5, y: u5 } = i(c5, m6, s5)), n6 = -1);\n  }\n  return { x: f5, y: u5, placement: m6, strategy: o5, middlewareData: g6 };\n};\nfunction a3(t5) {\n  return \"number\" != typeof t5 ? function(t6) {\n    return { top: 0, right: 0, bottom: 0, left: 0, ...t6 };\n  }(t5) : { top: t5, right: t5, bottom: t5, left: t5 };\n}\nfunction l3(t5) {\n  return { ...t5, top: t5.y, left: t5.x, right: t5.x + t5.width, bottom: t5.y + t5.height };\n}\nasync function s(t5, e5) {\n  var n5;\n  void 0 === e5 && (e5 = {});\n  const { x: r5, y: i4, platform: o5, rects: s5, elements: c5, strategy: f5 } = t5, { boundary: u5 = \"clippingAncestors\", rootBoundary: m6 = \"viewport\", elementContext: g6 = \"floating\", altBoundary: d6 = false, padding: p6 = 0 } = e5, h6 = a3(p6), y6 = c5[d6 ? \"floating\" === g6 ? \"reference\" : \"floating\" : g6], x5 = l3(await o5.getClippingRect({ element: null == (n5 = await (null == o5.isElement ? void 0 : o5.isElement(y6))) || n5 ? y6 : y6.contextElement || await (null == o5.getDocumentElement ? void 0 : o5.getDocumentElement(c5.floating)), boundary: u5, rootBoundary: m6, strategy: f5 })), w7 = l3(o5.convertOffsetParentRelativeRectToViewportRelativeRect ? await o5.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: \"floating\" === g6 ? { ...s5.floating, x: r5, y: i4 } : s5.reference, offsetParent: await (null == o5.getOffsetParent ? void 0 : o5.getOffsetParent(c5.floating)), strategy: f5 }) : s5[g6]);\n  return { top: x5.top - w7.top + h6.top, bottom: w7.bottom - x5.bottom + h6.bottom, left: x5.left - w7.left + h6.left, right: w7.right - x5.right + h6.right };\n}\nvar c = Math.min;\nvar f = Math.max;\nfunction u(t5, e5, n5) {\n  return f(t5, c(e5, n5));\n}\nvar m2 = (t5) => ({ name: \"arrow\", options: t5, async fn(i4) {\n  const { element: o5, padding: l7 = 0 } = null != t5 ? t5 : {}, { x: s5, y: c5, placement: f5, rects: m6, platform: g6 } = i4;\n  if (null == o5)\n    return {};\n  const d6 = a3(l7), p6 = { x: s5, y: c5 }, h6 = n(f5), y6 = e2(f5), x5 = r(h6), w7 = await g6.getDimensions(o5), v6 = \"y\" === h6 ? \"top\" : \"left\", b6 = \"y\" === h6 ? \"bottom\" : \"right\", R7 = m6.reference[x5] + m6.reference[h6] - p6[h6] - m6.floating[x5], A5 = p6[h6] - m6.reference[h6], P4 = await (null == g6.getOffsetParent ? void 0 : g6.getOffsetParent(o5));\n  let T5 = P4 ? \"y\" === h6 ? P4.clientHeight || 0 : P4.clientWidth || 0 : 0;\n  0 === T5 && (T5 = m6.floating[x5]);\n  const O5 = R7 / 2 - A5 / 2, D6 = d6[v6], L5 = T5 - w7[x5] - d6[b6], k6 = T5 / 2 - w7[x5] / 2 + O5, E6 = u(D6, k6, L5), C6 = (\"start\" === y6 ? d6[v6] : d6[b6]) > 0 && k6 !== E6 && m6.reference[x5] <= m6.floating[x5];\n  return { [h6]: p6[h6] - (C6 ? k6 < D6 ? D6 - k6 : L5 - k6 : 0), data: { [h6]: E6, centerOffset: k6 - E6 } };\n} });\nvar g3 = { left: \"right\", right: \"left\", bottom: \"top\", top: \"bottom\" };\nfunction d2(t5) {\n  return t5.replace(/left|right|bottom|top/g, (t6) => g3[t6]);\n}\nfunction p2(t5, i4, o5) {\n  void 0 === o5 && (o5 = false);\n  const a7 = e2(t5), l7 = n(t5), s5 = r(l7);\n  let c5 = \"x\" === l7 ? a7 === (o5 ? \"end\" : \"start\") ? \"right\" : \"left\" : \"start\" === a7 ? \"bottom\" : \"top\";\n  return i4.reference[s5] > i4.floating[s5] && (c5 = d2(c5)), { main: c5, cross: d2(c5) };\n}\nvar h2 = { start: \"end\", end: \"start\" };\nfunction y2(t5) {\n  return t5.replace(/start|end/g, (t6) => h2[t6]);\n}\nvar x2 = [\"top\", \"right\", \"bottom\", \"left\"];\nvar w3 = x2.reduce((t5, e5) => t5.concat(e5, e5 + \"-start\", e5 + \"-end\"), []);\nvar b2 = function(e5) {\n  return void 0 === e5 && (e5 = {}), { name: \"flip\", options: e5, async fn(n5) {\n    var r5;\n    const { placement: i4, middlewareData: o5, rects: a7, initialPlacement: l7, platform: c5, elements: f5 } = n5, { mainAxis: u5 = true, crossAxis: m6 = true, fallbackPlacements: g6, fallbackStrategy: h6 = \"bestFit\", flipAlignment: x5 = true, ...w7 } = e5, v6 = t2(i4), b6 = g6 || (v6 === l7 || !x5 ? [d2(l7)] : function(t5) {\n      const e6 = d2(t5);\n      return [y2(t5), e6, y2(e6)];\n    }(l7)), R7 = [l7, ...b6], A5 = await s(n5, w7), P4 = [];\n    let T5 = (null == (r5 = o5.flip) ? void 0 : r5.overflows) || [];\n    if (u5 && P4.push(A5[v6]), m6) {\n      const { main: t5, cross: e6 } = p2(i4, a7, await (null == c5.isRTL ? void 0 : c5.isRTL(f5.floating)));\n      P4.push(A5[t5], A5[e6]);\n    }\n    if (T5 = [...T5, { placement: i4, overflows: P4 }], !P4.every((t5) => t5 <= 0)) {\n      var O5, D6;\n      const t5 = (null != (O5 = null == (D6 = o5.flip) ? void 0 : D6.index) ? O5 : 0) + 1, e6 = R7[t5];\n      if (e6)\n        return { data: { index: t5, overflows: T5 }, reset: { placement: e6 } };\n      let n6 = \"bottom\";\n      switch (h6) {\n        case \"bestFit\": {\n          var L5;\n          const t6 = null == (L5 = T5.map((t7) => [t7, t7.overflows.filter((t8) => t8 > 0).reduce((t8, e7) => t8 + e7, 0)]).sort((t7, e7) => t7[1] - e7[1])[0]) ? void 0 : L5[0].placement;\n          t6 && (n6 = t6);\n          break;\n        }\n        case \"initialPlacement\":\n          n6 = l7;\n      }\n      if (i4 !== n6)\n        return { reset: { placement: n6 } };\n    }\n    return {};\n  } };\n};\nfunction R4(t5, e5) {\n  return { top: t5.top - e5.height, right: t5.right - e5.width, bottom: t5.bottom - e5.height, left: t5.left - e5.width };\n}\nfunction A3(t5) {\n  return x2.some((e5) => t5[e5] >= 0);\n}\nvar P = function(t5) {\n  let { strategy: e5 = \"referenceHidden\", ...n5 } = void 0 === t5 ? {} : t5;\n  return { name: \"hide\", async fn(t6) {\n    const { rects: r5 } = t6;\n    switch (e5) {\n      case \"referenceHidden\": {\n        const e6 = R4(await s(t6, { ...n5, elementContext: \"reference\" }), r5.reference);\n        return { data: { referenceHiddenOffsets: e6, referenceHidden: A3(e6) } };\n      }\n      case \"escaped\": {\n        const e6 = R4(await s(t6, { ...n5, altBoundary: true }), r5.floating);\n        return { data: { escapedOffsets: e6, escaped: A3(e6) } };\n      }\n      default:\n        return {};\n    }\n  } };\n};\nvar T2 = function(r5) {\n  return void 0 === r5 && (r5 = 0), { name: \"offset\", options: r5, async fn(i4) {\n    const { x: o5, y: a7 } = i4, l7 = await async function(r6, i5) {\n      const { placement: o6, platform: a8, elements: l8 } = r6, s5 = await (null == a8.isRTL ? void 0 : a8.isRTL(l8.floating)), c5 = t2(o6), f5 = e2(o6), u5 = \"x\" === n(o6), m6 = [\"left\", \"top\"].includes(c5) ? -1 : 1, g6 = s5 && u5 ? -1 : 1, d6 = \"function\" == typeof i5 ? i5(r6) : i5;\n      let { mainAxis: p6, crossAxis: h6, alignmentAxis: y6 } = \"number\" == typeof d6 ? { mainAxis: d6, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...d6 };\n      return f5 && \"number\" == typeof y6 && (h6 = \"end\" === f5 ? -1 * y6 : y6), u5 ? { x: h6 * g6, y: p6 * m6 } : { x: p6 * m6, y: h6 * g6 };\n    }(i4, r5);\n    return { x: o5 + l7.x, y: a7 + l7.y, data: l7 };\n  } };\n};\nfunction O3(t5) {\n  return \"x\" === t5 ? \"y\" : \"x\";\n}\nvar D3 = function(e5) {\n  return void 0 === e5 && (e5 = {}), { name: \"shift\", options: e5, async fn(r5) {\n    const { x: i4, y: o5, placement: a7 } = r5, { mainAxis: l7 = true, crossAxis: c5 = false, limiter: f5 = { fn: (t5) => {\n      let { x: e6, y: n5 } = t5;\n      return { x: e6, y: n5 };\n    } }, ...m6 } = e5, g6 = { x: i4, y: o5 }, d6 = await s(r5, m6), p6 = n(t2(a7)), h6 = O3(p6);\n    let y6 = g6[p6], x5 = g6[h6];\n    if (l7) {\n      const t5 = \"y\" === p6 ? \"bottom\" : \"right\";\n      y6 = u(y6 + d6[\"y\" === p6 ? \"top\" : \"left\"], y6, y6 - d6[t5]);\n    }\n    if (c5) {\n      const t5 = \"y\" === h6 ? \"bottom\" : \"right\";\n      x5 = u(x5 + d6[\"y\" === h6 ? \"top\" : \"left\"], x5, x5 - d6[t5]);\n    }\n    const w7 = f5.fn({ ...r5, [p6]: y6, [h6]: x5 });\n    return { ...w7, data: { x: w7.x - i4, y: w7.y - o5 } };\n  } };\n};\nvar L2 = function(e5) {\n  return void 0 === e5 && (e5 = {}), { options: e5, fn(r5) {\n    const { x: i4, y: o5, placement: a7, rects: l7, middlewareData: s5 } = r5, { offset: c5 = 0, mainAxis: f5 = true, crossAxis: u5 = true } = e5, m6 = { x: i4, y: o5 }, g6 = n(a7), d6 = O3(g6);\n    let p6 = m6[g6], h6 = m6[d6];\n    const y6 = \"function\" == typeof c5 ? c5({ ...l7, placement: a7 }) : c5, x5 = \"number\" == typeof y6 ? { mainAxis: y6, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...y6 };\n    if (f5) {\n      const t5 = \"y\" === g6 ? \"height\" : \"width\", e6 = l7.reference[g6] - l7.floating[t5] + x5.mainAxis, n5 = l7.reference[g6] + l7.reference[t5] - x5.mainAxis;\n      p6 < e6 ? p6 = e6 : p6 > n5 && (p6 = n5);\n    }\n    if (u5) {\n      var w7, v6, b6, R7;\n      const e6 = \"y\" === g6 ? \"width\" : \"height\", n5 = [\"top\", \"left\"].includes(t2(a7)), r6 = l7.reference[d6] - l7.floating[e6] + (n5 && null != (w7 = null == (v6 = s5.offset) ? void 0 : v6[d6]) ? w7 : 0) + (n5 ? 0 : x5.crossAxis), i5 = l7.reference[d6] + l7.reference[e6] + (n5 ? 0 : null != (b6 = null == (R7 = s5.offset) ? void 0 : R7[d6]) ? b6 : 0) - (n5 ? x5.crossAxis : 0);\n      h6 < r6 ? h6 = r6 : h6 > i5 && (h6 = i5);\n    }\n    return { [g6]: p6, [d6]: h6 };\n  } };\n};\n\n// node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.min.mjs\nfunction n2(t5) {\n  return t5 && t5.document && t5.location && t5.alert && t5.setInterval;\n}\nfunction o2(t5) {\n  if (null == t5)\n    return window;\n  if (!n2(t5)) {\n    const e5 = t5.ownerDocument;\n    return e5 && e5.defaultView || window;\n  }\n  return t5;\n}\nfunction i2(t5) {\n  return o2(t5).getComputedStyle(t5);\n}\nfunction r2(t5) {\n  return n2(t5) ? \"\" : t5 ? (t5.nodeName || \"\").toLowerCase() : \"\";\n}\nfunction l4() {\n  const t5 = navigator.userAgentData;\n  return null != t5 && t5.brands ? t5.brands.map((t6) => t6.brand + \"/\" + t6.version).join(\" \") : navigator.userAgent;\n}\nfunction c2(t5) {\n  return t5 instanceof o2(t5).HTMLElement;\n}\nfunction f2(t5) {\n  return t5 instanceof o2(t5).Element;\n}\nfunction s2(t5) {\n  if (\"undefined\" == typeof ShadowRoot)\n    return false;\n  return t5 instanceof o2(t5).ShadowRoot || t5 instanceof ShadowRoot;\n}\nfunction u2(t5) {\n  const { overflow: e5, overflowX: n5, overflowY: o5 } = i2(t5);\n  return /auto|scroll|overlay|hidden/.test(e5 + o5 + n5);\n}\nfunction d3(t5) {\n  return [\"table\", \"td\", \"th\"].includes(r2(t5));\n}\nfunction h3(t5) {\n  const e5 = /firefox/i.test(l4()), n5 = i2(t5);\n  return \"none\" !== n5.transform || \"none\" !== n5.perspective || \"paint\" === n5.contain || [\"transform\", \"perspective\"].includes(n5.willChange) || e5 && \"filter\" === n5.willChange || e5 && !!n5.filter && \"none\" !== n5.filter;\n}\nfunction a4() {\n  return !/^((?!chrome|android).)*safari/i.test(l4());\n}\nvar g4 = Math.min;\nvar p3 = Math.max;\nvar m3 = Math.round;\nfunction w4(t5, e5, n5) {\n  var i4, r5, l7, s5;\n  void 0 === e5 && (e5 = false), void 0 === n5 && (n5 = false);\n  const u5 = t5.getBoundingClientRect();\n  let d6 = 1, h6 = 1;\n  e5 && c2(t5) && (d6 = t5.offsetWidth > 0 && m3(u5.width) / t5.offsetWidth || 1, h6 = t5.offsetHeight > 0 && m3(u5.height) / t5.offsetHeight || 1);\n  const g6 = f2(t5) ? o2(t5) : window, p6 = !a4() && n5, w7 = (u5.left + (p6 && null != (i4 = null == (r5 = g6.visualViewport) ? void 0 : r5.offsetLeft) ? i4 : 0)) / d6, v6 = (u5.top + (p6 && null != (l7 = null == (s5 = g6.visualViewport) ? void 0 : s5.offsetTop) ? l7 : 0)) / h6, y6 = u5.width / d6, x5 = u5.height / h6;\n  return { width: y6, height: x5, top: v6, right: w7 + y6, bottom: v6 + x5, left: w7, x: w7, y: v6 };\n}\nfunction v3(t5) {\n  return (e5 = t5, (e5 instanceof o2(e5).Node ? t5.ownerDocument : t5.document) || window.document).documentElement;\n  var e5;\n}\nfunction y3(t5) {\n  return f2(t5) ? { scrollLeft: t5.scrollLeft, scrollTop: t5.scrollTop } : { scrollLeft: t5.pageXOffset, scrollTop: t5.pageYOffset };\n}\nfunction x3(t5) {\n  return w4(v3(t5)).left + y3(t5).scrollLeft;\n}\nfunction b3(t5, e5, n5) {\n  const o5 = c2(e5), i4 = v3(e5), l7 = w4(t5, o5 && function(t6) {\n    const e6 = w4(t6);\n    return m3(e6.width) !== t6.offsetWidth || m3(e6.height) !== t6.offsetHeight;\n  }(e5), \"fixed\" === n5);\n  let f5 = { scrollLeft: 0, scrollTop: 0 };\n  const s5 = { x: 0, y: 0 };\n  if (o5 || !o5 && \"fixed\" !== n5)\n    if ((\"body\" !== r2(e5) || u2(i4)) && (f5 = y3(e5)), c2(e5)) {\n      const t6 = w4(e5, true);\n      s5.x = t6.x + e5.clientLeft, s5.y = t6.y + e5.clientTop;\n    } else\n      i4 && (s5.x = x3(i4));\n  return { x: l7.left + f5.scrollLeft - s5.x, y: l7.top + f5.scrollTop - s5.y, width: l7.width, height: l7.height };\n}\nfunction L3(t5) {\n  return \"html\" === r2(t5) ? t5 : t5.assignedSlot || t5.parentNode || (s2(t5) ? t5.host : null) || v3(t5);\n}\nfunction R5(t5) {\n  return c2(t5) && \"fixed\" !== getComputedStyle(t5).position ? t5.offsetParent : null;\n}\nfunction T3(t5) {\n  const e5 = o2(t5);\n  let n5 = R5(t5);\n  for (; n5 && d3(n5) && \"static\" === getComputedStyle(n5).position; )\n    n5 = R5(n5);\n  return n5 && (\"html\" === r2(n5) || \"body\" === r2(n5) && \"static\" === getComputedStyle(n5).position && !h3(n5)) ? e5 : n5 || function(t6) {\n    let e6 = L3(t6);\n    for (s2(e6) && (e6 = e6.host); c2(e6) && ![\"html\", \"body\"].includes(r2(e6)); ) {\n      if (h3(e6))\n        return e6;\n      e6 = e6.parentNode;\n    }\n    return null;\n  }(t5) || e5;\n}\nfunction W3(t5) {\n  if (c2(t5))\n    return { width: t5.offsetWidth, height: t5.offsetHeight };\n  const e5 = w4(t5);\n  return { width: e5.width, height: e5.height };\n}\nfunction E4(t5) {\n  const e5 = L3(t5);\n  return [\"html\", \"body\", \"#document\"].includes(r2(e5)) ? t5.ownerDocument.body : c2(e5) && u2(e5) ? e5 : E4(e5);\n}\nfunction H3(t5, e5) {\n  var n5;\n  void 0 === e5 && (e5 = []);\n  const i4 = E4(t5), r5 = i4 === (null == (n5 = t5.ownerDocument) ? void 0 : n5.body), l7 = o2(i4), c5 = r5 ? [l7].concat(l7.visualViewport || [], u2(i4) ? i4 : []) : i4, f5 = e5.concat(c5);\n  return r5 ? f5 : f5.concat(H3(c5));\n}\nfunction C4(e5, n5, r5) {\n  return \"viewport\" === n5 ? l3(function(t5, e6) {\n    const n6 = o2(t5), i4 = v3(t5), r6 = n6.visualViewport;\n    let l7 = i4.clientWidth, c5 = i4.clientHeight, f5 = 0, s5 = 0;\n    if (r6) {\n      l7 = r6.width, c5 = r6.height;\n      const t6 = a4();\n      (t6 || !t6 && \"fixed\" === e6) && (f5 = r6.offsetLeft, s5 = r6.offsetTop);\n    }\n    return { width: l7, height: c5, x: f5, y: s5 };\n  }(e5, r5)) : f2(n5) ? function(t5, e6) {\n    const n6 = w4(t5, false, \"fixed\" === e6), o5 = n6.top + t5.clientTop, i4 = n6.left + t5.clientLeft;\n    return { top: o5, left: i4, x: i4, y: o5, right: i4 + t5.clientWidth, bottom: o5 + t5.clientHeight, width: t5.clientWidth, height: t5.clientHeight };\n  }(n5, r5) : l3(function(t5) {\n    var e6;\n    const n6 = v3(t5), o5 = y3(t5), r6 = null == (e6 = t5.ownerDocument) ? void 0 : e6.body, l7 = p3(n6.scrollWidth, n6.clientWidth, r6 ? r6.scrollWidth : 0, r6 ? r6.clientWidth : 0), c5 = p3(n6.scrollHeight, n6.clientHeight, r6 ? r6.scrollHeight : 0, r6 ? r6.clientHeight : 0);\n    let f5 = -o5.scrollLeft + x3(t5);\n    const s5 = -o5.scrollTop;\n    return \"rtl\" === i2(r6 || n6).direction && (f5 += p3(n6.clientWidth, r6 ? r6.clientWidth : 0) - l7), { width: l7, height: c5, x: f5, y: s5 };\n  }(v3(e5)));\n}\nfunction S2(t5) {\n  const e5 = H3(t5), n5 = [\"absolute\", \"fixed\"].includes(i2(t5).position) && c2(t5) ? T3(t5) : t5;\n  return f2(n5) ? e5.filter((t6) => f2(t6) && function(t7, e6) {\n    const n6 = null == e6.getRootNode ? void 0 : e6.getRootNode();\n    if (t7.contains(e6))\n      return true;\n    if (n6 && s2(n6)) {\n      let n7 = e6;\n      do {\n        if (n7 && t7 === n7)\n          return true;\n        n7 = n7.parentNode || n7.host;\n      } while (n7);\n    }\n    return false;\n  }(t6, n5) && \"body\" !== r2(t6)) : [];\n}\nvar D4 = { getClippingRect: function(t5) {\n  let { element: e5, boundary: n5, rootBoundary: o5, strategy: i4 } = t5;\n  const r5 = [...\"clippingAncestors\" === n5 ? S2(e5) : [].concat(n5), o5], l7 = r5[0], c5 = r5.reduce((t6, n6) => {\n    const o6 = C4(e5, n6, i4);\n    return t6.top = p3(o6.top, t6.top), t6.right = g4(o6.right, t6.right), t6.bottom = g4(o6.bottom, t6.bottom), t6.left = p3(o6.left, t6.left), t6;\n  }, C4(e5, l7, i4));\n  return { width: c5.right - c5.left, height: c5.bottom - c5.top, x: c5.left, y: c5.top };\n}, convertOffsetParentRelativeRectToViewportRelativeRect: function(t5) {\n  let { rect: e5, offsetParent: n5, strategy: o5 } = t5;\n  const i4 = c2(n5), l7 = v3(n5);\n  if (n5 === l7)\n    return e5;\n  let f5 = { scrollLeft: 0, scrollTop: 0 };\n  const s5 = { x: 0, y: 0 };\n  if ((i4 || !i4 && \"fixed\" !== o5) && ((\"body\" !== r2(n5) || u2(l7)) && (f5 = y3(n5)), c2(n5))) {\n    const t6 = w4(n5, true);\n    s5.x = t6.x + n5.clientLeft, s5.y = t6.y + n5.clientTop;\n  }\n  return { ...e5, x: e5.x - f5.scrollLeft + s5.x, y: e5.y - f5.scrollTop + s5.y };\n}, isElement: f2, getDimensions: W3, getOffsetParent: T3, getDocumentElement: v3, getElementRects: (t5) => {\n  let { reference: e5, floating: n5, strategy: o5 } = t5;\n  return { reference: b3(e5, T3(n5), o5), floating: { ...W3(n5), x: 0, y: 0 } };\n}, getClientRects: (t5) => Array.from(t5.getClientRects()), isRTL: (t5) => \"rtl\" === i2(t5).direction };\nfunction N3(t5, e5, n5, o5) {\n  void 0 === o5 && (o5 = {});\n  const { ancestorScroll: i4 = true, ancestorResize: r5 = true, elementResize: l7 = true, animationFrame: c5 = false } = o5, s5 = i4 && !c5, u5 = r5 && !c5, d6 = s5 || u5 ? [...f2(t5) ? H3(t5) : [], ...H3(e5)] : [];\n  d6.forEach((t6) => {\n    s5 && t6.addEventListener(\"scroll\", n5, { passive: true }), u5 && t6.addEventListener(\"resize\", n5);\n  });\n  let h6, a7 = null;\n  if (l7) {\n    let o6 = true;\n    a7 = new ResizeObserver(() => {\n      o6 || n5(), o6 = false;\n    }), f2(t5) && !c5 && a7.observe(t5), a7.observe(e5);\n  }\n  let g6 = c5 ? w4(t5) : null;\n  return c5 && function e6() {\n    const o6 = w4(t5);\n    !g6 || o6.x === g6.x && o6.y === g6.y && o6.width === g6.width && o6.height === g6.height || n5();\n    g6 = o6, h6 = requestAnimationFrame(e6);\n  }(), n5(), () => {\n    var t6;\n    d6.forEach((t7) => {\n      s5 && t7.removeEventListener(\"scroll\", n5), u5 && t7.removeEventListener(\"resize\", n5);\n    }), null == (t6 = a7) || t6.disconnect(), a7 = null, c5 && cancelAnimationFrame(h6);\n  };\n}\nvar z3 = (t5, n5, o5) => o(t5, n5, { platform: D4, ...o5 });\n\n// node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js\nvar React2 = __toESM(require(\"react\"));\nvar import_react19 = require(\"react\");\nvar ReactDOM = __toESM(require(\"react-dom\"));\nvar index = typeof document !== \"undefined\" ? import_react19.useLayoutEffect : import_react19.useEffect;\nfunction deepEqual(a7, b6) {\n  if (a7 === b6) {\n    return true;\n  }\n  if (typeof a7 !== typeof b6) {\n    return false;\n  }\n  if (typeof a7 === \"function\" && a7.toString() === b6.toString()) {\n    return true;\n  }\n  let length, i4, keys;\n  if (a7 && b6 && typeof a7 == \"object\") {\n    if (Array.isArray(a7)) {\n      length = a7.length;\n      if (length != b6.length)\n        return false;\n      for (i4 = length; i4-- !== 0; ) {\n        if (!deepEqual(a7[i4], b6[i4])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    keys = Object.keys(a7);\n    length = keys.length;\n    if (length !== Object.keys(b6).length) {\n      return false;\n    }\n    for (i4 = length; i4-- !== 0; ) {\n      if (!Object.prototype.hasOwnProperty.call(b6, keys[i4])) {\n        return false;\n      }\n    }\n    for (i4 = length; i4-- !== 0; ) {\n      const key = keys[i4];\n      if (key === \"_owner\" && a7.$$typeof) {\n        continue;\n      }\n      if (!deepEqual(a7[key], b6[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return a7 !== a7 && b6 !== b6;\n}\nfunction useLatestRef(value) {\n  const ref = React2.useRef(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\nfunction useFloating(_temp) {\n  let {\n    middleware,\n    placement = \"bottom\",\n    strategy = \"absolute\",\n    whileElementsMounted\n  } = _temp === void 0 ? {} : _temp;\n  const reference = React2.useRef(null);\n  const floating = React2.useRef(null);\n  const whileElementsMountedRef = useLatestRef(whileElementsMounted);\n  const cleanupRef = React2.useRef(null);\n  const [data, setData] = React2.useState({\n    x: null,\n    y: null,\n    strategy,\n    placement,\n    middlewareData: {}\n  });\n  const [latestMiddleware, setLatestMiddleware] = React2.useState(middleware);\n  if (!deepEqual(latestMiddleware == null ? void 0 : latestMiddleware.map((_ref) => {\n    let {\n      options\n    } = _ref;\n    return options;\n  }), middleware == null ? void 0 : middleware.map((_ref2) => {\n    let {\n      options\n    } = _ref2;\n    return options;\n  }))) {\n    setLatestMiddleware(middleware);\n  }\n  const update = React2.useCallback(() => {\n    if (!reference.current || !floating.current) {\n      return;\n    }\n    z3(reference.current, floating.current, {\n      middleware: latestMiddleware,\n      placement,\n      strategy\n    }).then((data2) => {\n      if (isMountedRef.current) {\n        ReactDOM.flushSync(() => {\n          setData(data2);\n        });\n      }\n    });\n  }, [latestMiddleware, placement, strategy]);\n  index(() => {\n    if (isMountedRef.current) {\n      update();\n    }\n  }, [update]);\n  const isMountedRef = React2.useRef(false);\n  index(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n  const runElementMountCallback = React2.useCallback(() => {\n    if (typeof cleanupRef.current === \"function\") {\n      cleanupRef.current();\n      cleanupRef.current = null;\n    }\n    if (reference.current && floating.current) {\n      if (whileElementsMountedRef.current) {\n        const cleanupFn = whileElementsMountedRef.current(reference.current, floating.current, update);\n        cleanupRef.current = cleanupFn;\n      } else {\n        update();\n      }\n    }\n  }, [update, whileElementsMountedRef]);\n  const setReference = React2.useCallback((node) => {\n    reference.current = node;\n    runElementMountCallback();\n  }, [runElementMountCallback]);\n  const setFloating = React2.useCallback((node) => {\n    floating.current = node;\n    runElementMountCallback();\n  }, [runElementMountCallback]);\n  const refs = React2.useMemo(() => ({\n    reference,\n    floating\n  }), []);\n  return React2.useMemo(() => ({\n    ...data,\n    update,\n    refs,\n    reference: setReference,\n    floating: setFloating\n  }), [data, update, refs, setReference, setFloating]);\n}\nvar arrow = (options) => {\n  const {\n    element,\n    padding\n  } = options;\n  function isRef(value) {\n    return Object.prototype.hasOwnProperty.call(value, \"current\");\n  }\n  return {\n    name: \"arrow\",\n    options,\n    fn(args) {\n      if (isRef(element)) {\n        if (element.current != null) {\n          return m2({\n            element: element.current,\n            padding\n          }).fn(args);\n        }\n        return {};\n      } else if (element) {\n        return m2({\n          element,\n          padding\n        }).fn(args);\n      }\n      return {};\n    }\n  };\n};\n\n// node_modules/@radix-ui/react-arrow/dist/index.module.js\nvar import_react20 = require(\"react\");\nvar $7e8f5cd07187803e$export$21b07c8f274aebd5 = /* @__PURE__ */ (0, import_react20.forwardRef)((props, forwardedRef) => {\n  const { children, width = 10, height = 5, ...arrowProps } = props;\n  return /* @__PURE__ */ (0, import_react20.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.svg, _extends({}, arrowProps, {\n    ref: forwardedRef,\n    width,\n    height,\n    viewBox: \"0 0 30 10\",\n    preserveAspectRatio: \"none\"\n  }), props.asChild ? children : /* @__PURE__ */ (0, import_react20.createElement)(\"polygon\", {\n    points: \"0,0 30,0 15,10\"\n  }));\n});\nvar $7e8f5cd07187803e$export$be92b6f5f03c0fe9 = $7e8f5cd07187803e$export$21b07c8f274aebd5;\n\n// node_modules/@radix-ui/react-use-size/dist/index.module.js\nvar import_react21 = require(\"react\");\nfunction $db6c3485150b8e66$export$1ab7ae714698c4b8(element) {\n  const [size, setSize] = (0, import_react21.useState)(void 0);\n  $9f79659886946c16$export$e5c5a5f917a5871c(() => {\n    if (element) {\n      setSize({\n        width: element.offsetWidth,\n        height: element.offsetHeight\n      });\n      const resizeObserver = new ResizeObserver((entries) => {\n        if (!Array.isArray(entries))\n          return;\n        if (!entries.length)\n          return;\n        const entry = entries[0];\n        let width;\n        let height;\n        if (\"borderBoxSize\" in entry) {\n          const borderSizeEntry = entry[\"borderBoxSize\"];\n          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;\n          width = borderSize[\"inlineSize\"];\n          height = borderSize[\"blockSize\"];\n        } else {\n          width = element.offsetWidth;\n          height = element.offsetHeight;\n        }\n        setSize({\n          width,\n          height\n        });\n      });\n      resizeObserver.observe(element, {\n        box: \"border-box\"\n      });\n      return () => resizeObserver.unobserve(element);\n    } else\n      setSize(void 0);\n  }, [\n    element\n  ]);\n  return size;\n}\n\n// node_modules/@radix-ui/react-popper/dist/index.module.js\nvar $cf1ac5d9fe0e8206$var$POPPER_NAME = \"Popper\";\nvar [$cf1ac5d9fe0e8206$var$createPopperContext, $cf1ac5d9fe0e8206$export$722aac194ae923] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($cf1ac5d9fe0e8206$var$POPPER_NAME);\nvar [$cf1ac5d9fe0e8206$var$PopperProvider, $cf1ac5d9fe0e8206$var$usePopperContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$POPPER_NAME);\nvar $cf1ac5d9fe0e8206$export$badac9ada3a0bdf9 = (props) => {\n  const { __scopePopper, children } = props;\n  const [anchor, setAnchor] = (0, import_react22.useState)(null);\n  return /* @__PURE__ */ (0, import_react22.createElement)($cf1ac5d9fe0e8206$var$PopperProvider, {\n    scope: __scopePopper,\n    anchor,\n    onAnchorChange: setAnchor\n  }, children);\n};\nvar $cf1ac5d9fe0e8206$var$ANCHOR_NAME = \"PopperAnchor\";\nvar $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d = /* @__PURE__ */ (0, import_react22.forwardRef)((props, forwardedRef) => {\n  const { __scopePopper, virtualRef, ...anchorProps } = props;\n  const context = $cf1ac5d9fe0e8206$var$usePopperContext($cf1ac5d9fe0e8206$var$ANCHOR_NAME, __scopePopper);\n  const ref = (0, import_react22.useRef)(null);\n  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);\n  (0, import_react22.useEffect)(() => {\n    context.onAnchorChange((virtualRef === null || virtualRef === void 0 ? void 0 : virtualRef.current) || ref.current);\n  });\n  return virtualRef ? null : /* @__PURE__ */ (0, import_react22.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, anchorProps, {\n    ref: composedRefs\n  }));\n});\nvar $cf1ac5d9fe0e8206$var$CONTENT_NAME = \"PopperContent\";\nvar [$cf1ac5d9fe0e8206$var$PopperContentProvider, $cf1ac5d9fe0e8206$var$useContentContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME);\nvar [$cf1ac5d9fe0e8206$var$PositionContextProvider, $cf1ac5d9fe0e8206$var$usePositionContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME, {\n  hasParent: false,\n  positionUpdateFns: /* @__PURE__ */ new Set()\n});\nvar $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc = /* @__PURE__ */ (0, import_react22.forwardRef)((props, forwardedRef) => {\n  var _arrowSize$width, _arrowSize$height, _middlewareData$arrow, _middlewareData$arrow2, _middlewareData$arrow3, _middlewareData$hide, _middlewareData$trans, _middlewareData$trans2;\n  const { __scopePopper, side = \"bottom\", sideOffset = 0, align = \"center\", alignOffset = 0, arrowPadding = 0, collisionBoundary = [], collisionPadding: collisionPaddingProp = 0, sticky = \"partial\", hideWhenDetached = false, avoidCollisions = true, ...contentProps } = props;\n  const context = $cf1ac5d9fe0e8206$var$usePopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME, __scopePopper);\n  const [content, setContent] = (0, import_react22.useState)(null);\n  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(\n    forwardedRef,\n    (node) => setContent(node)\n  );\n  const [arrow2, setArrow] = (0, import_react22.useState)(null);\n  const arrowSize = $db6c3485150b8e66$export$1ab7ae714698c4b8(arrow2);\n  const arrowWidth = (_arrowSize$width = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.width) !== null && _arrowSize$width !== void 0 ? _arrowSize$width : 0;\n  const arrowHeight = (_arrowSize$height = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.height) !== null && _arrowSize$height !== void 0 ? _arrowSize$height : 0;\n  const desiredPlacement = side + (align !== \"center\" ? \"-\" + align : \"\");\n  const collisionPadding = typeof collisionPaddingProp === \"number\" ? collisionPaddingProp : {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...collisionPaddingProp\n  };\n  const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [\n    collisionBoundary\n  ];\n  const hasExplicitBoundaries = boundary.length > 0;\n  const detectOverflowOptions = {\n    padding: collisionPadding,\n    boundary: boundary.filter($cf1ac5d9fe0e8206$var$isNotNull),\n    altBoundary: hasExplicitBoundaries\n  };\n  const { reference, floating, strategy, x: x5, y: y6, placement, middlewareData, update } = useFloating({\n    strategy: \"fixed\",\n    placement: desiredPlacement,\n    whileElementsMounted: N3,\n    middleware: [\n      T2({\n        mainAxis: sideOffset + arrowHeight,\n        alignmentAxis: alignOffset\n      }),\n      avoidCollisions ? D3({\n        mainAxis: true,\n        crossAxis: false,\n        limiter: sticky === \"partial\" ? L2() : void 0,\n        ...detectOverflowOptions\n      }) : void 0,\n      arrow2 ? arrow({\n        element: arrow2,\n        padding: arrowPadding\n      }) : void 0,\n      avoidCollisions ? b2({\n        ...detectOverflowOptions\n      }) : void 0,\n      $cf1ac5d9fe0e8206$var$transformOrigin({\n        arrowWidth,\n        arrowHeight\n      }),\n      hideWhenDetached ? P({\n        strategy: \"referenceHidden\"\n      }) : void 0\n    ].filter($cf1ac5d9fe0e8206$var$isDefined)\n  });\n  $9f79659886946c16$export$e5c5a5f917a5871c(() => {\n    reference(context.anchor);\n  }, [\n    reference,\n    context.anchor\n  ]);\n  const isPlaced = x5 !== null && y6 !== null;\n  const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement);\n  const arrowX = (_middlewareData$arrow = middlewareData.arrow) === null || _middlewareData$arrow === void 0 ? void 0 : _middlewareData$arrow.x;\n  const arrowY = (_middlewareData$arrow2 = middlewareData.arrow) === null || _middlewareData$arrow2 === void 0 ? void 0 : _middlewareData$arrow2.y;\n  const cannotCenterArrow = ((_middlewareData$arrow3 = middlewareData.arrow) === null || _middlewareData$arrow3 === void 0 ? void 0 : _middlewareData$arrow3.centerOffset) !== 0;\n  const [contentZIndex, setContentZIndex] = (0, import_react22.useState)();\n  $9f79659886946c16$export$e5c5a5f917a5871c(() => {\n    if (content)\n      setContentZIndex(window.getComputedStyle(content).zIndex);\n  }, [\n    content\n  ]);\n  const { hasParent, positionUpdateFns } = $cf1ac5d9fe0e8206$var$usePositionContext($cf1ac5d9fe0e8206$var$CONTENT_NAME, __scopePopper);\n  const isRoot = !hasParent;\n  (0, import_react22.useLayoutEffect)(() => {\n    if (!isRoot) {\n      positionUpdateFns.add(update);\n      return () => {\n        positionUpdateFns.delete(update);\n      };\n    }\n  }, [\n    isRoot,\n    positionUpdateFns,\n    update\n  ]);\n  (0, import_react22.useLayoutEffect)(() => {\n    if (isRoot && isPlaced)\n      Array.from(positionUpdateFns).reverse().forEach(\n        (fn2) => requestAnimationFrame(fn2)\n      );\n  }, [\n    isRoot,\n    isPlaced,\n    positionUpdateFns\n  ]);\n  const commonProps = {\n    \"data-side\": placedSide,\n    \"data-align\": placedAlign,\n    ...contentProps,\n    ref: composedRefs,\n    style: {\n      ...contentProps.style,\n      animation: !isPlaced ? \"none\" : void 0,\n      opacity: (_middlewareData$hide = middlewareData.hide) !== null && _middlewareData$hide !== void 0 && _middlewareData$hide.referenceHidden ? 0 : void 0\n    }\n  };\n  return /* @__PURE__ */ (0, import_react22.createElement)(\"div\", {\n    ref: floating,\n    \"data-radix-popper-content-wrapper\": \"\",\n    style: {\n      position: strategy,\n      left: 0,\n      top: 0,\n      transform: isPlaced ? `translate3d(${Math.round(x5)}px, ${Math.round(y6)}px, 0)` : \"translate3d(0, -200%, 0)\",\n      minWidth: \"max-content\",\n      zIndex: contentZIndex,\n      [\"--radix-popper-transform-origin\"]: [\n        (_middlewareData$trans = middlewareData.transformOrigin) === null || _middlewareData$trans === void 0 ? void 0 : _middlewareData$trans.x,\n        (_middlewareData$trans2 = middlewareData.transformOrigin) === null || _middlewareData$trans2 === void 0 ? void 0 : _middlewareData$trans2.y\n      ].join(\" \")\n    }\n  }, /* @__PURE__ */ (0, import_react22.createElement)($cf1ac5d9fe0e8206$var$PopperContentProvider, {\n    scope: __scopePopper,\n    placedSide,\n    onArrowChange: setArrow,\n    arrowX,\n    arrowY,\n    shouldHideArrow: cannotCenterArrow\n  }, isRoot ? /* @__PURE__ */ (0, import_react22.createElement)($cf1ac5d9fe0e8206$var$PositionContextProvider, {\n    scope: __scopePopper,\n    hasParent: true,\n    positionUpdateFns\n  }, /* @__PURE__ */ (0, import_react22.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, commonProps)) : /* @__PURE__ */ (0, import_react22.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, commonProps)));\n});\nvar $cf1ac5d9fe0e8206$var$ARROW_NAME = \"PopperArrow\";\nvar $cf1ac5d9fe0e8206$var$OPPOSITE_SIDE = {\n  top: \"bottom\",\n  right: \"left\",\n  bottom: \"top\",\n  left: \"right\"\n};\nvar $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd0 = /* @__PURE__ */ (0, import_react22.forwardRef)(function $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd02(props, forwardedRef) {\n  const { __scopePopper, ...arrowProps } = props;\n  const contentContext = $cf1ac5d9fe0e8206$var$useContentContext($cf1ac5d9fe0e8206$var$ARROW_NAME, __scopePopper);\n  const baseSide = $cf1ac5d9fe0e8206$var$OPPOSITE_SIDE[contentContext.placedSide];\n  return /* @__PURE__ */ (0, import_react22.createElement)(\"span\", {\n    ref: contentContext.onArrowChange,\n    style: {\n      position: \"absolute\",\n      left: contentContext.arrowX,\n      top: contentContext.arrowY,\n      [baseSide]: 0,\n      transformOrigin: {\n        top: \"\",\n        right: \"0 0\",\n        bottom: \"center 0\",\n        left: \"100% 0\"\n      }[contentContext.placedSide],\n      transform: {\n        top: \"translateY(100%)\",\n        right: \"translateY(50%) rotate(90deg) translateX(-50%)\",\n        bottom: `rotate(180deg)`,\n        left: \"translateY(50%) rotate(-90deg) translateX(50%)\"\n      }[contentContext.placedSide],\n      visibility: contentContext.shouldHideArrow ? \"hidden\" : void 0\n    }\n  }, /* @__PURE__ */ (0, import_react22.createElement)($7e8f5cd07187803e$export$be92b6f5f03c0fe9, _extends({}, arrowProps, {\n    ref: forwardedRef,\n    style: {\n      ...arrowProps.style,\n      display: \"block\"\n    }\n  })));\n});\nfunction $cf1ac5d9fe0e8206$var$isDefined(value) {\n  return value !== void 0;\n}\nfunction $cf1ac5d9fe0e8206$var$isNotNull(value) {\n  return value !== null;\n}\nvar $cf1ac5d9fe0e8206$var$transformOrigin = (options) => ({\n  name: \"transformOrigin\",\n  options,\n  fn(data) {\n    var _middlewareData$arrow4, _middlewareData$arrow5, _middlewareData$arrow6, _middlewareData$arrow7, _middlewareData$arrow8;\n    const { placement, rects, middlewareData } = data;\n    const cannotCenterArrow = ((_middlewareData$arrow4 = middlewareData.arrow) === null || _middlewareData$arrow4 === void 0 ? void 0 : _middlewareData$arrow4.centerOffset) !== 0;\n    const isArrowHidden = cannotCenterArrow;\n    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;\n    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;\n    const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement);\n    const noArrowAlign = {\n      start: \"0%\",\n      center: \"50%\",\n      end: \"100%\"\n    }[placedAlign];\n    const arrowXCenter = ((_middlewareData$arrow5 = (_middlewareData$arrow6 = middlewareData.arrow) === null || _middlewareData$arrow6 === void 0 ? void 0 : _middlewareData$arrow6.x) !== null && _middlewareData$arrow5 !== void 0 ? _middlewareData$arrow5 : 0) + arrowWidth / 2;\n    const arrowYCenter = ((_middlewareData$arrow7 = (_middlewareData$arrow8 = middlewareData.arrow) === null || _middlewareData$arrow8 === void 0 ? void 0 : _middlewareData$arrow8.y) !== null && _middlewareData$arrow7 !== void 0 ? _middlewareData$arrow7 : 0) + arrowHeight / 2;\n    let x5 = \"\";\n    let y6 = \"\";\n    if (placedSide === \"bottom\") {\n      x5 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;\n      y6 = `${-arrowHeight}px`;\n    } else if (placedSide === \"top\") {\n      x5 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;\n      y6 = `${rects.floating.height + arrowHeight}px`;\n    } else if (placedSide === \"right\") {\n      x5 = `${-arrowHeight}px`;\n      y6 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;\n    } else if (placedSide === \"left\") {\n      x5 = `${rects.floating.width + arrowHeight}px`;\n      y6 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;\n    }\n    return {\n      data: {\n        x: x5,\n        y: y6\n      }\n    };\n  }\n});\nfunction $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement) {\n  const [side, align = \"center\"] = placement.split(\"-\");\n  return [\n    side,\n    align\n  ];\n}\nvar $cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9 = $cf1ac5d9fe0e8206$export$badac9ada3a0bdf9;\nvar $cf1ac5d9fe0e8206$export$b688253958b8dfe7 = $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d;\nvar $cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2 = $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc;\nvar $cf1ac5d9fe0e8206$export$21b07c8f274aebd5 = $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd0;\n\n// node_modules/@radix-ui/react-portal/dist/index.module.js\nvar import_react23 = require(\"react\");\nvar import_react_dom3 = __toESM(require(\"react-dom\"));\nvar $f1701beae083dbae$export$602eac185826482c = /* @__PURE__ */ (0, import_react23.forwardRef)((props, forwardedRef) => {\n  var _globalThis$document;\n  const { container = globalThis === null || globalThis === void 0 ? void 0 : (_globalThis$document = globalThis.document) === null || _globalThis$document === void 0 ? void 0 : _globalThis$document.body, ...portalProps } = props;\n  return container ? /* @__PURE__ */ import_react_dom3.default.createPortal(/* @__PURE__ */ (0, import_react23.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, portalProps, {\n    ref: forwardedRef\n  })), container) : null;\n});\n\n// node_modules/@radix-ui/react-presence/dist/index.module.js\nvar import_react24 = require(\"react\");\nvar import_react_dom4 = require(\"react-dom\");\nfunction $fe963b355347cc68$export$3e6543de14f8614f(initialState, machine) {\n  return (0, import_react24.useReducer)((state, event) => {\n    const nextState = machine[state][event];\n    return nextState !== null && nextState !== void 0 ? nextState : state;\n  }, initialState);\n}\nvar $921a889cee6df7e8$export$99c2b779aa4e8b8b = (props) => {\n  const { present, children } = props;\n  const presence = $921a889cee6df7e8$var$usePresence(present);\n  const child = typeof children === \"function\" ? children({\n    present: presence.isPresent\n  }) : import_react24.Children.only(children);\n  const ref = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(presence.ref, child.ref);\n  const forceMount = typeof children === \"function\";\n  return forceMount || presence.isPresent ? /* @__PURE__ */ (0, import_react24.cloneElement)(child, {\n    ref\n  }) : null;\n};\n$921a889cee6df7e8$export$99c2b779aa4e8b8b.displayName = \"Presence\";\nfunction $921a889cee6df7e8$var$usePresence(present) {\n  const [node1, setNode] = (0, import_react24.useState)();\n  const stylesRef = (0, import_react24.useRef)({});\n  const prevPresentRef = (0, import_react24.useRef)(present);\n  const prevAnimationNameRef = (0, import_react24.useRef)(\"none\");\n  const initialState = present ? \"mounted\" : \"unmounted\";\n  const [state, send] = $fe963b355347cc68$export$3e6543de14f8614f(initialState, {\n    mounted: {\n      UNMOUNT: \"unmounted\",\n      ANIMATION_OUT: \"unmountSuspended\"\n    },\n    unmountSuspended: {\n      MOUNT: \"mounted\",\n      ANIMATION_END: \"unmounted\"\n    },\n    unmounted: {\n      MOUNT: \"mounted\"\n    }\n  });\n  (0, import_react24.useEffect)(() => {\n    const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);\n    prevAnimationNameRef.current = state === \"mounted\" ? currentAnimationName : \"none\";\n  }, [\n    state\n  ]);\n  $9f79659886946c16$export$e5c5a5f917a5871c(() => {\n    const styles = stylesRef.current;\n    const wasPresent = prevPresentRef.current;\n    const hasPresentChanged = wasPresent !== present;\n    if (hasPresentChanged) {\n      const prevAnimationName = prevAnimationNameRef.current;\n      const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(styles);\n      if (present)\n        send(\"MOUNT\");\n      else if (currentAnimationName === \"none\" || (styles === null || styles === void 0 ? void 0 : styles.display) === \"none\")\n        send(\"UNMOUNT\");\n      else {\n        const isAnimating = prevAnimationName !== currentAnimationName;\n        if (wasPresent && isAnimating)\n          send(\"ANIMATION_OUT\");\n        else\n          send(\"UNMOUNT\");\n      }\n      prevPresentRef.current = present;\n    }\n  }, [\n    present,\n    send\n  ]);\n  $9f79659886946c16$export$e5c5a5f917a5871c(() => {\n    if (node1) {\n      const handleAnimationEnd = (event) => {\n        const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);\n        const isCurrentAnimation = currentAnimationName.includes(event.animationName);\n        if (event.target === node1 && isCurrentAnimation)\n          (0, import_react_dom4.flushSync)(\n            () => send(\"ANIMATION_END\")\n          );\n      };\n      const handleAnimationStart = (event) => {\n        if (event.target === node1)\n          prevAnimationNameRef.current = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);\n      };\n      node1.addEventListener(\"animationstart\", handleAnimationStart);\n      node1.addEventListener(\"animationcancel\", handleAnimationEnd);\n      node1.addEventListener(\"animationend\", handleAnimationEnd);\n      return () => {\n        node1.removeEventListener(\"animationstart\", handleAnimationStart);\n        node1.removeEventListener(\"animationcancel\", handleAnimationEnd);\n        node1.removeEventListener(\"animationend\", handleAnimationEnd);\n      };\n    } else\n      send(\"ANIMATION_END\");\n  }, [\n    node1,\n    send\n  ]);\n  return {\n    isPresent: [\n      \"mounted\",\n      \"unmountSuspended\"\n    ].includes(state),\n    ref: (0, import_react24.useCallback)((node) => {\n      if (node)\n        stylesRef.current = getComputedStyle(node);\n      setNode(node);\n    }, [])\n  };\n}\nfunction $921a889cee6df7e8$var$getAnimationName(styles) {\n  return (styles === null || styles === void 0 ? void 0 : styles.animationName) || \"none\";\n}\n\n// node_modules/@radix-ui/react-roving-focus/dist/index.module.js\nvar import_react26 = require(\"react\");\n\n// node_modules/@radix-ui/react-use-controllable-state/dist/index.module.js\nvar import_react25 = require(\"react\");\nfunction $71cd76cc60e0454e$export$6f32135080cb4c3({ prop, defaultProp, onChange = () => {\n} }) {\n  const [uncontrolledProp, setUncontrolledProp] = $71cd76cc60e0454e$var$useUncontrolledState({\n    defaultProp,\n    onChange\n  });\n  const isControlled = prop !== void 0;\n  const value1 = isControlled ? prop : uncontrolledProp;\n  const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange);\n  const setValue = (0, import_react25.useCallback)((nextValue) => {\n    if (isControlled) {\n      const setter = nextValue;\n      const value = typeof nextValue === \"function\" ? setter(prop) : nextValue;\n      if (value !== prop)\n        handleChange(value);\n    } else\n      setUncontrolledProp(nextValue);\n  }, [\n    isControlled,\n    prop,\n    setUncontrolledProp,\n    handleChange\n  ]);\n  return [\n    value1,\n    setValue\n  ];\n}\nfunction $71cd76cc60e0454e$var$useUncontrolledState({ defaultProp, onChange }) {\n  const uncontrolledState = (0, import_react25.useState)(defaultProp);\n  const [value] = uncontrolledState;\n  const prevValueRef = (0, import_react25.useRef)(value);\n  const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange);\n  (0, import_react25.useEffect)(() => {\n    if (prevValueRef.current !== value) {\n      handleChange(value);\n      prevValueRef.current = value;\n    }\n  }, [\n    value,\n    prevValueRef,\n    handleChange\n  ]);\n  return uncontrolledState;\n}\n\n// node_modules/@radix-ui/react-roving-focus/dist/index.module.js\nvar $d7bdfb9eb0fdf311$var$ENTRY_FOCUS = \"rovingFocusGroup.onEntryFocus\";\nvar $d7bdfb9eb0fdf311$var$EVENT_OPTIONS = {\n  bubbles: false,\n  cancelable: true\n};\nvar $d7bdfb9eb0fdf311$var$GROUP_NAME = \"RovingFocusGroup\";\nvar [$d7bdfb9eb0fdf311$var$Collection, $d7bdfb9eb0fdf311$var$useCollection, $d7bdfb9eb0fdf311$var$createCollectionScope] = $e02a7d9cb1dc128c$export$c74125a8e3af6bb2($d7bdfb9eb0fdf311$var$GROUP_NAME);\nvar [$d7bdfb9eb0fdf311$var$createRovingFocusGroupContext, $d7bdfb9eb0fdf311$export$c7109489551a4f4] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($d7bdfb9eb0fdf311$var$GROUP_NAME, [\n  $d7bdfb9eb0fdf311$var$createCollectionScope\n]);\nvar [$d7bdfb9eb0fdf311$var$RovingFocusProvider, $d7bdfb9eb0fdf311$var$useRovingFocusContext] = $d7bdfb9eb0fdf311$var$createRovingFocusGroupContext($d7bdfb9eb0fdf311$var$GROUP_NAME);\nvar $d7bdfb9eb0fdf311$export$8699f7c8af148338 = /* @__PURE__ */ (0, import_react26.forwardRef)((props, forwardedRef) => {\n  return /* @__PURE__ */ (0, import_react26.createElement)($d7bdfb9eb0fdf311$var$Collection.Provider, {\n    scope: props.__scopeRovingFocusGroup\n  }, /* @__PURE__ */ (0, import_react26.createElement)($d7bdfb9eb0fdf311$var$Collection.Slot, {\n    scope: props.__scopeRovingFocusGroup\n  }, /* @__PURE__ */ (0, import_react26.createElement)($d7bdfb9eb0fdf311$var$RovingFocusGroupImpl, _extends({}, props, {\n    ref: forwardedRef\n  }))));\n});\nvar $d7bdfb9eb0fdf311$var$RovingFocusGroupImpl = /* @__PURE__ */ (0, import_react26.forwardRef)((props, forwardedRef) => {\n  const { __scopeRovingFocusGroup, orientation, loop = false, dir, currentTabStopId: currentTabStopIdProp, defaultCurrentTabStopId, onCurrentTabStopIdChange, onEntryFocus, ...groupProps } = props;\n  const ref = (0, import_react26.useRef)(null);\n  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);\n  const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir);\n  const [currentTabStopId = null, setCurrentTabStopId] = $71cd76cc60e0454e$export$6f32135080cb4c3({\n    prop: currentTabStopIdProp,\n    defaultProp: defaultCurrentTabStopId,\n    onChange: onCurrentTabStopIdChange\n  });\n  const [isTabbingBackOut, setIsTabbingBackOut] = (0, import_react26.useState)(false);\n  const handleEntryFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onEntryFocus);\n  const getItems = $d7bdfb9eb0fdf311$var$useCollection(__scopeRovingFocusGroup);\n  const isClickFocusRef = (0, import_react26.useRef)(false);\n  const [focusableItemsCount, setFocusableItemsCount] = (0, import_react26.useState)(0);\n  (0, import_react26.useEffect)(() => {\n    const node = ref.current;\n    if (node) {\n      node.addEventListener($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, handleEntryFocus);\n      return () => node.removeEventListener($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, handleEntryFocus);\n    }\n  }, [\n    handleEntryFocus\n  ]);\n  return /* @__PURE__ */ (0, import_react26.createElement)($d7bdfb9eb0fdf311$var$RovingFocusProvider, {\n    scope: __scopeRovingFocusGroup,\n    orientation,\n    dir: direction,\n    loop,\n    currentTabStopId,\n    onItemFocus: (0, import_react26.useCallback)(\n      (tabStopId) => setCurrentTabStopId(tabStopId),\n      [\n        setCurrentTabStopId\n      ]\n    ),\n    onItemShiftTab: (0, import_react26.useCallback)(\n      () => setIsTabbingBackOut(true),\n      []\n    ),\n    onFocusableItemAdd: (0, import_react26.useCallback)(\n      () => setFocusableItemsCount(\n        (prevCount) => prevCount + 1\n      ),\n      []\n    ),\n    onFocusableItemRemove: (0, import_react26.useCallback)(\n      () => setFocusableItemsCount(\n        (prevCount) => prevCount - 1\n      ),\n      []\n    )\n  }, /* @__PURE__ */ (0, import_react26.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({\n    tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,\n    \"data-orientation\": orientation\n  }, groupProps, {\n    ref: composedRefs,\n    style: {\n      outline: \"none\",\n      ...props.style\n    },\n    onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onMouseDown, () => {\n      isClickFocusRef.current = true;\n    }),\n    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocus, (event) => {\n      const isKeyboardFocus = !isClickFocusRef.current;\n      if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {\n        const entryFocusEvent = new CustomEvent($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, $d7bdfb9eb0fdf311$var$EVENT_OPTIONS);\n        event.currentTarget.dispatchEvent(entryFocusEvent);\n        if (!entryFocusEvent.defaultPrevented) {\n          const items = getItems().filter(\n            (item) => item.focusable\n          );\n          const activeItem = items.find(\n            (item) => item.active\n          );\n          const currentItem = items.find(\n            (item) => item.id === currentTabStopId\n          );\n          const candidateItems = [\n            activeItem,\n            currentItem,\n            ...items\n          ].filter(Boolean);\n          const candidateNodes = candidateItems.map(\n            (item) => item.ref.current\n          );\n          $d7bdfb9eb0fdf311$var$focusFirst(candidateNodes);\n        }\n      }\n      isClickFocusRef.current = false;\n    }),\n    onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(\n      props.onBlur,\n      () => setIsTabbingBackOut(false)\n    )\n  })));\n});\nvar $d7bdfb9eb0fdf311$var$ITEM_NAME = \"RovingFocusGroupItem\";\nvar $d7bdfb9eb0fdf311$export$ab9df7c53fe8454 = /* @__PURE__ */ (0, import_react26.forwardRef)((props, forwardedRef) => {\n  const { __scopeRovingFocusGroup, focusable = true, active = false, ...itemProps } = props;\n  const id = $1746a345f3d73bb7$export$f680877a34711e37();\n  const context = $d7bdfb9eb0fdf311$var$useRovingFocusContext($d7bdfb9eb0fdf311$var$ITEM_NAME, __scopeRovingFocusGroup);\n  const isCurrentTabStop = context.currentTabStopId === id;\n  const getItems = $d7bdfb9eb0fdf311$var$useCollection(__scopeRovingFocusGroup);\n  const { onFocusableItemAdd, onFocusableItemRemove } = context;\n  (0, import_react26.useEffect)(() => {\n    if (focusable) {\n      onFocusableItemAdd();\n      return () => onFocusableItemRemove();\n    }\n  }, [\n    focusable,\n    onFocusableItemAdd,\n    onFocusableItemRemove\n  ]);\n  return /* @__PURE__ */ (0, import_react26.createElement)($d7bdfb9eb0fdf311$var$Collection.ItemSlot, {\n    scope: __scopeRovingFocusGroup,\n    id,\n    focusable,\n    active\n  }, /* @__PURE__ */ (0, import_react26.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({\n    tabIndex: isCurrentTabStop ? 0 : -1,\n    \"data-orientation\": context.orientation\n  }, itemProps, {\n    ref: forwardedRef,\n    onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onMouseDown, (event) => {\n      if (!focusable)\n        event.preventDefault();\n      else\n        context.onItemFocus(id);\n    }),\n    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(\n      props.onFocus,\n      () => context.onItemFocus(id)\n    ),\n    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {\n      if (event.key === \"Tab\" && event.shiftKey) {\n        context.onItemShiftTab();\n        return;\n      }\n      if (event.target !== event.currentTarget)\n        return;\n      const focusIntent = $d7bdfb9eb0fdf311$var$getFocusIntent(event, context.orientation, context.dir);\n      if (focusIntent !== void 0) {\n        event.preventDefault();\n        const items = getItems().filter(\n          (item) => item.focusable\n        );\n        let candidateNodes = items.map(\n          (item) => item.ref.current\n        );\n        if (focusIntent === \"last\")\n          candidateNodes.reverse();\n        else if (focusIntent === \"prev\" || focusIntent === \"next\") {\n          if (focusIntent === \"prev\")\n            candidateNodes.reverse();\n          const currentIndex = candidateNodes.indexOf(event.currentTarget);\n          candidateNodes = context.loop ? $d7bdfb9eb0fdf311$var$wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);\n        }\n        setTimeout(\n          () => $d7bdfb9eb0fdf311$var$focusFirst(candidateNodes)\n        );\n      }\n    })\n  })));\n});\nvar $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT = {\n  ArrowLeft: \"prev\",\n  ArrowUp: \"prev\",\n  ArrowRight: \"next\",\n  ArrowDown: \"next\",\n  PageUp: \"first\",\n  Home: \"first\",\n  PageDown: \"last\",\n  End: \"last\"\n};\nfunction $d7bdfb9eb0fdf311$var$getDirectionAwareKey(key, dir) {\n  if (dir !== \"rtl\")\n    return key;\n  return key === \"ArrowLeft\" ? \"ArrowRight\" : key === \"ArrowRight\" ? \"ArrowLeft\" : key;\n}\nfunction $d7bdfb9eb0fdf311$var$getFocusIntent(event, orientation, dir) {\n  const key = $d7bdfb9eb0fdf311$var$getDirectionAwareKey(event.key, dir);\n  if (orientation === \"vertical\" && [\n    \"ArrowLeft\",\n    \"ArrowRight\"\n  ].includes(key))\n    return void 0;\n  if (orientation === \"horizontal\" && [\n    \"ArrowUp\",\n    \"ArrowDown\"\n  ].includes(key))\n    return void 0;\n  return $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT[key];\n}\nfunction $d7bdfb9eb0fdf311$var$focusFirst(candidates) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)\n      return;\n    candidate.focus();\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)\n      return;\n  }\n}\nfunction $d7bdfb9eb0fdf311$var$wrapArray(array, startIndex) {\n  return array.map(\n    (_3, index2) => array[(startIndex + index2) % array.length]\n  );\n}\nvar $d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9 = $d7bdfb9eb0fdf311$export$8699f7c8af148338;\nvar $d7bdfb9eb0fdf311$export$6d08773d2e66f8f2 = $d7bdfb9eb0fdf311$export$ab9df7c53fe8454;\n\n// node_modules/aria-hidden/dist/es2015/index.js\nvar getDefaultParent = function(originalTarget) {\n  if (typeof document === \"undefined\") {\n    return null;\n  }\n  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;\n  return sampleTarget.ownerDocument.body;\n};\nvar counterMap = /* @__PURE__ */ new WeakMap();\nvar uncontrolledNodes = /* @__PURE__ */ new WeakMap();\nvar markerMap = {};\nvar lockCount = 0;\nvar unwrapHost = function(node) {\n  return node && (node.host || unwrapHost(node.parentNode));\n};\nvar correctTargets = function(parent, targets) {\n  return targets.map(function(target) {\n    if (parent.contains(target)) {\n      return target;\n    }\n    var correctedTarget = unwrapHost(target);\n    if (correctedTarget && parent.contains(correctedTarget)) {\n      return correctedTarget;\n    }\n    console.error(\"aria-hidden\", target, \"in not contained inside\", parent, \". Doing nothing\");\n    return null;\n  }).filter(function(x5) {\n    return Boolean(x5);\n  });\n};\nvar applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {\n  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);\n  if (!markerMap[markerName]) {\n    markerMap[markerName] = /* @__PURE__ */ new WeakMap();\n  }\n  var markerCounter = markerMap[markerName];\n  var hiddenNodes = [];\n  var elementsToKeep = /* @__PURE__ */ new Set();\n  var elementsToStop = new Set(targets);\n  var keep = function(el) {\n    if (!el || elementsToKeep.has(el)) {\n      return;\n    }\n    elementsToKeep.add(el);\n    keep(el.parentNode);\n  };\n  targets.forEach(keep);\n  var deep = function(parent) {\n    if (!parent || elementsToStop.has(parent)) {\n      return;\n    }\n    Array.prototype.forEach.call(parent.children, function(node) {\n      if (elementsToKeep.has(node)) {\n        deep(node);\n      } else {\n        var attr = node.getAttribute(controlAttribute);\n        var alreadyHidden = attr !== null && attr !== \"false\";\n        var counterValue = (counterMap.get(node) || 0) + 1;\n        var markerValue = (markerCounter.get(node) || 0) + 1;\n        counterMap.set(node, counterValue);\n        markerCounter.set(node, markerValue);\n        hiddenNodes.push(node);\n        if (counterValue === 1 && alreadyHidden) {\n          uncontrolledNodes.set(node, true);\n        }\n        if (markerValue === 1) {\n          node.setAttribute(markerName, \"true\");\n        }\n        if (!alreadyHidden) {\n          node.setAttribute(controlAttribute, \"true\");\n        }\n      }\n    });\n  };\n  deep(parentNode);\n  elementsToKeep.clear();\n  lockCount++;\n  return function() {\n    hiddenNodes.forEach(function(node) {\n      var counterValue = counterMap.get(node) - 1;\n      var markerValue = markerCounter.get(node) - 1;\n      counterMap.set(node, counterValue);\n      markerCounter.set(node, markerValue);\n      if (!counterValue) {\n        if (!uncontrolledNodes.has(node)) {\n          node.removeAttribute(controlAttribute);\n        }\n        uncontrolledNodes.delete(node);\n      }\n      if (!markerValue) {\n        node.removeAttribute(markerName);\n      }\n    });\n    lockCount--;\n    if (!lockCount) {\n      counterMap = /* @__PURE__ */ new WeakMap();\n      counterMap = /* @__PURE__ */ new WeakMap();\n      uncontrolledNodes = /* @__PURE__ */ new WeakMap();\n      markerMap = {};\n    }\n  };\n};\nvar hideOthers = function(originalTarget, parentNode, markerName) {\n  if (markerName === void 0) {\n    markerName = \"data-aria-hidden\";\n  }\n  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);\n  var activeParentNode = parentNode || getDefaultParent(originalTarget);\n  if (!activeParentNode) {\n    return function() {\n      return null;\n    };\n  }\n  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll(\"[aria-live]\")));\n  return applyAttributeToOthers(targets, activeParentNode, markerName, \"aria-hidden\");\n};\n\n// node_modules/tslib/tslib.es6.js\nvar __assign = function() {\n  __assign = Object.assign || function __assign2(t5) {\n    for (var s5, i4 = 1, n5 = arguments.length; i4 < n5; i4++) {\n      s5 = arguments[i4];\n      for (var p6 in s5)\n        if (Object.prototype.hasOwnProperty.call(s5, p6))\n          t5[p6] = s5[p6];\n    }\n    return t5;\n  };\n  return __assign.apply(this, arguments);\n};\nfunction __rest(s5, e5) {\n  var t5 = {};\n  for (var p6 in s5)\n    if (Object.prototype.hasOwnProperty.call(s5, p6) && e5.indexOf(p6) < 0)\n      t5[p6] = s5[p6];\n  if (s5 != null && typeof Object.getOwnPropertySymbols === \"function\")\n    for (var i4 = 0, p6 = Object.getOwnPropertySymbols(s5); i4 < p6.length; i4++) {\n      if (e5.indexOf(p6[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s5, p6[i4]))\n        t5[p6[i4]] = s5[p6[i4]];\n    }\n  return t5;\n}\nfunction __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2)\n    for (var i4 = 0, l7 = from.length, ar; i4 < l7; i4++) {\n      if (ar || !(i4 in from)) {\n        if (!ar)\n          ar = Array.prototype.slice.call(from, 0, i4);\n        ar[i4] = from[i4];\n      }\n    }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\n// node_modules/react-remove-scroll/dist/es2015/Combination.js\nvar React8 = __toESM(require(\"react\"));\n\n// node_modules/react-remove-scroll/dist/es2015/UI.js\nvar React4 = __toESM(require(\"react\"));\n\n// node_modules/react-remove-scroll-bar/dist/es2015/constants.js\nvar zeroRightClassName = \"right-scroll-bar-position\";\nvar fullWidthClassName = \"width-before-scroll-bar\";\nvar noScrollbarsClassName = \"with-scroll-bars-hidden\";\nvar removedBarSizeVariable = \"--removed-body-scroll-bar-size\";\n\n// node_modules/use-callback-ref/dist/es2015/assignRef.js\nfunction assignRef(ref, value) {\n  if (typeof ref === \"function\") {\n    ref(value);\n  } else if (ref) {\n    ref.current = value;\n  }\n  return ref;\n}\n\n// node_modules/use-callback-ref/dist/es2015/useRef.js\nvar import_react27 = require(\"react\");\nfunction useCallbackRef(initialValue, callback) {\n  var ref = (0, import_react27.useState)(function() {\n    return {\n      value: initialValue,\n      callback,\n      facade: {\n        get current() {\n          return ref.value;\n        },\n        set current(value) {\n          var last = ref.value;\n          if (last !== value) {\n            ref.value = value;\n            ref.callback(value, last);\n          }\n        }\n      }\n    };\n  })[0];\n  ref.callback = callback;\n  return ref.facade;\n}\n\n// node_modules/use-callback-ref/dist/es2015/useMergeRef.js\nfunction useMergeRefs(refs, defaultValue) {\n  return useCallbackRef(defaultValue || null, function(newValue) {\n    return refs.forEach(function(ref) {\n      return assignRef(ref, newValue);\n    });\n  });\n}\n\n// node_modules/use-sidecar/dist/es2015/medium.js\nfunction ItoI(a7) {\n  return a7;\n}\nfunction innerCreateMedium(defaults, middleware) {\n  if (middleware === void 0) {\n    middleware = ItoI;\n  }\n  var buffer = [];\n  var assigned = false;\n  var medium = {\n    read: function() {\n      if (assigned) {\n        throw new Error(\"Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.\");\n      }\n      if (buffer.length) {\n        return buffer[buffer.length - 1];\n      }\n      return defaults;\n    },\n    useMedium: function(data) {\n      var item = middleware(data, assigned);\n      buffer.push(item);\n      return function() {\n        buffer = buffer.filter(function(x5) {\n          return x5 !== item;\n        });\n      };\n    },\n    assignSyncMedium: function(cb) {\n      assigned = true;\n      while (buffer.length) {\n        var cbs = buffer;\n        buffer = [];\n        cbs.forEach(cb);\n      }\n      buffer = {\n        push: function(x5) {\n          return cb(x5);\n        },\n        filter: function() {\n          return buffer;\n        }\n      };\n    },\n    assignMedium: function(cb) {\n      assigned = true;\n      var pendingQueue = [];\n      if (buffer.length) {\n        var cbs = buffer;\n        buffer = [];\n        cbs.forEach(cb);\n        pendingQueue = buffer;\n      }\n      var executeQueue = function() {\n        var cbs2 = pendingQueue;\n        pendingQueue = [];\n        cbs2.forEach(cb);\n      };\n      var cycle = function() {\n        return Promise.resolve().then(executeQueue);\n      };\n      cycle();\n      buffer = {\n        push: function(x5) {\n          pendingQueue.push(x5);\n          cycle();\n        },\n        filter: function(filter2) {\n          pendingQueue = pendingQueue.filter(filter2);\n          return buffer;\n        }\n      };\n    }\n  };\n  return medium;\n}\nfunction createSidecarMedium(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var medium = innerCreateMedium(null);\n  medium.options = __assign({ async: true, ssr: false }, options);\n  return medium;\n}\n\n// node_modules/use-sidecar/dist/es2015/exports.js\nvar React3 = __toESM(require(\"react\"));\nvar SideCar = function(_a) {\n  var sideCar = _a.sideCar, rest = __rest(_a, [\"sideCar\"]);\n  if (!sideCar) {\n    throw new Error(\"Sidecar: please provide `sideCar` property to import the right car\");\n  }\n  var Target = sideCar.read();\n  if (!Target) {\n    throw new Error(\"Sidecar medium not found\");\n  }\n  return React3.createElement(Target, __assign({}, rest));\n};\nSideCar.isSideCarExport = true;\nfunction exportSidecar(medium, exported) {\n  medium.useMedium(exported);\n  return SideCar;\n}\n\n// node_modules/react-remove-scroll/dist/es2015/medium.js\nvar effectCar = createSidecarMedium();\n\n// node_modules/react-remove-scroll/dist/es2015/UI.js\nvar nothing = function() {\n  return;\n};\nvar RemoveScroll = React4.forwardRef(function(props, parentRef) {\n  var ref = React4.useRef(null);\n  var _a = React4.useState({\n    onScrollCapture: nothing,\n    onWheelCapture: nothing,\n    onTouchMoveCapture: nothing\n  }), callbacks = _a[0], setCallbacks = _a[1];\n  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? \"div\" : _b, rest = __rest(props, [\"forwardProps\", \"children\", \"className\", \"removeScrollBar\", \"enabled\", \"shards\", \"sideCar\", \"noIsolation\", \"inert\", \"allowPinchZoom\", \"as\"]);\n  var SideCar2 = sideCar;\n  var containerRef = useMergeRefs([ref, parentRef]);\n  var containerProps = __assign(__assign({}, rest), callbacks);\n  return React4.createElement(\n    React4.Fragment,\n    null,\n    enabled && React4.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref }),\n    forwardProps ? React4.cloneElement(React4.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React4.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)\n  );\n});\nRemoveScroll.defaultProps = {\n  enabled: true,\n  removeScrollBar: true,\n  inert: false\n};\nRemoveScroll.classNames = {\n  fullWidth: fullWidthClassName,\n  zeroRight: zeroRightClassName\n};\n\n// node_modules/react-remove-scroll/dist/es2015/SideEffect.js\nvar React7 = __toESM(require(\"react\"));\n\n// node_modules/react-remove-scroll-bar/dist/es2015/component.js\nvar React6 = __toESM(require(\"react\"));\n\n// node_modules/react-style-singleton/dist/es2015/hook.js\nvar React5 = __toESM(require(\"react\"));\n\n// node_modules/get-nonce/dist/es2015/index.js\nvar currentNonce;\nvar getNonce = function() {\n  if (currentNonce) {\n    return currentNonce;\n  }\n  if (typeof __webpack_nonce__ !== \"undefined\") {\n    return __webpack_nonce__;\n  }\n  return void 0;\n};\n\n// node_modules/react-style-singleton/dist/es2015/singleton.js\nfunction makeStyleTag() {\n  if (!document)\n    return null;\n  var tag = document.createElement(\"style\");\n  tag.type = \"text/css\";\n  var nonce = getNonce();\n  if (nonce) {\n    tag.setAttribute(\"nonce\", nonce);\n  }\n  return tag;\n}\nfunction injectStyles(tag, css) {\n  if (tag.styleSheet) {\n    tag.styleSheet.cssText = css;\n  } else {\n    tag.appendChild(document.createTextNode(css));\n  }\n}\nfunction insertStyleTag(tag) {\n  var head = document.head || document.getElementsByTagName(\"head\")[0];\n  head.appendChild(tag);\n}\nvar stylesheetSingleton = function() {\n  var counter = 0;\n  var stylesheet = null;\n  return {\n    add: function(style) {\n      if (counter == 0) {\n        if (stylesheet = makeStyleTag()) {\n          injectStyles(stylesheet, style);\n          insertStyleTag(stylesheet);\n        }\n      }\n      counter++;\n    },\n    remove: function() {\n      counter--;\n      if (!counter && stylesheet) {\n        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);\n        stylesheet = null;\n      }\n    }\n  };\n};\n\n// node_modules/react-style-singleton/dist/es2015/hook.js\nvar styleHookSingleton = function() {\n  var sheet = stylesheetSingleton();\n  return function(styles, isDynamic) {\n    React5.useEffect(function() {\n      sheet.add(styles);\n      return function() {\n        sheet.remove();\n      };\n    }, [styles && isDynamic]);\n  };\n};\n\n// node_modules/react-style-singleton/dist/es2015/component.js\nvar styleSingleton = function() {\n  var useStyle = styleHookSingleton();\n  var Sheet = function(_a) {\n    var styles = _a.styles, dynamic = _a.dynamic;\n    useStyle(styles, dynamic);\n    return null;\n  };\n  return Sheet;\n};\n\n// node_modules/react-remove-scroll-bar/dist/es2015/utils.js\nvar zeroGap = {\n  left: 0,\n  top: 0,\n  right: 0,\n  gap: 0\n};\nvar parse2 = function(x5) {\n  return parseInt(x5 || \"\", 10) || 0;\n};\nvar getOffset = function(gapMode) {\n  var cs = window.getComputedStyle(document.body);\n  var left = cs[gapMode === \"padding\" ? \"paddingLeft\" : \"marginLeft\"];\n  var top2 = cs[gapMode === \"padding\" ? \"paddingTop\" : \"marginTop\"];\n  var right = cs[gapMode === \"padding\" ? \"paddingRight\" : \"marginRight\"];\n  return [parse2(left), parse2(top2), parse2(right)];\n};\nvar getGapWidth = function(gapMode) {\n  if (gapMode === void 0) {\n    gapMode = \"margin\";\n  }\n  if (typeof window === \"undefined\") {\n    return zeroGap;\n  }\n  var offsets = getOffset(gapMode);\n  var documentWidth = document.documentElement.clientWidth;\n  var windowWidth = window.innerWidth;\n  return {\n    left: offsets[0],\n    top: offsets[1],\n    right: offsets[2],\n    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])\n  };\n};\n\n// node_modules/react-remove-scroll-bar/dist/es2015/component.js\nvar Style = styleSingleton();\nvar getStyles = function(_a, allowRelative, gapMode, important) {\n  var left = _a.left, top2 = _a.top, right = _a.right, gap = _a.gap;\n  if (gapMode === void 0) {\n    gapMode = \"margin\";\n  }\n  return \"\\n  .\".concat(noScrollbarsClassName, \" {\\n   overflow: hidden \").concat(important, \";\\n   padding-right: \").concat(gap, \"px \").concat(important, \";\\n  }\\n  body {\\n    overflow: hidden \").concat(important, \";\\n    overscroll-behavior: contain;\\n    \").concat([\n    allowRelative && \"position: relative \".concat(important, \";\"),\n    gapMode === \"margin\" && \"\\n    padding-left: \".concat(left, \"px;\\n    padding-top: \").concat(top2, \"px;\\n    padding-right: \").concat(right, \"px;\\n    margin-left:0;\\n    margin-top:0;\\n    margin-right: \").concat(gap, \"px \").concat(important, \";\\n    \"),\n    gapMode === \"padding\" && \"padding-right: \".concat(gap, \"px \").concat(important, \";\")\n  ].filter(Boolean).join(\"\"), \"\\n  }\\n  \\n  .\").concat(zeroRightClassName, \" {\\n    right: \").concat(gap, \"px \").concat(important, \";\\n  }\\n  \\n  .\").concat(fullWidthClassName, \" {\\n    margin-right: \").concat(gap, \"px \").concat(important, \";\\n  }\\n  \\n  .\").concat(zeroRightClassName, \" .\").concat(zeroRightClassName, \" {\\n    right: 0 \").concat(important, \";\\n  }\\n  \\n  .\").concat(fullWidthClassName, \" .\").concat(fullWidthClassName, \" {\\n    margin-right: 0 \").concat(important, \";\\n  }\\n  \\n  body {\\n    \").concat(removedBarSizeVariable, \": \").concat(gap, \"px;\\n  }\\n\");\n};\nvar RemoveScrollBar = function(props) {\n  var noRelative = props.noRelative, noImportant = props.noImportant, _a = props.gapMode, gapMode = _a === void 0 ? \"margin\" : _a;\n  var gap = React6.useMemo(function() {\n    return getGapWidth(gapMode);\n  }, [gapMode]);\n  return React6.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? \"!important\" : \"\") });\n};\n\n// node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js\nvar passiveSupported = false;\nif (typeof window !== \"undefined\") {\n  try {\n    options = Object.defineProperty({}, \"passive\", {\n      get: function() {\n        passiveSupported = true;\n        return true;\n      }\n    });\n    window.addEventListener(\"test\", options, options);\n    window.removeEventListener(\"test\", options, options);\n  } catch (err) {\n    passiveSupported = false;\n  }\n}\nvar options;\nvar nonPassive = passiveSupported ? { passive: false } : false;\n\n// node_modules/react-remove-scroll/dist/es2015/handleScroll.js\nvar alwaysContainsScroll = function(node) {\n  return node.tagName === \"TEXTAREA\";\n};\nvar elementCanBeScrolled = function(node, overflow) {\n  var styles = window.getComputedStyle(node);\n  return styles[overflow] !== \"hidden\" && !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === \"visible\");\n};\nvar elementCouldBeVScrolled = function(node) {\n  return elementCanBeScrolled(node, \"overflowY\");\n};\nvar elementCouldBeHScrolled = function(node) {\n  return elementCanBeScrolled(node, \"overflowX\");\n};\nvar locationCouldBeScrolled = function(axis, node) {\n  var current = node;\n  do {\n    if (typeof ShadowRoot !== \"undefined\" && current instanceof ShadowRoot) {\n      current = current.host;\n    }\n    var isScrollable = elementCouldBeScrolled(axis, current);\n    if (isScrollable) {\n      var _a = getScrollVariables(axis, current), s5 = _a[1], d6 = _a[2];\n      if (s5 > d6) {\n        return true;\n      }\n    }\n    current = current.parentNode;\n  } while (current && current !== document.body);\n  return false;\n};\nvar getVScrollVariables = function(_a) {\n  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;\n  return [\n    scrollTop,\n    scrollHeight,\n    clientHeight\n  ];\n};\nvar getHScrollVariables = function(_a) {\n  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;\n  return [\n    scrollLeft,\n    scrollWidth,\n    clientWidth\n  ];\n};\nvar elementCouldBeScrolled = function(axis, node) {\n  return axis === \"v\" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);\n};\nvar getScrollVariables = function(axis, node) {\n  return axis === \"v\" ? getVScrollVariables(node) : getHScrollVariables(node);\n};\nvar getDirectionFactor = function(axis, direction) {\n  return axis === \"h\" && direction === \"rtl\" ? -1 : 1;\n};\nvar handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {\n  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);\n  var delta = directionFactor * sourceDelta;\n  var target = event.target;\n  var targetInLock = endTarget.contains(target);\n  var shouldCancelScroll = false;\n  var isDeltaPositive = delta > 0;\n  var availableScroll = 0;\n  var availableScrollTop = 0;\n  do {\n    var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];\n    var elementScroll = scroll_1 - capacity - directionFactor * position;\n    if (position || elementScroll) {\n      if (elementCouldBeScrolled(axis, target)) {\n        availableScroll += elementScroll;\n        availableScrollTop += position;\n      }\n    }\n    target = target.parentNode;\n  } while (!targetInLock && target !== document.body || targetInLock && (endTarget.contains(target) || endTarget === target));\n  if (isDeltaPositive && (noOverscroll && availableScroll === 0 || !noOverscroll && delta > availableScroll)) {\n    shouldCancelScroll = true;\n  } else if (!isDeltaPositive && (noOverscroll && availableScrollTop === 0 || !noOverscroll && -delta > availableScrollTop)) {\n    shouldCancelScroll = true;\n  }\n  return shouldCancelScroll;\n};\n\n// node_modules/react-remove-scroll/dist/es2015/SideEffect.js\nvar getTouchXY = function(event) {\n  return \"changedTouches\" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];\n};\nvar getDeltaXY = function(event) {\n  return [event.deltaX, event.deltaY];\n};\nvar extractRef = function(ref) {\n  return ref && \"current\" in ref ? ref.current : ref;\n};\nvar deltaCompare = function(x5, y6) {\n  return x5[0] === y6[0] && x5[1] === y6[1];\n};\nvar generateStyle = function(id) {\n  return \"\\n  .block-interactivity-\".concat(id, \" {pointer-events: none;}\\n  .allow-interactivity-\").concat(id, \" {pointer-events: all;}\\n\");\n};\nvar idCounter = 0;\nvar lockStack = [];\nfunction RemoveScrollSideCar(props) {\n  var shouldPreventQueue = React7.useRef([]);\n  var touchStartRef = React7.useRef([0, 0]);\n  var activeAxis = React7.useRef();\n  var id = React7.useState(idCounter++)[0];\n  var Style2 = React7.useState(function() {\n    return styleSingleton();\n  })[0];\n  var lastProps = React7.useRef(props);\n  React7.useEffect(function() {\n    lastProps.current = props;\n  }, [props]);\n  React7.useEffect(function() {\n    if (props.inert) {\n      document.body.classList.add(\"block-interactivity-\".concat(id));\n      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);\n      allow_1.forEach(function(el) {\n        return el.classList.add(\"allow-interactivity-\".concat(id));\n      });\n      return function() {\n        document.body.classList.remove(\"block-interactivity-\".concat(id));\n        allow_1.forEach(function(el) {\n          return el.classList.remove(\"allow-interactivity-\".concat(id));\n        });\n      };\n    }\n    return;\n  }, [props.inert, props.lockRef.current, props.shards]);\n  var shouldCancelEvent = React7.useCallback(function(event, parent) {\n    if (\"touches\" in event && event.touches.length === 2) {\n      return !lastProps.current.allowPinchZoom;\n    }\n    var touch = getTouchXY(event);\n    var touchStart = touchStartRef.current;\n    var deltaX = \"deltaX\" in event ? event.deltaX : touchStart[0] - touch[0];\n    var deltaY = \"deltaY\" in event ? event.deltaY : touchStart[1] - touch[1];\n    var currentAxis;\n    var target = event.target;\n    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? \"h\" : \"v\";\n    if (\"touches\" in event && moveDirection === \"h\" && target.type === \"range\") {\n      return false;\n    }\n    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);\n    if (!canBeScrolledInMainDirection) {\n      return true;\n    }\n    if (canBeScrolledInMainDirection) {\n      currentAxis = moveDirection;\n    } else {\n      currentAxis = moveDirection === \"v\" ? \"h\" : \"v\";\n      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);\n    }\n    if (!canBeScrolledInMainDirection) {\n      return false;\n    }\n    if (!activeAxis.current && \"changedTouches\" in event && (deltaX || deltaY)) {\n      activeAxis.current = currentAxis;\n    }\n    if (!currentAxis) {\n      return true;\n    }\n    var cancelingAxis = activeAxis.current || currentAxis;\n    return handleScroll(cancelingAxis, parent, event, cancelingAxis === \"h\" ? deltaX : deltaY, true);\n  }, []);\n  var shouldPrevent = React7.useCallback(function(_event) {\n    var event = _event;\n    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {\n      return;\n    }\n    var delta = \"deltaY\" in event ? getDeltaXY(event) : getTouchXY(event);\n    var sourceEvent = shouldPreventQueue.current.filter(function(e5) {\n      return e5.name === event.type && e5.target === event.target && deltaCompare(e5.delta, delta);\n    })[0];\n    if (sourceEvent && sourceEvent.should) {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n      return;\n    }\n    if (!sourceEvent) {\n      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {\n        return node.contains(event.target);\n      });\n      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;\n      if (shouldStop) {\n        if (event.cancelable) {\n          event.preventDefault();\n        }\n      }\n    }\n  }, []);\n  var shouldCancel = React7.useCallback(function(name, delta, target, should) {\n    var event = { name, delta, target, should };\n    shouldPreventQueue.current.push(event);\n    setTimeout(function() {\n      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e5) {\n        return e5 !== event;\n      });\n    }, 1);\n  }, []);\n  var scrollTouchStart = React7.useCallback(function(event) {\n    touchStartRef.current = getTouchXY(event);\n    activeAxis.current = void 0;\n  }, []);\n  var scrollWheel = React7.useCallback(function(event) {\n    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));\n  }, []);\n  var scrollTouchMove = React7.useCallback(function(event) {\n    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));\n  }, []);\n  React7.useEffect(function() {\n    lockStack.push(Style2);\n    props.setCallbacks({\n      onScrollCapture: scrollWheel,\n      onWheelCapture: scrollWheel,\n      onTouchMoveCapture: scrollTouchMove\n    });\n    document.addEventListener(\"wheel\", shouldPrevent, nonPassive);\n    document.addEventListener(\"touchmove\", shouldPrevent, nonPassive);\n    document.addEventListener(\"touchstart\", scrollTouchStart, nonPassive);\n    return function() {\n      lockStack = lockStack.filter(function(inst) {\n        return inst !== Style2;\n      });\n      document.removeEventListener(\"wheel\", shouldPrevent, nonPassive);\n      document.removeEventListener(\"touchmove\", shouldPrevent, nonPassive);\n      document.removeEventListener(\"touchstart\", scrollTouchStart, nonPassive);\n    };\n  }, []);\n  var removeScrollBar = props.removeScrollBar, inert = props.inert;\n  return React7.createElement(\n    React7.Fragment,\n    null,\n    inert ? React7.createElement(Style2, { styles: generateStyle(id) }) : null,\n    removeScrollBar ? React7.createElement(RemoveScrollBar, { gapMode: \"margin\" }) : null\n  );\n}\n\n// node_modules/react-remove-scroll/dist/es2015/sidecar.js\nvar sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);\n\n// node_modules/react-remove-scroll/dist/es2015/Combination.js\nvar ReactRemoveScroll = React8.forwardRef(function(props, ref) {\n  return React8.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: sidecar_default }));\n});\nReactRemoveScroll.classNames = RemoveScroll.classNames;\nvar Combination_default = ReactRemoveScroll;\n\n// node_modules/@radix-ui/react-menu/dist/index.module.js\nvar $6cc32821e9371a1c$var$SELECTION_KEYS = [\n  \"Enter\",\n  \" \"\n];\nvar $6cc32821e9371a1c$var$FIRST_KEYS = [\n  \"ArrowDown\",\n  \"PageUp\",\n  \"Home\"\n];\nvar $6cc32821e9371a1c$var$LAST_KEYS = [\n  \"ArrowUp\",\n  \"PageDown\",\n  \"End\"\n];\nvar $6cc32821e9371a1c$var$FIRST_LAST_KEYS = [\n  ...$6cc32821e9371a1c$var$FIRST_KEYS,\n  ...$6cc32821e9371a1c$var$LAST_KEYS\n];\nvar $6cc32821e9371a1c$var$SUB_OPEN_KEYS = {\n  ltr: [\n    ...$6cc32821e9371a1c$var$SELECTION_KEYS,\n    \"ArrowRight\"\n  ],\n  rtl: [\n    ...$6cc32821e9371a1c$var$SELECTION_KEYS,\n    \"ArrowLeft\"\n  ]\n};\nvar $6cc32821e9371a1c$var$SUB_CLOSE_KEYS = {\n  ltr: [\n    \"ArrowLeft\"\n  ],\n  rtl: [\n    \"ArrowRight\"\n  ]\n};\nvar $6cc32821e9371a1c$var$MENU_NAME = \"Menu\";\nvar [$6cc32821e9371a1c$var$Collection, $6cc32821e9371a1c$var$useCollection, $6cc32821e9371a1c$var$createCollectionScope] = $e02a7d9cb1dc128c$export$c74125a8e3af6bb2($6cc32821e9371a1c$var$MENU_NAME);\nvar [$6cc32821e9371a1c$var$createMenuContext, $6cc32821e9371a1c$export$4027731b685e72eb] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($6cc32821e9371a1c$var$MENU_NAME, [\n  $6cc32821e9371a1c$var$createCollectionScope,\n  $cf1ac5d9fe0e8206$export$722aac194ae923,\n  $d7bdfb9eb0fdf311$export$c7109489551a4f4\n]);\nvar $6cc32821e9371a1c$var$usePopperScope = $cf1ac5d9fe0e8206$export$722aac194ae923();\nvar $6cc32821e9371a1c$var$useRovingFocusGroupScope = $d7bdfb9eb0fdf311$export$c7109489551a4f4();\nvar [$6cc32821e9371a1c$var$MenuProvider, $6cc32821e9371a1c$var$useMenuContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$MENU_NAME);\nvar [$6cc32821e9371a1c$var$MenuRootProvider, $6cc32821e9371a1c$var$useMenuRootContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$MENU_NAME);\nvar $6cc32821e9371a1c$export$d9b273488cd8ce6f = (props) => {\n  const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props;\n  const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);\n  const [content, setContent] = (0, import_react28.useState)(null);\n  const isUsingKeyboardRef = (0, import_react28.useRef)(false);\n  const handleOpenChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onOpenChange);\n  const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir);\n  (0, import_react28.useEffect)(() => {\n    const handleKeyDown = () => {\n      isUsingKeyboardRef.current = true;\n      document.addEventListener(\"pointerdown\", handlePointer, {\n        capture: true,\n        once: true\n      });\n      document.addEventListener(\"pointermove\", handlePointer, {\n        capture: true,\n        once: true\n      });\n    };\n    const handlePointer = () => isUsingKeyboardRef.current = false;\n    document.addEventListener(\"keydown\", handleKeyDown, {\n      capture: true\n    });\n    return () => {\n      document.removeEventListener(\"keydown\", handleKeyDown, {\n        capture: true\n      });\n      document.removeEventListener(\"pointerdown\", handlePointer, {\n        capture: true\n      });\n      document.removeEventListener(\"pointermove\", handlePointer, {\n        capture: true\n      });\n    };\n  }, []);\n  return /* @__PURE__ */ (0, import_react28.createElement)($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9, popperScope, /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuProvider, {\n    scope: __scopeMenu,\n    open,\n    onOpenChange: handleOpenChange,\n    content,\n    onContentChange: setContent\n  }, /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuRootProvider, {\n    scope: __scopeMenu,\n    onClose: (0, import_react28.useCallback)(\n      () => handleOpenChange(false),\n      [\n        handleOpenChange\n      ]\n    ),\n    isUsingKeyboardRef,\n    dir: direction,\n    modal\n  }, children)));\n};\nvar $6cc32821e9371a1c$export$9fa5ebd18bee4d43 = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {\n  const { __scopeMenu, ...anchorProps } = props;\n  const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);\n  return /* @__PURE__ */ (0, import_react28.createElement)($cf1ac5d9fe0e8206$export$b688253958b8dfe7, _extends({}, popperScope, anchorProps, {\n    ref: forwardedRef\n  }));\n});\nvar $6cc32821e9371a1c$var$PORTAL_NAME = \"MenuPortal\";\nvar [$6cc32821e9371a1c$var$PortalProvider, $6cc32821e9371a1c$var$usePortalContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$PORTAL_NAME, {\n  forceMount: void 0\n});\nvar $6cc32821e9371a1c$export$793392f970497feb = (props) => {\n  const { __scopeMenu, forceMount, children, container } = props;\n  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$PORTAL_NAME, __scopeMenu);\n  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$PortalProvider, {\n    scope: __scopeMenu,\n    forceMount\n  }, /* @__PURE__ */ (0, import_react28.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {\n    present: forceMount || context.open\n  }, /* @__PURE__ */ (0, import_react28.createElement)($f1701beae083dbae$export$602eac185826482c, {\n    asChild: true,\n    container\n  }, children)));\n};\nvar $6cc32821e9371a1c$var$CONTENT_NAME = \"MenuContent\";\nvar [$6cc32821e9371a1c$var$MenuContentProvider, $6cc32821e9371a1c$var$useMenuContentContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$CONTENT_NAME);\nvar $6cc32821e9371a1c$export$479f0f2f71193efe = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {\n  const portalContext = $6cc32821e9371a1c$var$usePortalContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);\n  const { forceMount = portalContext.forceMount, ...contentProps } = props;\n  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);\n  const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);\n  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$Collection.Provider, {\n    scope: props.__scopeMenu\n  }, /* @__PURE__ */ (0, import_react28.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {\n    present: forceMount || context.open\n  }, /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$Collection.Slot, {\n    scope: props.__scopeMenu\n  }, rootContext.modal ? /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuRootContentModal, _extends({}, contentProps, {\n    ref: forwardedRef\n  })) : /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuRootContentNonModal, _extends({}, contentProps, {\n    ref: forwardedRef\n  })))));\n});\nvar $6cc32821e9371a1c$var$MenuRootContentModal = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {\n  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);\n  const ref = (0, import_react28.useRef)(null);\n  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);\n  (0, import_react28.useEffect)(() => {\n    const content = ref.current;\n    if (content)\n      return hideOthers(content);\n  }, []);\n  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuContentImpl, _extends({}, props, {\n    ref: composedRefs,\n    trapFocus: context.open,\n    disableOutsidePointerEvents: context.open,\n    disableOutsideScroll: true,\n    onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(\n      props.onFocusOutside,\n      (event) => event.preventDefault(),\n      {\n        checkForDefaultPrevented: false\n      }\n    ),\n    onDismiss: () => context.onOpenChange(false)\n  }));\n});\nvar $6cc32821e9371a1c$var$MenuRootContentNonModal = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {\n  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);\n  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuContentImpl, _extends({}, props, {\n    ref: forwardedRef,\n    trapFocus: false,\n    disableOutsidePointerEvents: false,\n    disableOutsideScroll: false,\n    onDismiss: () => context.onOpenChange(false)\n  }));\n});\nvar $6cc32821e9371a1c$var$MenuContentImpl = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {\n  const { __scopeMenu, loop = false, trapFocus, onOpenAutoFocus, onCloseAutoFocus, disableOutsidePointerEvents, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, onDismiss, disableOutsideScroll, ...contentProps } = props;\n  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, __scopeMenu);\n  const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$CONTENT_NAME, __scopeMenu);\n  const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);\n  const rovingFocusGroupScope = $6cc32821e9371a1c$var$useRovingFocusGroupScope(__scopeMenu);\n  const getItems = $6cc32821e9371a1c$var$useCollection(__scopeMenu);\n  const [currentItemId, setCurrentItemId] = (0, import_react28.useState)(null);\n  const contentRef = (0, import_react28.useRef)(null);\n  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, contentRef, context.onContentChange);\n  const timerRef = (0, import_react28.useRef)(0);\n  const searchRef = (0, import_react28.useRef)(\"\");\n  const pointerGraceTimerRef = (0, import_react28.useRef)(0);\n  const pointerGraceIntentRef = (0, import_react28.useRef)(null);\n  const pointerDirRef = (0, import_react28.useRef)(\"right\");\n  const lastPointerXRef = (0, import_react28.useRef)(0);\n  const ScrollLockWrapper = disableOutsideScroll ? Combination_default : import_react28.Fragment;\n  const scrollLockWrapperProps = disableOutsideScroll ? {\n    as: $5e63c961fc1ce211$export$8c6ed5c666ac1360,\n    allowPinchZoom: true\n  } : void 0;\n  const handleTypeaheadSearch = (key) => {\n    var _items$find, _items$find2;\n    const search = searchRef.current + key;\n    const items = getItems().filter(\n      (item) => !item.disabled\n    );\n    const currentItem = document.activeElement;\n    const currentMatch = (_items$find = items.find(\n      (item) => item.ref.current === currentItem\n    )) === null || _items$find === void 0 ? void 0 : _items$find.textValue;\n    const values = items.map(\n      (item) => item.textValue\n    );\n    const nextMatch = $6cc32821e9371a1c$var$getNextMatch(values, search, currentMatch);\n    const newItem = (_items$find2 = items.find(\n      (item) => item.textValue === nextMatch\n    )) === null || _items$find2 === void 0 ? void 0 : _items$find2.ref.current;\n    (function updateSearch(value) {\n      searchRef.current = value;\n      window.clearTimeout(timerRef.current);\n      if (value !== \"\")\n        timerRef.current = window.setTimeout(\n          () => updateSearch(\"\"),\n          1e3\n        );\n    })(search);\n    if (newItem)\n      setTimeout(\n        () => newItem.focus()\n      );\n  };\n  (0, import_react28.useEffect)(() => {\n    return () => window.clearTimeout(timerRef.current);\n  }, []);\n  $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c();\n  const isPointerMovingToSubmenu = (0, import_react28.useCallback)((event) => {\n    var _pointerGraceIntentRe, _pointerGraceIntentRe2;\n    const isMovingTowards = pointerDirRef.current === ((_pointerGraceIntentRe = pointerGraceIntentRef.current) === null || _pointerGraceIntentRe === void 0 ? void 0 : _pointerGraceIntentRe.side);\n    return isMovingTowards && $6cc32821e9371a1c$var$isPointerInGraceArea(event, (_pointerGraceIntentRe2 = pointerGraceIntentRef.current) === null || _pointerGraceIntentRe2 === void 0 ? void 0 : _pointerGraceIntentRe2.area);\n  }, []);\n  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuContentProvider, {\n    scope: __scopeMenu,\n    searchRef,\n    onItemEnter: (0, import_react28.useCallback)((event) => {\n      if (isPointerMovingToSubmenu(event))\n        event.preventDefault();\n    }, [\n      isPointerMovingToSubmenu\n    ]),\n    onItemLeave: (0, import_react28.useCallback)((event) => {\n      var _contentRef$current;\n      if (isPointerMovingToSubmenu(event))\n        return;\n      (_contentRef$current = contentRef.current) === null || _contentRef$current === void 0 || _contentRef$current.focus();\n      setCurrentItemId(null);\n    }, [\n      isPointerMovingToSubmenu\n    ]),\n    onTriggerLeave: (0, import_react28.useCallback)((event) => {\n      if (isPointerMovingToSubmenu(event))\n        event.preventDefault();\n    }, [\n      isPointerMovingToSubmenu\n    ]),\n    pointerGraceTimerRef,\n    onPointerGraceIntentChange: (0, import_react28.useCallback)((intent) => {\n      pointerGraceIntentRef.current = intent;\n    }, [])\n  }, /* @__PURE__ */ (0, import_react28.createElement)(ScrollLockWrapper, scrollLockWrapperProps, /* @__PURE__ */ (0, import_react28.createElement)($d3863c46a17e8a28$export$20e40289641fbbb6, {\n    asChild: true,\n    trapped: trapFocus,\n    onMountAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(onOpenAutoFocus, (event) => {\n      var _contentRef$current2;\n      event.preventDefault();\n      (_contentRef$current2 = contentRef.current) === null || _contentRef$current2 === void 0 || _contentRef$current2.focus();\n    }),\n    onUnmountAutoFocus: onCloseAutoFocus\n  }, /* @__PURE__ */ (0, import_react28.createElement)($5cb92bef7577960e$export$177fb62ff3ec1f22, {\n    asChild: true,\n    disableOutsidePointerEvents,\n    onEscapeKeyDown,\n    onPointerDownOutside,\n    onFocusOutside,\n    onInteractOutside,\n    onDismiss\n  }, /* @__PURE__ */ (0, import_react28.createElement)($d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9, _extends({\n    asChild: true\n  }, rovingFocusGroupScope, {\n    dir: rootContext.dir,\n    orientation: \"vertical\",\n    loop,\n    currentTabStopId: currentItemId,\n    onCurrentTabStopIdChange: setCurrentItemId,\n    onEntryFocus: (event) => {\n      if (!rootContext.isUsingKeyboardRef.current)\n        event.preventDefault();\n    }\n  }), /* @__PURE__ */ (0, import_react28.createElement)($cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2, _extends({\n    role: \"menu\",\n    \"aria-orientation\": \"vertical\",\n    \"data-state\": $6cc32821e9371a1c$var$getOpenState(context.open),\n    \"data-radix-menu-content\": \"\",\n    dir: rootContext.dir\n  }, popperScope, contentProps, {\n    ref: composedRefs,\n    style: {\n      outline: \"none\",\n      ...contentProps.style\n    },\n    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(contentProps.onKeyDown, (event) => {\n      const target = event.target;\n      const isKeyDownInside = target.closest(\"[data-radix-menu-content]\") === event.currentTarget;\n      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;\n      const isCharacterKey = event.key.length === 1;\n      if (isKeyDownInside) {\n        if (event.key === \"Tab\")\n          event.preventDefault();\n        if (!isModifierKey && isCharacterKey)\n          handleTypeaheadSearch(event.key);\n      }\n      const content = contentRef.current;\n      if (event.target !== content)\n        return;\n      if (!$6cc32821e9371a1c$var$FIRST_LAST_KEYS.includes(event.key))\n        return;\n      event.preventDefault();\n      const items = getItems().filter(\n        (item) => !item.disabled\n      );\n      const candidateNodes = items.map(\n        (item) => item.ref.current\n      );\n      if ($6cc32821e9371a1c$var$LAST_KEYS.includes(event.key))\n        candidateNodes.reverse();\n      $6cc32821e9371a1c$var$focusFirst(candidateNodes);\n    }),\n    onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlur, (event) => {\n      if (!event.currentTarget.contains(event.target)) {\n        window.clearTimeout(timerRef.current);\n        searchRef.current = \"\";\n      }\n    }),\n    onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, $6cc32821e9371a1c$var$whenMouse((event) => {\n      const target = event.target;\n      const pointerXHasChanged = lastPointerXRef.current !== event.clientX;\n      if (event.currentTarget.contains(target) && pointerXHasChanged) {\n        const newDir = event.clientX > lastPointerXRef.current ? \"right\" : \"left\";\n        pointerDirRef.current = newDir;\n        lastPointerXRef.current = event.clientX;\n      }\n    }))\n  })))))));\n});\nvar $6cc32821e9371a1c$export$22a631d1f72787bb = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {\n  const { __scopeMenu, ...groupProps } = props;\n  return /* @__PURE__ */ (0, import_react28.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({\n    role: \"group\"\n  }, groupProps, {\n    ref: forwardedRef\n  }));\n});\nvar $6cc32821e9371a1c$var$ITEM_NAME = \"MenuItem\";\nvar $6cc32821e9371a1c$var$ITEM_SELECT = \"menu.itemSelect\";\nvar $6cc32821e9371a1c$export$2ce376c2cc3355c8 = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {\n  const { disabled = false, onSelect, ...itemProps } = props;\n  const ref = (0, import_react28.useRef)(null);\n  const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$ITEM_NAME, props.__scopeMenu);\n  const contentContext = $6cc32821e9371a1c$var$useMenuContentContext($6cc32821e9371a1c$var$ITEM_NAME, props.__scopeMenu);\n  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);\n  const isPointerDownRef = (0, import_react28.useRef)(false);\n  const handleSelect = () => {\n    const menuItem = ref.current;\n    if (!disabled && menuItem) {\n      const itemSelectEvent = new CustomEvent($6cc32821e9371a1c$var$ITEM_SELECT, {\n        bubbles: true,\n        cancelable: true\n      });\n      menuItem.addEventListener(\n        $6cc32821e9371a1c$var$ITEM_SELECT,\n        (event) => onSelect === null || onSelect === void 0 ? void 0 : onSelect(event),\n        {\n          once: true\n        }\n      );\n      $8927f6f2acc4f386$export$6d1a0317bde7de7f(menuItem, itemSelectEvent);\n      if (itemSelectEvent.defaultPrevented)\n        isPointerDownRef.current = false;\n      else\n        rootContext.onClose();\n    }\n  };\n  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuItemImpl, _extends({}, itemProps, {\n    ref: composedRefs,\n    disabled,\n    onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, handleSelect),\n    onPointerDown: (event) => {\n      var _props$onPointerDown;\n      (_props$onPointerDown = props.onPointerDown) === null || _props$onPointerDown === void 0 || _props$onPointerDown.call(props, event);\n      isPointerDownRef.current = true;\n    },\n    onPointerUp: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerUp, (event) => {\n      var _event$currentTarget;\n      if (!isPointerDownRef.current)\n        (_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 || _event$currentTarget.click();\n    }),\n    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {\n      const isTypingAhead = contentContext.searchRef.current !== \"\";\n      if (disabled || isTypingAhead && event.key === \" \")\n        return;\n      if ($6cc32821e9371a1c$var$SELECTION_KEYS.includes(event.key)) {\n        event.currentTarget.click();\n        event.preventDefault();\n      }\n    })\n  }));\n});\nvar $6cc32821e9371a1c$var$MenuItemImpl = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {\n  const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;\n  const contentContext = $6cc32821e9371a1c$var$useMenuContentContext($6cc32821e9371a1c$var$ITEM_NAME, __scopeMenu);\n  const rovingFocusGroupScope = $6cc32821e9371a1c$var$useRovingFocusGroupScope(__scopeMenu);\n  const ref = (0, import_react28.useRef)(null);\n  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);\n  const [isFocused, setIsFocused] = (0, import_react28.useState)(false);\n  const [textContent, setTextContent] = (0, import_react28.useState)(\"\");\n  (0, import_react28.useEffect)(() => {\n    const menuItem = ref.current;\n    if (menuItem) {\n      var _menuItem$textContent;\n      setTextContent(((_menuItem$textContent = menuItem.textContent) !== null && _menuItem$textContent !== void 0 ? _menuItem$textContent : \"\").trim());\n    }\n  }, [\n    itemProps.children\n  ]);\n  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$Collection.ItemSlot, {\n    scope: __scopeMenu,\n    disabled,\n    textValue: textValue !== null && textValue !== void 0 ? textValue : textContent\n  }, /* @__PURE__ */ (0, import_react28.createElement)($d7bdfb9eb0fdf311$export$6d08773d2e66f8f2, _extends({\n    asChild: true\n  }, rovingFocusGroupScope, {\n    focusable: !disabled\n  }), /* @__PURE__ */ (0, import_react28.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({\n    role: \"menuitem\",\n    \"data-highlighted\": isFocused ? \"\" : void 0,\n    \"aria-disabled\": disabled || void 0,\n    \"data-disabled\": disabled ? \"\" : void 0\n  }, itemProps, {\n    ref: composedRefs,\n    onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, $6cc32821e9371a1c$var$whenMouse((event) => {\n      if (disabled)\n        contentContext.onItemLeave(event);\n      else {\n        contentContext.onItemEnter(event);\n        if (!event.defaultPrevented) {\n          const item = event.currentTarget;\n          item.focus();\n        }\n      }\n    })),\n    onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerLeave, $6cc32821e9371a1c$var$whenMouse(\n      (event) => contentContext.onItemLeave(event)\n    )),\n    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(\n      props.onFocus,\n      () => setIsFocused(true)\n    ),\n    onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(\n      props.onBlur,\n      () => setIsFocused(false)\n    )\n  }))));\n});\nvar $6cc32821e9371a1c$export$f6f243521332502d = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {\n  const { checked = false, onCheckedChange, ...checkboxItemProps } = props;\n  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$ItemIndicatorProvider, {\n    scope: props.__scopeMenu,\n    checked\n  }, /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$export$2ce376c2cc3355c8, _extends({\n    role: \"menuitemcheckbox\",\n    \"aria-checked\": $6cc32821e9371a1c$var$isIndeterminate(checked) ? \"mixed\" : checked\n  }, checkboxItemProps, {\n    ref: forwardedRef,\n    \"data-state\": $6cc32821e9371a1c$var$getCheckedState(checked),\n    onSelect: $e42e1063c40fb3ef$export$b9ecd428b558ff10(\n      checkboxItemProps.onSelect,\n      () => onCheckedChange === null || onCheckedChange === void 0 ? void 0 : onCheckedChange($6cc32821e9371a1c$var$isIndeterminate(checked) ? true : !checked),\n      {\n        checkForDefaultPrevented: false\n      }\n    )\n  })));\n});\nvar $6cc32821e9371a1c$var$RADIO_GROUP_NAME = \"MenuRadioGroup\";\nvar [$6cc32821e9371a1c$var$RadioGroupProvider, $6cc32821e9371a1c$var$useRadioGroupContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$RADIO_GROUP_NAME, {\n  value: void 0,\n  onValueChange: () => {\n  }\n});\nvar $6cc32821e9371a1c$export$ea2200c9eee416b3 = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {\n  const { value, onValueChange, ...groupProps } = props;\n  const handleValueChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onValueChange);\n  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$RadioGroupProvider, {\n    scope: props.__scopeMenu,\n    value,\n    onValueChange: handleValueChange\n  }, /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$export$22a631d1f72787bb, _extends({}, groupProps, {\n    ref: forwardedRef\n  })));\n});\nvar $6cc32821e9371a1c$var$RADIO_ITEM_NAME = \"MenuRadioItem\";\nvar $6cc32821e9371a1c$export$69bd225e9817f6d0 = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {\n  const { value, ...radioItemProps } = props;\n  const context = $6cc32821e9371a1c$var$useRadioGroupContext($6cc32821e9371a1c$var$RADIO_ITEM_NAME, props.__scopeMenu);\n  const checked = value === context.value;\n  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$ItemIndicatorProvider, {\n    scope: props.__scopeMenu,\n    checked\n  }, /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$export$2ce376c2cc3355c8, _extends({\n    role: \"menuitemradio\",\n    \"aria-checked\": checked\n  }, radioItemProps, {\n    ref: forwardedRef,\n    \"data-state\": $6cc32821e9371a1c$var$getCheckedState(checked),\n    onSelect: $e42e1063c40fb3ef$export$b9ecd428b558ff10(radioItemProps.onSelect, () => {\n      var _context$onValueChang;\n      return (_context$onValueChang = context.onValueChange) === null || _context$onValueChang === void 0 ? void 0 : _context$onValueChang.call(context, value);\n    }, {\n      checkForDefaultPrevented: false\n    })\n  })));\n});\nvar $6cc32821e9371a1c$var$ITEM_INDICATOR_NAME = \"MenuItemIndicator\";\nvar [$6cc32821e9371a1c$var$ItemIndicatorProvider, $6cc32821e9371a1c$var$useItemIndicatorContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$ITEM_INDICATOR_NAME, {\n  checked: false\n});\nvar $6cc32821e9371a1c$export$a2593e23056970a3 = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {\n  const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;\n  const indicatorContext = $6cc32821e9371a1c$var$useItemIndicatorContext($6cc32821e9371a1c$var$ITEM_INDICATOR_NAME, __scopeMenu);\n  return /* @__PURE__ */ (0, import_react28.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {\n    present: forceMount || $6cc32821e9371a1c$var$isIndeterminate(indicatorContext.checked) || indicatorContext.checked === true\n  }, /* @__PURE__ */ (0, import_react28.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({}, itemIndicatorProps, {\n    ref: forwardedRef,\n    \"data-state\": $6cc32821e9371a1c$var$getCheckedState(indicatorContext.checked)\n  })));\n});\nvar $6cc32821e9371a1c$export$1cec7dcdd713e220 = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {\n  const { __scopeMenu, ...separatorProps } = props;\n  return /* @__PURE__ */ (0, import_react28.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({\n    role: \"separator\",\n    \"aria-orientation\": \"horizontal\"\n  }, separatorProps, {\n    ref: forwardedRef\n  }));\n});\nvar $6cc32821e9371a1c$export$bcdda4773debf5fa = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {\n  const { __scopeMenu, ...arrowProps } = props;\n  const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);\n  return /* @__PURE__ */ (0, import_react28.createElement)($cf1ac5d9fe0e8206$export$21b07c8f274aebd5, _extends({}, popperScope, arrowProps, {\n    ref: forwardedRef\n  }));\n});\nvar $6cc32821e9371a1c$var$SUB_NAME = \"MenuSub\";\nvar [$6cc32821e9371a1c$var$MenuSubProvider, $6cc32821e9371a1c$var$useMenuSubContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$SUB_NAME);\nvar $6cc32821e9371a1c$export$71bdb9d1e2909932 = (props) => {\n  const { __scopeMenu, children, open = false, onOpenChange } = props;\n  const parentMenuContext = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$SUB_NAME, __scopeMenu);\n  const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);\n  const [trigger2, setTrigger] = (0, import_react28.useState)(null);\n  const [content, setContent] = (0, import_react28.useState)(null);\n  const handleOpenChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onOpenChange);\n  (0, import_react28.useEffect)(() => {\n    if (parentMenuContext.open === false)\n      handleOpenChange(false);\n    return () => handleOpenChange(false);\n  }, [\n    parentMenuContext.open,\n    handleOpenChange\n  ]);\n  return /* @__PURE__ */ (0, import_react28.createElement)($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9, popperScope, /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuProvider, {\n    scope: __scopeMenu,\n    open,\n    onOpenChange: handleOpenChange,\n    content,\n    onContentChange: setContent\n  }, /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuSubProvider, {\n    scope: __scopeMenu,\n    contentId: $1746a345f3d73bb7$export$f680877a34711e37(),\n    triggerId: $1746a345f3d73bb7$export$f680877a34711e37(),\n    trigger: trigger2,\n    onTriggerChange: setTrigger\n  }, children)));\n};\nvar $6cc32821e9371a1c$var$SUB_TRIGGER_NAME = \"MenuSubTrigger\";\nvar $6cc32821e9371a1c$export$5fbbb3ba7297405f = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {\n  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$SUB_TRIGGER_NAME, props.__scopeMenu);\n  const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$SUB_TRIGGER_NAME, props.__scopeMenu);\n  const subContext = $6cc32821e9371a1c$var$useMenuSubContext($6cc32821e9371a1c$var$SUB_TRIGGER_NAME, props.__scopeMenu);\n  const contentContext = $6cc32821e9371a1c$var$useMenuContentContext($6cc32821e9371a1c$var$SUB_TRIGGER_NAME, props.__scopeMenu);\n  const openTimerRef = (0, import_react28.useRef)(null);\n  const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;\n  const scope = {\n    __scopeMenu: props.__scopeMenu\n  };\n  const clearOpenTimer = (0, import_react28.useCallback)(() => {\n    if (openTimerRef.current)\n      window.clearTimeout(openTimerRef.current);\n    openTimerRef.current = null;\n  }, []);\n  (0, import_react28.useEffect)(\n    () => clearOpenTimer,\n    [\n      clearOpenTimer\n    ]\n  );\n  (0, import_react28.useEffect)(() => {\n    const pointerGraceTimer = pointerGraceTimerRef.current;\n    return () => {\n      window.clearTimeout(pointerGraceTimer);\n      onPointerGraceIntentChange(null);\n    };\n  }, [\n    pointerGraceTimerRef,\n    onPointerGraceIntentChange\n  ]);\n  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$export$9fa5ebd18bee4d43, _extends({\n    asChild: true\n  }, scope), /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuItemImpl, _extends({\n    id: subContext.triggerId,\n    \"aria-haspopup\": \"menu\",\n    \"aria-expanded\": context.open,\n    \"aria-controls\": subContext.contentId,\n    \"data-state\": $6cc32821e9371a1c$var$getOpenState(context.open)\n  }, props, {\n    ref: $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, subContext.onTriggerChange),\n    onClick: (event) => {\n      var _props$onClick;\n      (_props$onClick = props.onClick) === null || _props$onClick === void 0 || _props$onClick.call(props, event);\n      if (props.disabled || event.defaultPrevented)\n        return;\n      event.currentTarget.focus();\n      if (!context.open)\n        context.onOpenChange(true);\n    },\n    onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, $6cc32821e9371a1c$var$whenMouse((event) => {\n      contentContext.onItemEnter(event);\n      if (event.defaultPrevented)\n        return;\n      if (!props.disabled && !context.open && !openTimerRef.current) {\n        contentContext.onPointerGraceIntentChange(null);\n        openTimerRef.current = window.setTimeout(() => {\n          context.onOpenChange(true);\n          clearOpenTimer();\n        }, 100);\n      }\n    })),\n    onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerLeave, $6cc32821e9371a1c$var$whenMouse((event) => {\n      var _context$content;\n      clearOpenTimer();\n      const contentRect = (_context$content = context.content) === null || _context$content === void 0 ? void 0 : _context$content.getBoundingClientRect();\n      if (contentRect) {\n        var _context$content2;\n        const side = (_context$content2 = context.content) === null || _context$content2 === void 0 ? void 0 : _context$content2.dataset.side;\n        const rightSide = side === \"right\";\n        const bleed = rightSide ? -5 : 5;\n        const contentNearEdge = contentRect[rightSide ? \"left\" : \"right\"];\n        const contentFarEdge = contentRect[rightSide ? \"right\" : \"left\"];\n        contentContext.onPointerGraceIntentChange({\n          area: [\n            {\n              x: event.clientX + bleed,\n              y: event.clientY\n            },\n            {\n              x: contentNearEdge,\n              y: contentRect.top\n            },\n            {\n              x: contentFarEdge,\n              y: contentRect.top\n            },\n            {\n              x: contentFarEdge,\n              y: contentRect.bottom\n            },\n            {\n              x: contentNearEdge,\n              y: contentRect.bottom\n            }\n          ],\n          side\n        });\n        window.clearTimeout(pointerGraceTimerRef.current);\n        pointerGraceTimerRef.current = window.setTimeout(\n          () => contentContext.onPointerGraceIntentChange(null),\n          300\n        );\n      } else {\n        contentContext.onTriggerLeave(event);\n        if (event.defaultPrevented)\n          return;\n        contentContext.onPointerGraceIntentChange(null);\n      }\n    })),\n    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {\n      const isTypingAhead = contentContext.searchRef.current !== \"\";\n      if (props.disabled || isTypingAhead && event.key === \" \")\n        return;\n      if ($6cc32821e9371a1c$var$SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {\n        var _context$content3;\n        context.onOpenChange(true);\n        (_context$content3 = context.content) === null || _context$content3 === void 0 || _context$content3.focus();\n        event.preventDefault();\n      }\n    })\n  })));\n});\nvar $6cc32821e9371a1c$var$SUB_CONTENT_NAME = \"MenuSubContent\";\nvar $6cc32821e9371a1c$export$e7142ab31822bde6 = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {\n  const portalContext = $6cc32821e9371a1c$var$usePortalContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);\n  const { forceMount = portalContext.forceMount, ...subContentProps } = props;\n  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);\n  const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);\n  const subContext = $6cc32821e9371a1c$var$useMenuSubContext($6cc32821e9371a1c$var$SUB_CONTENT_NAME, props.__scopeMenu);\n  const ref = (0, import_react28.useRef)(null);\n  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);\n  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$Collection.Provider, {\n    scope: props.__scopeMenu\n  }, /* @__PURE__ */ (0, import_react28.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {\n    present: forceMount || context.open\n  }, /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$Collection.Slot, {\n    scope: props.__scopeMenu\n  }, /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuContentImpl, _extends({\n    id: subContext.contentId,\n    \"aria-labelledby\": subContext.triggerId\n  }, subContentProps, {\n    ref: composedRefs,\n    align: \"start\",\n    side: rootContext.dir === \"rtl\" ? \"left\" : \"right\",\n    disableOutsidePointerEvents: false,\n    disableOutsideScroll: false,\n    trapFocus: false,\n    onOpenAutoFocus: (event) => {\n      var _ref$current;\n      if (rootContext.isUsingKeyboardRef.current)\n        (_ref$current = ref.current) === null || _ref$current === void 0 || _ref$current.focus();\n      event.preventDefault();\n    },\n    onCloseAutoFocus: (event) => event.preventDefault(),\n    onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocusOutside, (event) => {\n      if (event.target !== subContext.trigger)\n        context.onOpenChange(false);\n    }),\n    onEscapeKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onEscapeKeyDown, rootContext.onClose),\n    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {\n      const isKeyDownInside = event.currentTarget.contains(event.target);\n      const isCloseKey = $6cc32821e9371a1c$var$SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);\n      if (isKeyDownInside && isCloseKey) {\n        var _subContext$trigger;\n        context.onOpenChange(false);\n        (_subContext$trigger = subContext.trigger) === null || _subContext$trigger === void 0 || _subContext$trigger.focus();\n        event.preventDefault();\n      }\n    })\n  })))));\n});\nfunction $6cc32821e9371a1c$var$getOpenState(open) {\n  return open ? \"open\" : \"closed\";\n}\nfunction $6cc32821e9371a1c$var$isIndeterminate(checked) {\n  return checked === \"indeterminate\";\n}\nfunction $6cc32821e9371a1c$var$getCheckedState(checked) {\n  return $6cc32821e9371a1c$var$isIndeterminate(checked) ? \"indeterminate\" : checked ? \"checked\" : \"unchecked\";\n}\nfunction $6cc32821e9371a1c$var$focusFirst(candidates) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)\n      return;\n    candidate.focus();\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)\n      return;\n  }\n}\nfunction $6cc32821e9371a1c$var$wrapArray(array, startIndex) {\n  return array.map(\n    (_3, index2) => array[(startIndex + index2) % array.length]\n  );\n}\nfunction $6cc32821e9371a1c$var$getNextMatch(values, search, currentMatch) {\n  const isRepeated = search.length > 1 && Array.from(search).every(\n    (char) => char === search[0]\n  );\n  const normalizedSearch = isRepeated ? search[0] : search;\n  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;\n  let wrappedValues = $6cc32821e9371a1c$var$wrapArray(values, Math.max(currentMatchIndex, 0));\n  const excludeCurrentMatch = normalizedSearch.length === 1;\n  if (excludeCurrentMatch)\n    wrappedValues = wrappedValues.filter(\n      (v6) => v6 !== currentMatch\n    );\n  const nextMatch = wrappedValues.find(\n    (value) => value.toLowerCase().startsWith(normalizedSearch.toLowerCase())\n  );\n  return nextMatch !== currentMatch ? nextMatch : void 0;\n}\nfunction $6cc32821e9371a1c$var$isPointInPolygon(point, polygon) {\n  const { x: x5, y: y6 } = point;\n  let inside = false;\n  for (let i4 = 0, j4 = polygon.length - 1; i4 < polygon.length; j4 = i4++) {\n    const xi = polygon[i4].x;\n    const yi = polygon[i4].y;\n    const xj = polygon[j4].x;\n    const yj = polygon[j4].y;\n    const intersect = yi > y6 !== yj > y6 && x5 < (xj - xi) * (y6 - yi) / (yj - yi) + xi;\n    if (intersect)\n      inside = !inside;\n  }\n  return inside;\n}\nfunction $6cc32821e9371a1c$var$isPointerInGraceArea(event, area) {\n  if (!area)\n    return false;\n  const cursorPos = {\n    x: event.clientX,\n    y: event.clientY\n  };\n  return $6cc32821e9371a1c$var$isPointInPolygon(cursorPos, area);\n}\nfunction $6cc32821e9371a1c$var$whenMouse(handler) {\n  return (event) => event.pointerType === \"mouse\" ? handler(event) : void 0;\n}\nvar $6cc32821e9371a1c$export$be92b6f5f03c0fe9 = $6cc32821e9371a1c$export$d9b273488cd8ce6f;\nvar $6cc32821e9371a1c$export$b688253958b8dfe7 = $6cc32821e9371a1c$export$9fa5ebd18bee4d43;\nvar $6cc32821e9371a1c$export$602eac185826482c = $6cc32821e9371a1c$export$793392f970497feb;\nvar $6cc32821e9371a1c$export$7c6e2c02157bb7d2 = $6cc32821e9371a1c$export$479f0f2f71193efe;\nvar $6cc32821e9371a1c$export$6d08773d2e66f8f2 = $6cc32821e9371a1c$export$2ce376c2cc3355c8;\nvar $6cc32821e9371a1c$export$16ce288f89fa631c = $6cc32821e9371a1c$export$f6f243521332502d;\nvar $6cc32821e9371a1c$export$a98f0dcb43a68a25 = $6cc32821e9371a1c$export$ea2200c9eee416b3;\nvar $6cc32821e9371a1c$export$371ab307eab489c0 = $6cc32821e9371a1c$export$69bd225e9817f6d0;\nvar $6cc32821e9371a1c$export$c3468e2714d175fa = $6cc32821e9371a1c$export$a2593e23056970a3;\nvar $6cc32821e9371a1c$export$1ff3c3f08ae963c0 = $6cc32821e9371a1c$export$1cec7dcdd713e220;\nvar $6cc32821e9371a1c$export$21b07c8f274aebd5 = $6cc32821e9371a1c$export$bcdda4773debf5fa;\nvar $6cc32821e9371a1c$export$d7a01e11500dfb6f = $6cc32821e9371a1c$export$71bdb9d1e2909932;\nvar $6cc32821e9371a1c$export$2ea8a7a591ac5eac = $6cc32821e9371a1c$export$5fbbb3ba7297405f;\nvar $6cc32821e9371a1c$export$6d4de93b380beddf = $6cc32821e9371a1c$export$e7142ab31822bde6;\n\n// node_modules/@radix-ui/react-context-menu/dist/index.module.js\nvar $1b0217ee4a91d156$var$CONTEXT_MENU_NAME = \"ContextMenu\";\nvar [$1b0217ee4a91d156$var$createContextMenuContext, $1b0217ee4a91d156$export$1059331f43ddcc82] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($1b0217ee4a91d156$var$CONTEXT_MENU_NAME, [\n  $6cc32821e9371a1c$export$4027731b685e72eb\n]);\nvar $1b0217ee4a91d156$var$useMenuScope = $6cc32821e9371a1c$export$4027731b685e72eb();\nvar [$1b0217ee4a91d156$var$ContextMenuProvider, $1b0217ee4a91d156$var$useContextMenuContext] = $1b0217ee4a91d156$var$createContextMenuContext($1b0217ee4a91d156$var$CONTEXT_MENU_NAME);\nvar $1b0217ee4a91d156$export$8dc6765e8be191c7 = (props) => {\n  const { __scopeContextMenu, children, onOpenChange, dir, modal = true } = props;\n  const [open1, setOpen] = (0, import_react29.useState)(false);\n  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);\n  const handleOpenChangeProp = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onOpenChange);\n  const handleOpenChange = (0, import_react29.useCallback)((open) => {\n    setOpen(open);\n    handleOpenChangeProp(open);\n  }, [\n    handleOpenChangeProp\n  ]);\n  return /* @__PURE__ */ (0, import_react29.createElement)($1b0217ee4a91d156$var$ContextMenuProvider, {\n    scope: __scopeContextMenu,\n    open: open1,\n    onOpenChange: handleOpenChange,\n    modal\n  }, /* @__PURE__ */ (0, import_react29.createElement)($6cc32821e9371a1c$export$be92b6f5f03c0fe9, _extends({}, menuScope, {\n    dir,\n    open: open1,\n    onOpenChange: handleOpenChange,\n    modal\n  }), children));\n};\nvar $1b0217ee4a91d156$var$TRIGGER_NAME = \"ContextMenuTrigger\";\nvar $1b0217ee4a91d156$export$be6fc7b1d5b0beb9 = /* @__PURE__ */ (0, import_react29.forwardRef)((props, forwardedRef) => {\n  const { __scopeContextMenu, disabled = false, ...triggerProps } = props;\n  const context = $1b0217ee4a91d156$var$useContextMenuContext($1b0217ee4a91d156$var$TRIGGER_NAME, __scopeContextMenu);\n  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);\n  const pointRef = (0, import_react29.useRef)({\n    x: 0,\n    y: 0\n  });\n  const virtualRef = (0, import_react29.useRef)({\n    getBoundingClientRect: () => DOMRect.fromRect({\n      width: 0,\n      height: 0,\n      ...pointRef.current\n    })\n  });\n  const longPressTimerRef = (0, import_react29.useRef)(0);\n  const clearLongPress = (0, import_react29.useCallback)(\n    () => window.clearTimeout(longPressTimerRef.current),\n    []\n  );\n  const handleOpen = (event) => {\n    pointRef.current = {\n      x: event.clientX,\n      y: event.clientY\n    };\n    context.onOpenChange(true);\n  };\n  (0, import_react29.useEffect)(\n    () => clearLongPress,\n    [\n      clearLongPress\n    ]\n  );\n  (0, import_react29.useEffect)(\n    () => void (disabled && clearLongPress()),\n    [\n      disabled,\n      clearLongPress\n    ]\n  );\n  return /* @__PURE__ */ (0, import_react29.createElement)(import_react29.Fragment, null, /* @__PURE__ */ (0, import_react29.createElement)($6cc32821e9371a1c$export$b688253958b8dfe7, _extends({}, menuScope, {\n    virtualRef\n  })), /* @__PURE__ */ (0, import_react29.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({\n    \"data-state\": context.open ? \"open\" : \"closed\",\n    \"data-disabled\": disabled ? \"\" : void 0\n  }, triggerProps, {\n    ref: forwardedRef,\n    style: {\n      WebkitTouchCallout: \"none\",\n      ...props.style\n    },\n    onContextMenu: disabled ? props.onContextMenu : $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onContextMenu, (event) => {\n      clearLongPress();\n      handleOpen(event);\n      event.preventDefault();\n    }),\n    onPointerDown: disabled ? props.onPointerDown : $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDown, $1b0217ee4a91d156$var$whenTouchOrPen((event) => {\n      clearLongPress();\n      longPressTimerRef.current = window.setTimeout(\n        () => handleOpen(event),\n        700\n      );\n    })),\n    onPointerMove: disabled ? props.onPointerMove : $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, $1b0217ee4a91d156$var$whenTouchOrPen(clearLongPress)),\n    onPointerCancel: disabled ? props.onPointerCancel : $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerCancel, $1b0217ee4a91d156$var$whenTouchOrPen(clearLongPress)),\n    onPointerUp: disabled ? props.onPointerUp : $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerUp, $1b0217ee4a91d156$var$whenTouchOrPen(clearLongPress))\n  })));\n});\nvar $1b0217ee4a91d156$export$14afd0be83e45060 = (props) => {\n  const { __scopeContextMenu, ...portalProps } = props;\n  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);\n  return /* @__PURE__ */ (0, import_react29.createElement)($6cc32821e9371a1c$export$602eac185826482c, _extends({}, menuScope, portalProps));\n};\nvar $1b0217ee4a91d156$var$CONTENT_NAME = \"ContextMenuContent\";\nvar $1b0217ee4a91d156$export$572205900c9369e = /* @__PURE__ */ (0, import_react29.forwardRef)((props, forwardedRef) => {\n  const { __scopeContextMenu, ...contentProps } = props;\n  const context = $1b0217ee4a91d156$var$useContextMenuContext($1b0217ee4a91d156$var$CONTENT_NAME, __scopeContextMenu);\n  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);\n  const hasInteractedOutsideRef = (0, import_react29.useRef)(false);\n  return /* @__PURE__ */ (0, import_react29.createElement)($6cc32821e9371a1c$export$7c6e2c02157bb7d2, _extends({}, menuScope, contentProps, {\n    ref: forwardedRef,\n    side: \"right\",\n    sideOffset: 2,\n    align: \"start\",\n    onCloseAutoFocus: (event) => {\n      var _props$onCloseAutoFoc;\n      (_props$onCloseAutoFoc = props.onCloseAutoFocus) === null || _props$onCloseAutoFoc === void 0 || _props$onCloseAutoFoc.call(props, event);\n      if (!event.defaultPrevented && hasInteractedOutsideRef.current)\n        event.preventDefault();\n      hasInteractedOutsideRef.current = false;\n    },\n    onInteractOutside: (event) => {\n      var _props$onInteractOuts;\n      (_props$onInteractOuts = props.onInteractOutside) === null || _props$onInteractOuts === void 0 || _props$onInteractOuts.call(props, event);\n      if (!event.defaultPrevented && !context.modal)\n        hasInteractedOutsideRef.current = true;\n    },\n    style: {\n      ...props.style,\n      [\"--radix-context-menu-content-transform-origin\"]: \"var(--radix-popper-transform-origin)\"\n    }\n  }));\n});\nvar $1b0217ee4a91d156$export$16a26dc176a49100 = /* @__PURE__ */ (0, import_react29.forwardRef)((props, forwardedRef) => {\n  const { __scopeContextMenu, ...itemProps } = props;\n  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);\n  return /* @__PURE__ */ (0, import_react29.createElement)($6cc32821e9371a1c$export$6d08773d2e66f8f2, _extends({}, menuScope, itemProps, {\n    ref: forwardedRef\n  }));\n});\nvar $1b0217ee4a91d156$export$f47d0a58228a61e2 = /* @__PURE__ */ (0, import_react29.forwardRef)((props, forwardedRef) => {\n  const { __scopeContextMenu, ...arrowProps } = props;\n  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);\n  return /* @__PURE__ */ (0, import_react29.createElement)($6cc32821e9371a1c$export$21b07c8f274aebd5, _extends({}, menuScope, arrowProps, {\n    ref: forwardedRef\n  }));\n});\nvar $1b0217ee4a91d156$export$5bc21d1c00c4b201 = (props) => {\n  const { __scopeContextMenu, children, onOpenChange, open: openProp, defaultOpen } = props;\n  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);\n  const [open, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange\n  });\n  return /* @__PURE__ */ (0, import_react29.createElement)($6cc32821e9371a1c$export$d7a01e11500dfb6f, _extends({}, menuScope, {\n    open,\n    onOpenChange: setOpen\n  }), children);\n};\nvar $1b0217ee4a91d156$export$30b2b5c64556d316 = /* @__PURE__ */ (0, import_react29.forwardRef)((props, forwardedRef) => {\n  const { __scopeContextMenu, ...triggerItemProps } = props;\n  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);\n  return /* @__PURE__ */ (0, import_react29.createElement)($6cc32821e9371a1c$export$2ea8a7a591ac5eac, _extends({}, menuScope, triggerItemProps, {\n    ref: forwardedRef\n  }));\n});\nvar $1b0217ee4a91d156$export$2c967063bd2dc512 = /* @__PURE__ */ (0, import_react29.forwardRef)((props, forwardedRef) => {\n  const { __scopeContextMenu, ...subContentProps } = props;\n  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);\n  return /* @__PURE__ */ (0, import_react29.createElement)($6cc32821e9371a1c$export$6d4de93b380beddf, _extends({}, menuScope, subContentProps, {\n    ref: forwardedRef,\n    style: {\n      ...props.style,\n      [\"--radix-context-menu-content-transform-origin\"]: \"var(--radix-popper-transform-origin)\"\n    }\n  }));\n});\nfunction $1b0217ee4a91d156$var$whenTouchOrPen(handler) {\n  return (event) => event.pointerType !== \"mouse\" ? handler(event) : void 0;\n}\nvar $1b0217ee4a91d156$export$be92b6f5f03c0fe9 = $1b0217ee4a91d156$export$8dc6765e8be191c7;\nvar $1b0217ee4a91d156$export$41fb9f06171c75f4 = $1b0217ee4a91d156$export$be6fc7b1d5b0beb9;\nvar $1b0217ee4a91d156$export$602eac185826482c = $1b0217ee4a91d156$export$14afd0be83e45060;\nvar $1b0217ee4a91d156$export$7c6e2c02157bb7d2 = $1b0217ee4a91d156$export$572205900c9369e;\nvar $1b0217ee4a91d156$export$d7a01e11500dfb6f = $1b0217ee4a91d156$export$5bc21d1c00c4b201;\nvar $1b0217ee4a91d156$export$2ea8a7a591ac5eac = $1b0217ee4a91d156$export$30b2b5c64556d316;\nvar $1b0217ee4a91d156$export$6d4de93b380beddf = $1b0217ee4a91d156$export$2c967063bd2dc512;\n\n// node_modules/@radix-ui/react-icons/dist/react-icons.esm.js\nvar import_react30 = require(\"react\");\nfunction _objectWithoutPropertiesLoose2(source, excluded) {\n  if (source == null)\n    return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i4;\n  for (i4 = 0; i4 < sourceKeys.length; i4++) {\n    key = sourceKeys[i4];\n    if (excluded.indexOf(key) >= 0)\n      continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nvar _excluded$3 = [\"color\"];\nvar AlignBottomIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$3);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M9 3C9 2.44772 8.55229 2 8 2H7C6.44772 2 6 2.44772 6 3L6 14H1.5C1.22386 14 1 14.2239 1 14.5C1 14.7761 1.22386 15 1.5 15L6 15H9H13.5C13.7761 15 14 14.7761 14 14.5C14 14.2239 13.7761 14 13.5 14H9V3Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$4 = [\"color\"];\nvar AlignCenterHorizontallyIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$4);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M1.99988 6C1.44759 6 0.999877 6.44772 0.999877 7L0.999877 8C0.999877 8.55228 1.44759 9 1.99988 9L6.99988 9L6.99988 13.5C6.99988 13.7761 7.22374 14 7.49988 14C7.77602 14 7.99988 13.7761 7.99988 13.5L7.99988 9L12.9999 9C13.5522 9 13.9999 8.55228 13.9999 8L13.9999 7C13.9999 6.44772 13.5522 6 12.9999 6L7.99988 6L7.99988 1.5C7.99988 1.22386 7.77602 1 7.49988 1C7.22373 1 6.99988 1.22386 6.99988 1.5L6.99988 6L1.99988 6Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$5 = [\"color\"];\nvar AlignCenterVerticallyIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$5);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M6.99988 1C6.44759 1 5.99988 1.44772 5.99988 2V7H1.49988C1.22374 7 0.999878 7.22386 0.999878 7.5C0.999878 7.77614 1.22374 8 1.49988 8H5.99988V13C5.99988 13.5523 6.44759 14 6.99988 14H7.99988C8.55216 14 8.99988 13.5523 8.99988 13V8H13.4999C13.776 8 13.9999 7.77614 13.9999 7.5C13.9999 7.22386 13.776 7 13.4999 7H8.99988V2C8.99988 1.44772 8.55216 1 7.99988 1L6.99988 1Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$6 = [\"color\"];\nvar AlignLeftIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$6);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M0.499995 0.999995C0.223855 0.999995 -5.58458e-07 1.22385 -5.46388e-07 1.49999L-2.18554e-08 13.4999C-9.78492e-09 13.776 0.223855 13.9999 0.499995 13.9999C0.776136 13.9999 0.999991 13.776 0.999991 13.4999L0.999991 8.99993L12 8.99993C12.5523 8.99993 13 8.55222 13 7.99993L13 6.99994C13 6.44766 12.5523 5.99995 12 5.99995L0.999991 5.99995L0.999991 1.49999C0.999991 1.22385 0.776135 0.999995 0.499995 0.999995Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$7 = [\"color\"];\nvar AlignRightIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$7);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M14.4999 1C14.2237 1 13.9999 1.22386 13.9999 1.5L13.9999 6L2.99988 6C2.44759 6 1.99988 6.44772 1.99988 7L1.99988 8C1.99988 8.55228 2.44759 9 2.99988 9L13.9999 9L13.9999 13.5C13.9999 13.7761 14.2237 14 14.4999 14C14.776 14 14.9999 13.7761 14.9999 13.5L14.9999 9L14.9999 6L14.9999 1.5C14.9999 1.22386 14.776 1 14.4999 1Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$8 = [\"color\"];\nvar AlignTopIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$8);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M1.5 0C1.22386 0 1 0.223858 1 0.5C1 0.776142 1.22386 1 1.5 1H6V12C6 12.5523 6.44772 13 7 13H8C8.55228 13 9 12.5523 9 12V1H13.5C13.7761 1 14 0.776142 14 0.5C14 0.223858 13.7761 0 13.5 0H9H6H1.5Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$a = [\"color\"];\nvar AngleIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$a);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M8.8914 2.1937C9.1158 2.35464 9.16725 2.66701 9.00631 2.89141L2.47388 12H13.5C13.7761 12 14 12.2239 14 12.5C14 12.7762 13.7761 13 13.5 13H1.5C1.31254 13 1.14082 12.8952 1.0552 12.7284C0.969578 12.5616 0.984438 12.361 1.09369 12.2086L8.19369 2.30862C8.35462 2.08422 8.667 2.03277 8.8914 2.1937ZM11.1 6.50001C11.1 6.22387 11.3238 6.00001 11.6 6.00001C11.8761 6.00001 12.1 6.22387 12.1 6.50001C12.1 6.77615 11.8761 7.00001 11.6 7.00001C11.3238 7.00001 11.1 6.77615 11.1 6.50001ZM10.4 4.00001C10.1239 4.00001 9.90003 4.22387 9.90003 4.50001C9.90003 4.77615 10.1239 5.00001 10.4 5.00001C10.6762 5.00001 10.9 4.77615 10.9 4.50001C10.9 4.22387 10.6762 4.00001 10.4 4.00001ZM12.1 8.50001C12.1 8.22387 12.3238 8.00001 12.6 8.00001C12.8761 8.00001 13.1 8.22387 13.1 8.50001C13.1 8.77615 12.8761 9.00001 12.6 9.00001C12.3238 9.00001 12.1 8.77615 12.1 8.50001ZM13.4 10C13.1239 10 12.9 10.2239 12.9 10.5C12.9 10.7761 13.1239 11 13.4 11C13.6762 11 13.9 10.7761 13.9 10.5C13.9 10.2239 13.6762 10 13.4 10Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$e = [\"color\"];\nvar ArrowDownIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$e);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M7.5 2C7.77614 2 8 2.22386 8 2.5L8 11.2929L11.1464 8.14645C11.3417 7.95118 11.6583 7.95118 11.8536 8.14645C12.0488 8.34171 12.0488 8.65829 11.8536 8.85355L7.85355 12.8536C7.75979 12.9473 7.63261 13 7.5 13C7.36739 13 7.24021 12.9473 7.14645 12.8536L3.14645 8.85355C2.95118 8.65829 2.95118 8.34171 3.14645 8.14645C3.34171 7.95118 3.65829 7.95118 3.85355 8.14645L7 11.2929L7 2.5C7 2.22386 7.22386 2 7.5 2Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$i = [\"color\"];\nvar ArrowTopRightIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$i);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M3.64645 11.3536C3.45118 11.1583 3.45118 10.8417 3.64645 10.6465L10.2929 4L6 4C5.72386 4 5.5 3.77614 5.5 3.5C5.5 3.22386 5.72386 3 6 3L11.5 3C11.6326 3 11.7598 3.05268 11.8536 3.14645C11.9473 3.24022 12 3.36739 12 3.5L12 9.00001C12 9.27615 11.7761 9.50001 11.5 9.50001C11.2239 9.50001 11 9.27615 11 9.00001V4.70711L4.35355 11.3536C4.15829 11.5488 3.84171 11.5488 3.64645 11.3536Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$j = [\"color\"];\nvar ArrowUpIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$j);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M7.14645 2.14645C7.34171 1.95118 7.65829 1.95118 7.85355 2.14645L11.8536 6.14645C12.0488 6.34171 12.0488 6.65829 11.8536 6.85355C11.6583 7.04882 11.3417 7.04882 11.1464 6.85355L8 3.70711L8 12.5C8 12.7761 7.77614 13 7.5 13C7.22386 13 7 12.7761 7 12.5L7 3.70711L3.85355 6.85355C3.65829 7.04882 3.34171 7.04882 3.14645 6.85355C2.95118 6.65829 2.95118 6.34171 3.14645 6.14645L7.14645 2.14645Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$k = [\"color\"];\nvar AspectRatioIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$k);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M2.5 2H12.5C12.7761 2 13 2.22386 13 2.5V12.5C13 12.7761 12.7761 13 12.5 13H2.5C2.22386 13 2 12.7761 2 12.5V2.5C2 2.22386 2.22386 2 2.5 2ZM1 2.5C1 1.67157 1.67157 1 2.5 1H12.5C13.3284 1 14 1.67157 14 2.5V12.5C14 13.3284 13.3284 14 12.5 14H2.5C1.67157 14 1 13.3284 1 12.5V2.5ZM7.5 4C7.77614 4 8 3.77614 8 3.5C8 3.22386 7.77614 3 7.5 3C7.22386 3 7 3.22386 7 3.5C7 3.77614 7.22386 4 7.5 4ZM8 5.5C8 5.77614 7.77614 6 7.5 6C7.22386 6 7 5.77614 7 5.5C7 5.22386 7.22386 5 7.5 5C7.77614 5 8 5.22386 8 5.5ZM7.5 8C7.77614 8 8 7.77614 8 7.5C8 7.22386 7.77614 7 7.5 7C7.22386 7 7 7.22386 7 7.5C7 7.77614 7.22386 8 7.5 8ZM10 7.5C10 7.77614 9.77614 8 9.5 8C9.22386 8 9 7.77614 9 7.5C9 7.22386 9.22386 7 9.5 7C9.77614 7 10 7.22386 10 7.5ZM11.5 8C11.7761 8 12 7.77614 12 7.5C12 7.22386 11.7761 7 11.5 7C11.2239 7 11 7.22386 11 7.5C11 7.77614 11.2239 8 11.5 8Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$F = [\"color\"];\nvar BoxIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$F);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M12.5 2H2.5C2.22386 2 2 2.22386 2 2.5V12.5C2 12.7761 2.22386 13 2.5 13H12.5C12.7761 13 13 12.7761 13 12.5V2.5C13 2.22386 12.7761 2 12.5 2ZM2.5 1C1.67157 1 1 1.67157 1 2.5V12.5C1 13.3284 1.67157 14 2.5 14H12.5C13.3284 14 14 13.3284 14 12.5V2.5C14 1.67157 13.3284 1 12.5 1H2.5Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$T = [\"color\"];\nvar CheckIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$T);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M11.4669 3.72684C11.7558 3.91574 11.8369 4.30308 11.648 4.59198L7.39799 11.092C7.29783 11.2452 7.13556 11.3467 6.95402 11.3699C6.77247 11.3931 6.58989 11.3355 6.45446 11.2124L3.70446 8.71241C3.44905 8.48022 3.43023 8.08494 3.66242 7.82953C3.89461 7.57412 4.28989 7.55529 4.5453 7.78749L6.75292 9.79441L10.6018 3.90792C10.7907 3.61902 11.178 3.53795 11.4669 3.72684Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$Y = [\"color\"];\nvar ChevronRightIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$Y);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M6.1584 3.13508C6.35985 2.94621 6.67627 2.95642 6.86514 3.15788L10.6151 7.15788C10.7954 7.3502 10.7954 7.64949 10.6151 7.84182L6.86514 11.8418C6.67627 12.0433 6.35985 12.0535 6.1584 11.8646C5.95694 11.6757 5.94673 11.3593 6.1356 11.1579L9.565 7.49985L6.1356 3.84182C5.94673 3.64036 5.95694 3.32394 6.1584 3.13508Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$_ = [\"color\"];\nvar CircleIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$_);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M0.877075 7.49991C0.877075 3.84222 3.84222 0.877075 7.49991 0.877075C11.1576 0.877075 14.1227 3.84222 14.1227 7.49991C14.1227 11.1576 11.1576 14.1227 7.49991 14.1227C3.84222 14.1227 0.877075 11.1576 0.877075 7.49991ZM7.49991 1.82708C4.36689 1.82708 1.82708 4.36689 1.82708 7.49991C1.82708 10.6329 4.36689 13.1727 7.49991 13.1727C10.6329 13.1727 13.1727 10.6329 13.1727 7.49991C13.1727 4.36689 10.6329 1.82708 7.49991 1.82708Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$1h = [\"color\"];\nvar CopyIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$1h);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M1 9.50006C1 10.3285 1.67157 11.0001 2.5 11.0001H4L4 10.0001H2.5C2.22386 10.0001 2 9.7762 2 9.50006L2 2.50006C2 2.22392 2.22386 2.00006 2.5 2.00006L9.5 2.00006C9.77614 2.00006 10 2.22392 10 2.50006V4.00002H5.5C4.67158 4.00002 4 4.67159 4 5.50002V12.5C4 13.3284 4.67158 14 5.5 14H12.5C13.3284 14 14 13.3284 14 12.5V5.50002C14 4.67159 13.3284 4.00002 12.5 4.00002H11V2.50006C11 1.67163 10.3284 1.00006 9.5 1.00006H2.5C1.67157 1.00006 1 1.67163 1 2.50006V9.50006ZM5 5.50002C5 5.22388 5.22386 5.00002 5.5 5.00002H12.5C12.7761 5.00002 13 5.22388 13 5.50002V12.5C13 12.7762 12.7761 13 12.5 13H5.5C5.22386 13 5 12.7762 5 12.5V5.50002Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$1x = [\"color\"];\nvar CursorArrowIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$1x);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M3.29227 0.048984C3.47033 -0.032338 3.67946 -0.00228214 3.8274 0.125891L12.8587 7.95026C13.0134 8.08432 13.0708 8.29916 13.0035 8.49251C12.9362 8.68586 12.7578 8.81866 12.5533 8.82768L9.21887 8.97474L11.1504 13.2187C11.2648 13.47 11.1538 13.7664 10.9026 13.8808L8.75024 14.8613C8.499 14.9758 8.20255 14.8649 8.08802 14.6137L6.15339 10.3703L3.86279 12.7855C3.72196 12.934 3.50487 12.9817 3.31479 12.9059C3.1247 12.8301 3 12.6461 3 12.4414V0.503792C3 0.308048 3.11422 0.130306 3.29227 0.048984ZM4 1.59852V11.1877L5.93799 9.14425C6.05238 9.02363 6.21924 8.96776 6.38319 8.99516C6.54715 9.02256 6.68677 9.12965 6.75573 9.2809L8.79056 13.7441L10.0332 13.178L8.00195 8.71497C7.93313 8.56376 7.94391 8.38824 8.03072 8.24659C8.11753 8.10494 8.26903 8.01566 8.435 8.00834L11.2549 7.88397L4 1.59852Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$1I = [\"color\"];\nvar DotFilledIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$1I);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M9.875 7.5C9.875 8.81168 8.81168 9.875 7.5 9.875C6.18832 9.875 5.125 8.81168 5.125 7.5C5.125 6.18832 6.18832 5.125 7.5 5.125C8.81168 5.125 9.875 6.18832 9.875 7.5Z\",\n    fill: color\n  }));\n});\nvar _excluded$1J = [\"color\"];\nvar DotsHorizontalIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$1J);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M3.625 7.5C3.625 8.12132 3.12132 8.625 2.5 8.625C1.87868 8.625 1.375 8.12132 1.375 7.5C1.375 6.87868 1.87868 6.375 2.5 6.375C3.12132 6.375 3.625 6.87868 3.625 7.5ZM8.625 7.5C8.625 8.12132 8.12132 8.625 7.5 8.625C6.87868 8.625 6.375 8.12132 6.375 7.5C6.375 6.87868 6.87868 6.375 7.5 6.375C8.12132 6.375 8.625 6.87868 8.625 7.5ZM12.5 8.625C13.1213 8.625 13.625 8.12132 13.625 7.5C13.625 6.87868 13.1213 6.375 12.5 6.375C11.8787 6.375 11.375 6.87868 11.375 7.5C11.375 8.12132 11.8787 8.625 12.5 8.625Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$2p = [\"color\"];\nvar GroupIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$2p);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M1.44995 0.949951C1.31734 0.949951 1.19016 1.00263 1.0964 1.0964C1.00263 1.19017 0.949951 1.31735 0.949951 1.44995L0.949966 3.44995C0.949969 3.7261 1.17383 3.94995 1.44997 3.94995C1.72611 3.94995 1.94997 3.72609 1.94997 3.44995L1.94995 1.94995H3.44997C3.72611 1.94995 3.94997 1.72609 3.94997 1.44995C3.94997 1.17381 3.72611 0.949951 3.44997 0.949951H1.44995ZM5.94995 0.949951C5.67381 0.949951 5.44995 1.17381 5.44995 1.44995C5.44995 1.72609 5.67381 1.94995 5.94995 1.94995H8.94995C9.22609 1.94995 9.44995 1.72609 9.44995 1.44995C9.44995 1.17381 9.22609 0.949951 8.94995 0.949951H5.94995ZM5.44995 13.45C5.44995 13.1738 5.67381 12.95 5.94995 12.95H8.94995C9.22609 12.95 9.44995 13.1738 9.44995 13.45C9.44995 13.7261 9.22609 13.95 8.94995 13.95H5.94995C5.67381 13.95 5.44995 13.7261 5.44995 13.45ZM1.94995 5.94995C1.94995 5.67381 1.72609 5.44995 1.44995 5.44995C1.17381 5.44995 0.949951 5.67381 0.949951 5.94995V8.94995C0.949951 9.22609 1.17381 9.44995 1.44995 9.44995C1.72609 9.44995 1.94995 9.22609 1.94995 8.94995V5.94995ZM13.45 5.44995C13.7261 5.44995 13.95 5.67381 13.95 5.94995V8.94995C13.95 9.22609 13.7261 9.44995 13.45 9.44995C13.1738 9.44995 12.95 9.22609 12.95 8.94995V5.94995C12.95 5.67381 13.1738 5.44995 13.45 5.44995ZM11.45 0.949951C11.1738 0.949951 10.95 1.17381 10.95 1.44995C10.95 1.72609 11.1738 1.94995 11.45 1.94995H12.9499V3.44995C12.9499 3.72609 13.1738 3.94995 13.4499 3.94995C13.7261 3.94995 13.9499 3.72609 13.9499 3.44995V1.44995C13.9499 1.17381 13.7252 0.949951 13.449 0.949951H11.45ZM1.44995 10.95C1.72609 10.95 1.94995 11.1738 1.94995 11.45V12.95H3.44997C3.72611 12.95 3.94997 13.1738 3.94997 13.45C3.94997 13.7261 3.72611 13.95 3.44997 13.95H1.44995C1.17381 13.95 0.949951 13.7261 0.949951 13.45V11.45C0.949951 11.1738 1.17381 10.95 1.44995 10.95ZM13.95 11.45C13.95 11.1738 13.7261 10.95 13.45 10.95C13.1738 10.9499 12.95 11.1738 12.95 11.4499L12.9491 12.95H11.45C11.1738 12.95 10.95 13.1738 10.95 13.45C10.95 13.7261 11.1738 13.95 11.45 13.95H13.4499C13.7261 13.95 13.9499 13.7261 13.9499 13.45L13.95 11.45Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$2s = [\"color\"];\nvar HamburgerMenuIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$2s);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M1.5 3C1.22386 3 1 3.22386 1 3.5C1 3.77614 1.22386 4 1.5 4H13.5C13.7761 4 14 3.77614 14 3.5C14 3.22386 13.7761 3 13.5 3H1.5ZM1 7.5C1 7.22386 1.22386 7 1.5 7H13.5C13.7761 7 14 7.22386 14 7.5C14 7.77614 13.7761 8 13.5 8H1.5C1.22386 8 1 7.77614 1 7.5ZM1 11.5C1 11.2239 1.22386 11 1.5 11H13.5C13.7761 11 14 11.2239 14 11.5C14 11.7761 13.7761 12 13.5 12H1.5C1.22386 12 1 11.7761 1 11.5Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$2C = [\"color\"];\nvar ImageIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$2C);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M2.5 1H12.5C13.3284 1 14 1.67157 14 2.5V12.5C14 13.3284 13.3284 14 12.5 14H2.5C1.67157 14 1 13.3284 1 12.5V2.5C1 1.67157 1.67157 1 2.5 1ZM2.5 2C2.22386 2 2 2.22386 2 2.5V8.3636L3.6818 6.6818C3.76809 6.59551 3.88572 6.54797 4.00774 6.55007C4.12975 6.55216 4.24568 6.60372 4.32895 6.69293L7.87355 10.4901L10.6818 7.6818C10.8575 7.50607 11.1425 7.50607 11.3182 7.6818L13 9.3636V2.5C13 2.22386 12.7761 2 12.5 2H2.5ZM2 12.5V9.6364L3.98887 7.64753L7.5311 11.4421L8.94113 13H2.5C2.22386 13 2 12.7761 2 12.5ZM12.5 13H10.155L8.48336 11.153L11 8.6364L13 10.6364V12.5C13 12.7761 12.7761 13 12.5 13ZM6.64922 5.5C6.64922 5.03013 7.03013 4.64922 7.5 4.64922C7.96987 4.64922 8.35078 5.03013 8.35078 5.5C8.35078 5.96987 7.96987 6.35078 7.5 6.35078C7.03013 6.35078 6.64922 5.96987 6.64922 5.5ZM7.5 3.74922C6.53307 3.74922 5.74922 4.53307 5.74922 5.5C5.74922 6.46693 6.53307 7.25078 7.5 7.25078C8.46693 7.25078 9.25078 6.46693 9.25078 5.5C9.25078 4.53307 8.46693 3.74922 7.5 3.74922Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$2_ = [\"color\"];\nvar LockClosedIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$2_);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M5 4.63601C5 3.76031 5.24219 3.1054 5.64323 2.67357C6.03934 2.24705 6.64582 1.9783 7.5014 1.9783C8.35745 1.9783 8.96306 2.24652 9.35823 2.67208C9.75838 3.10299 10 3.75708 10 4.63325V5.99999H5V4.63601ZM4 5.99999V4.63601C4 3.58148 4.29339 2.65754 4.91049 1.99307C5.53252 1.32329 6.42675 0.978302 7.5014 0.978302C8.57583 0.978302 9.46952 1.32233 10.091 1.99162C10.7076 2.65557 11 3.57896 11 4.63325V5.99999H12C12.5523 5.99999 13 6.44771 13 6.99999V13C13 13.5523 12.5523 14 12 14H3C2.44772 14 2 13.5523 2 13V6.99999C2 6.44771 2.44772 5.99999 3 5.99999H4ZM3 6.99999H12V13H3V6.99999Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$2$ = [\"color\"];\nvar LockOpen1Icon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$2$);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M7.4986 0C6.3257 0 5.36107 0.38943 4.73753 1.19361C4.23745 1.83856 4 2.68242 4 3.63325H5C5 2.84313 5.19691 2.23312 5.5278 1.80636C5.91615 1.30552 6.55152 1 7.4986 1C8.35683 1 8.96336 1.26502 9.35846 1.68623C9.75793 2.11211 10 2.76044 10 3.63601V6H3C2.44772 6 2 6.44772 2 7V13C2 13.5523 2.44772 14 3 14H12C12.5523 14 13 13.5523 13 13V7C13 6.44771 12.5523 6 12 6H11V3.63601C11 2.58135 10.7065 1.66167 10.0878 1.0021C9.46477 0.337871 8.57061 0 7.4986 0ZM3 7H12V13H3V7Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$3b = [\"color\"];\nvar MixerVerticalIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$3b);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M5 1.5C5 1.22386 4.77614 1 4.5 1C4.22386 1 4 1.22386 4 1.5L4 7C4 7.01671 4.00082 7.03323 4.00242 7.04952C2.86009 7.28022 2 8.28967 2 9.5C2 10.7103 2.86009 11.7198 4.00242 11.9505C4.00082 11.9668 4 11.9833 4 12V13.5C4 13.7761 4.22386 14 4.5 14C4.77614 14 5 13.7761 5 13.5V12C5 11.9833 4.99918 11.9668 4.99758 11.9505C6.1399 11.7198 7 10.7103 7 9.5C7 8.28967 6.1399 7.28022 4.99758 7.04952C4.99918 7.03323 5 7.01671 5 7L5 1.5ZM11 1.5C11 1.22386 10.7761 1 10.5 1C10.2239 1 10 1.22386 10 1.5V3C10 3.01671 10.0008 3.03323 10.0024 3.04952C8.8601 3.28022 8 4.28967 8 5.5C8 6.71033 8.8601 7.71978 10.0024 7.95048C10.0008 7.96677 10 7.98329 10 8V13.5C10 13.7761 10.2239 14 10.5 14C10.7761 14 11 13.7761 11 13.5V8C11 7.98329 10.9992 7.96677 10.9976 7.95048C12.1399 7.71978 13 6.71033 13 5.5C13 4.28967 12.1399 3.28022 10.9976 3.04952C10.9992 3.03323 11 3.01671 11 3V1.5ZM4.5 8C3.67157 8 3 8.67157 3 9.5C3 10.3284 3.67157 11 4.5 11C5.32843 11 6 10.3284 6 9.5C6 8.67157 5.32843 8 4.5 8ZM9 5.5C9 4.67157 9.67157 4 10.5 4C11.3284 4 12 4.67157 12 5.5C12 6.32843 11.3284 7 10.5 7C9.67157 7 9 6.32843 9 5.5Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$3n = [\"color\"];\nvar Pencil1Icon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$3n);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M11.8536 1.14645C11.6583 0.951184 11.3417 0.951184 11.1465 1.14645L3.71455 8.57836C3.62459 8.66832 3.55263 8.77461 3.50251 8.89155L2.04044 12.303C1.9599 12.491 2.00189 12.709 2.14646 12.8536C2.29103 12.9981 2.50905 13.0401 2.69697 12.9596L6.10847 11.4975C6.2254 11.4474 6.3317 11.3754 6.42166 11.2855L13.8536 3.85355C14.0488 3.65829 14.0488 3.34171 13.8536 3.14645L11.8536 1.14645ZM4.42166 9.28547L11.5 2.20711L12.7929 3.5L5.71455 10.5784L4.21924 11.2192L3.78081 10.7808L4.42166 9.28547Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$3o = [\"color\"];\nvar Pencil2Icon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$3o);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M12.1464 1.14645C12.3417 0.951184 12.6583 0.951184 12.8535 1.14645L14.8535 3.14645C15.0488 3.34171 15.0488 3.65829 14.8535 3.85355L10.9109 7.79618C10.8349 7.87218 10.7471 7.93543 10.651 7.9835L6.72359 9.94721C6.53109 10.0435 6.29861 10.0057 6.14643 9.85355C5.99425 9.70137 5.95652 9.46889 6.05277 9.27639L8.01648 5.34897C8.06455 5.25283 8.1278 5.16507 8.2038 5.08907L12.1464 1.14645ZM12.5 2.20711L8.91091 5.79618L7.87266 7.87267L8.12731 8.12732L10.2038 7.08907L13.7929 3.5L12.5 2.20711ZM9.99998 2L8.99998 3H4.9C4.47171 3 4.18056 3.00039 3.95552 3.01877C3.73631 3.03668 3.62421 3.06915 3.54601 3.10899C3.35785 3.20487 3.20487 3.35785 3.10899 3.54601C3.06915 3.62421 3.03669 3.73631 3.01878 3.95552C3.00039 4.18056 3 4.47171 3 4.9V11.1C3 11.5283 3.00039 11.8194 3.01878 12.0445C3.03669 12.2637 3.06915 12.3758 3.10899 12.454C3.20487 12.6422 3.35785 12.7951 3.54601 12.891C3.62421 12.9309 3.73631 12.9633 3.95552 12.9812C4.18056 12.9996 4.47171 13 4.9 13H11.1C11.5283 13 11.8194 12.9996 12.0445 12.9812C12.2637 12.9633 12.3758 12.9309 12.454 12.891C12.6422 12.7951 12.7951 12.6422 12.891 12.454C12.9309 12.3758 12.9633 12.2637 12.9812 12.0445C12.9996 11.8194 13 11.5283 13 11.1V6.99998L14 5.99998V11.1V11.1207C14 11.5231 14 11.8553 13.9779 12.1259C13.9549 12.407 13.9057 12.6653 13.782 12.908C13.5903 13.2843 13.2843 13.5903 12.908 13.782C12.6653 13.9057 12.407 13.9549 12.1259 13.9779C11.8553 14 11.5231 14 11.1207 14H11.1H4.9H4.87934C4.47686 14 4.14468 14 3.87409 13.9779C3.59304 13.9549 3.33469 13.9057 3.09202 13.782C2.7157 13.5903 2.40973 13.2843 2.21799 12.908C2.09434 12.6653 2.04506 12.407 2.0221 12.1259C1.99999 11.8553 1.99999 11.5231 2 11.1207V11.1206V11.1V4.9V4.87935V4.87932V4.87931C1.99999 4.47685 1.99999 4.14468 2.0221 3.87409C2.04506 3.59304 2.09434 3.33469 2.21799 3.09202C2.40973 2.71569 2.7157 2.40973 3.09202 2.21799C3.33469 2.09434 3.59304 2.04506 3.87409 2.0221C4.14468 1.99999 4.47685 1.99999 4.87932 2H4.87935H4.9H9.99998Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$3s = [\"color\"];\nvar PinBottomIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$3s);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M13.5 13.95C13.7485 13.95 13.95 13.7485 13.95 13.5C13.95 13.2514 13.7485 13.05 13.5 13.05L1.49995 13.05C1.25142 13.05 1.04995 13.2514 1.04995 13.5C1.04995 13.7485 1.25142 13.95 1.49995 13.95L13.5 13.95ZM11.0681 7.5683C11.2439 7.39257 11.2439 7.10764 11.0681 6.93191C10.8924 6.75617 10.6075 6.75617 10.4317 6.93191L7.94993 9.41371L7.94993 1.49998C7.94993 1.25146 7.74846 1.04998 7.49993 1.04998C7.2514 1.04998 7.04993 1.25146 7.04993 1.49998L7.04993 9.41371L4.56813 6.93191C4.39239 6.75617 4.10746 6.75617 3.93173 6.93191C3.75599 7.10764 3.75599 7.39257 3.93173 7.5683L7.18173 10.8183C7.35746 10.994 7.64239 10.994 7.81812 10.8183L11.0681 7.5683Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$3v = [\"color\"];\nvar PinTopIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$3v);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M1.50005 1.05005C1.25152 1.05005 1.05005 1.25152 1.05005 1.50005C1.05005 1.74858 1.25152 1.95005 1.50005 1.95005L13.5 1.95005C13.7486 1.95005 13.95 1.74858 13.95 1.50005C13.95 1.25152 13.7486 1.05005 13.5 1.05005H1.50005ZM3.93188 7.43169C3.75614 7.60743 3.75614 7.89236 3.93188 8.06809C4.10761 8.24383 4.39254 8.24383 4.56827 8.06809L7.05007 5.58629V13.5C7.05007 13.7485 7.25155 13.95 7.50007 13.95C7.7486 13.95 7.95007 13.7485 7.95007 13.5L7.95007 5.58629L10.4319 8.06809C10.6076 8.24383 10.8925 8.24383 11.0683 8.06809C11.244 7.89235 11.244 7.60743 11.0683 7.43169L7.81827 4.18169C7.64254 4.00596 7.35761 4.00596 7.18188 4.18169L3.93188 7.43169Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$3x = [\"color\"];\nvar PlusIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$3x);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M8 2.75C8 2.47386 7.77614 2.25 7.5 2.25C7.22386 2.25 7 2.47386 7 2.75V7H2.75C2.47386 7 2.25 7.22386 2.25 7.5C2.25 7.77614 2.47386 8 2.75 8H7V12.25C7 12.5261 7.22386 12.75 7.5 12.75C7.77614 12.75 8 12.5261 8 12.25V8H12.25C12.5261 8 12.75 7.77614 12.75 7.5C12.75 7.22386 12.5261 7 12.25 7H8V2.75Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$3I = [\"color\"];\nvar RotateCounterClockwiseIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$3I);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M7.59664 2.93628C7.76085 3.06401 8.00012 2.94698 8.00012 2.73895V1.99998C9.98143 2 11.1848 2.3637 11.9105 3.08945C12.6363 3.81522 13 5.0186 13 6.99998C13 7.27613 13.2239 7.49998 13.5 7.49998C13.7761 7.49998 14 7.27613 14 6.99998C14 4.9438 13.6325 3.39719 12.6176 2.38234C11.6028 1.36752 10.0562 0.999999 8.00012 0.999984V0.261266C8.00012 0.0532293 7.76085 -0.0637944 7.59664 0.063928L6.00384 1.30277C5.87516 1.40286 5.87516 1.59735 6.00384 1.69744L7.59664 2.93628ZM9.5 5H2.5C2.22386 5 2 5.22386 2 5.5V12.5C2 12.7761 2.22386 13 2.5 13H9.5C9.77614 13 10 12.7761 10 12.5V5.5C10 5.22386 9.77614 5 9.5 5ZM2.5 4C1.67157 4 1 4.67157 1 5.5V12.5C1 13.3284 1.67157 14 2.5 14H9.5C10.3284 14 11 13.3284 11 12.5V5.5C11 4.67157 10.3284 4 9.5 4H2.5Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$42 = [\"color\"];\nvar SpaceEvenlyHorizontallyIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$42);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M14.4999 0.999992C14.2237 0.999992 13.9999 1.22385 13.9999 1.49999L13.9999 13.4999C13.9999 13.776 14.2237 13.9999 14.4999 13.9999C14.776 13.9999 14.9999 13.776 14.9999 13.4999L14.9999 1.49999C14.9999 1.22385 14.776 0.999992 14.4999 0.999992ZM0.499996 0.999992C0.223856 0.999992 -9.78509e-09 1.22385 -2.18556e-08 1.49999L4.07279e-07 13.4999C3.95208e-07 13.776 0.223855 13.9999 0.499996 13.9999C0.776136 13.9999 0.999992 13.776 0.999992 13.4999L0.999992 1.49999C0.999992 1.22385 0.776136 0.999992 0.499996 0.999992ZM1.99998 6.99994C1.99998 6.44766 2.44769 5.99995 2.99998 5.99995L5.99995 5.99995C6.55223 5.99995 6.99994 6.44766 6.99994 6.99994L6.99994 7.99993C6.99994 8.55221 6.55223 8.99992 5.99995 8.99992L2.99998 8.99992C2.4477 8.99992 1.99998 8.55221 1.99998 7.99993L1.99998 6.99994ZM8.99993 5.99995C8.44765 5.99995 7.99993 6.44766 7.99993 6.99994L7.99993 7.99993C7.99993 8.55221 8.44765 8.99992 8.99993 8.99992L11.9999 8.99992C12.5522 8.99992 12.9999 8.55221 12.9999 7.99993L12.9999 6.99994C12.9999 6.44766 12.5522 5.99995 11.9999 5.99995L8.99993 5.99995Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$43 = [\"color\"];\nvar SpaceEvenlyVerticallyIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$43);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M0.999878 0.5C0.999878 0.223858 1.22374 0 1.49988 0H13.4999C13.776 0 13.9999 0.223858 13.9999 0.5C13.9999 0.776142 13.776 1 13.4999 1H1.49988C1.22374 1 0.999878 0.776142 0.999878 0.5ZM7 2C6.44772 2 6 2.44772 6 3V6C6 6.55228 6.44772 7 7 7H8C8.55228 7 9 6.55228 9 6V3C9 2.44772 8.55228 2 8 2H7ZM7 8C6.44772 8 6 8.44771 6 9V12C6 12.5523 6.44772 13 7 13H8C8.55228 13 9 12.5523 9 12V9C9 8.44772 8.55228 8 8 8H7ZM1.49988 14C1.22374 14 0.999878 14.2239 0.999878 14.5C0.999878 14.7761 1.22374 15 1.49988 15H13.4999C13.776 15 13.9999 14.7761 13.9999 14.5C13.9999 14.2239 13.776 14 13.4999 14H1.49988Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$48 = [\"color\"];\nvar SquareIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$48);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M1 1H1.5H13.5H14V1.5V13.5V14H13.5H1.5H1V13.5V1.5V1ZM2 2V13H13V2H2Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$4f = [\"color\"];\nvar StretchHorizontallyIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$4f);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M14.4999 0.999992C14.2237 0.999992 13.9999 1.22385 13.9999 1.49999L13.9999 5.99995L0.999992 5.99995L0.999992 1.49999C0.999992 1.22385 0.776136 0.999992 0.499996 0.999992C0.223856 0.999992 -9.78509e-09 1.22385 -2.18556e-08 1.49999L4.07279e-07 13.4999C3.95208e-07 13.776 0.223855 13.9999 0.499996 13.9999C0.776136 13.9999 0.999992 13.776 0.999992 13.4999L0.999992 8.99992L13.9999 8.99992L13.9999 13.4999C13.9999 13.776 14.2237 13.9999 14.4999 13.9999C14.776 13.9999 14.9999 13.776 14.9999 13.4999L14.9999 1.49999C14.9999 1.22385 14.776 0.999992 14.4999 0.999992Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$4g = [\"color\"];\nvar StretchVerticallyIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$4g);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M0.999878 0.5C0.999878 0.223858 1.22374 0 1.49988 0H13.4999C13.776 0 13.9999 0.223858 13.9999 0.5C13.9999 0.776142 13.776 1 13.4999 1H6H1.49988C1.22374 1 0.999878 0.776142 0.999878 0.5ZM9 14V1L6 1V14H1.49988C1.22374 14 0.999878 14.2239 0.999878 14.5C0.999878 14.7761 1.22374 15 1.49988 15H13.4999C13.776 15 13.9999 14.7761 13.9999 14.5C13.9999 14.2239 13.776 14 13.4999 14H9Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$4n = [\"color\"];\nvar TextIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$4n);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M3.94993 2.95002L3.94993 4.49998C3.94993 4.74851 3.74845 4.94998 3.49993 4.94998C3.2514 4.94998 3.04993 4.74851 3.04993 4.49998V2.50004C3.04993 2.45246 3.05731 2.40661 3.07099 2.36357C3.12878 2.18175 3.29897 2.05002 3.49993 2.05002H11.4999C11.6553 2.05002 11.7922 2.12872 11.8731 2.24842C11.9216 2.32024 11.9499 2.40682 11.9499 2.50002L11.9499 2.50004V4.49998C11.9499 4.74851 11.7485 4.94998 11.4999 4.94998C11.2514 4.94998 11.0499 4.74851 11.0499 4.49998V2.95002H8.04993V12.05H9.25428C9.50281 12.05 9.70428 12.2515 9.70428 12.5C9.70428 12.7486 9.50281 12.95 9.25428 12.95H5.75428C5.50575 12.95 5.30428 12.7486 5.30428 12.5C5.30428 12.2515 5.50575 12.05 5.75428 12.05H6.94993V2.95002H3.94993Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$4p = [\"color\"];\nvar TextAlignCenterIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$4p);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M2 4.5C2 4.22386 2.22386 4 2.5 4H12.5C12.7761 4 13 4.22386 13 4.5C13 4.77614 12.7761 5 12.5 5H2.5C2.22386 5 2 4.77614 2 4.5ZM4 7.5C4 7.22386 4.22386 7 4.5 7H10.5C10.7761 7 11 7.22386 11 7.5C11 7.77614 10.7761 8 10.5 8H4.5C4.22386 8 4 7.77614 4 7.5ZM3 10.5C3 10.2239 3.22386 10 3.5 10H11.5C11.7761 10 12 10.2239 12 10.5C12 10.7761 11.7761 11 11.5 11H3.5C3.22386 11 3 10.7761 3 10.5Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$4q = [\"color\"];\nvar TextAlignJustifyIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$4q);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M2.5 4C2.22386 4 2 4.22386 2 4.5C2 4.77614 2.22386 5 2.5 5H12.5C12.7761 5 13 4.77614 13 4.5C13 4.22386 12.7761 4 12.5 4H2.5ZM2 7.5C2 7.22386 2.22386 7 2.5 7H12.5C12.7761 7 13 7.22386 13 7.5C13 7.77614 12.7761 8 12.5 8H2.5C2.22386 8 2 7.77614 2 7.5ZM2 10.5C2 10.2239 2.22386 10 2.5 10H12.5C12.7761 10 13 10.2239 13 10.5C13 10.7761 12.7761 11 12.5 11H2.5C2.22386 11 2 10.7761 2 10.5Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$4r = [\"color\"];\nvar TextAlignLeftIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$4r);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M2 4.5C2 4.22386 2.22386 4 2.5 4H12.5C12.7761 4 13 4.22386 13 4.5C13 4.77614 12.7761 5 12.5 5H2.5C2.22386 5 2 4.77614 2 4.5ZM2 7.5C2 7.22386 2.22386 7 2.5 7H7.5C7.77614 7 8 7.22386 8 7.5C8 7.77614 7.77614 8 7.5 8H2.5C2.22386 8 2 7.77614 2 7.5ZM2 10.5C2 10.2239 2.22386 10 2.5 10H10.5C10.7761 10 11 10.2239 11 10.5C11 10.7761 10.7761 11 10.5 11H2.5C2.22386 11 2 10.7761 2 10.5Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$4t = [\"color\"];\nvar TextAlignRightIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$4t);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M2 4.5C2 4.22386 2.22386 4 2.5 4H12.5C12.7761 4 13 4.22386 13 4.5C13 4.77614 12.7761 5 12.5 5H2.5C2.22386 5 2 4.77614 2 4.5ZM7 7.5C7 7.22386 7.22386 7 7.5 7H12.5C12.7761 7 13 7.22386 13 7.5C13 7.77614 12.7761 8 12.5 8H7.5C7.22386 8 7 7.77614 7 7.5ZM4 10.5C4 10.2239 4.22386 10 4.5 10H12.5C12.7761 10 13 10.2239 13 10.5C13 10.7761 12.7761 11 12.5 11H4.5C4.22386 11 4 10.7761 4 10.5Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$4R = [\"color\"];\nvar VercelLogoIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$4R);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M7.49998 1L6.92321 2.00307L1.17498 12L0.599976 13H1.7535H13.2464H14.4L13.825 12L8.07674 2.00307L7.49998 1ZM7.49998 3.00613L2.3285 12H12.6714L7.49998 3.00613Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\n\n// src/components/Tldraw/components/ContextMenu/ContextMenu.tsx\nvar React16 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/translations/main.json\nvar main_default = {\n  \"style.menu.color\": \"Color\",\n  \"style.menu.fill\": \"Fill\",\n  \"style.menu.dash\": \"Dash\",\n  \"style.menu.size\": \"Size\",\n  \"style.menu.keep.open\": \"Keep Open\",\n  \"style.menu.font\": \"Font\",\n  \"style.menu.align\": \"Align\",\n  styles: \"Styles\",\n  \"zoom.in\": \"Zoom In\",\n  \"zoom.out\": \"Zoom Out\",\n  to: \"To\",\n  \"menu.tools\": \"Tools\",\n  \"menu.transform\": \"Transform\",\n  \"menu.file\": \"File\",\n  \"menu.edit\": \"Edit\",\n  \"menu.view\": \"View\",\n  \"menu.preferences\": \"Preferences\",\n  \"menu.sign.in\": \"Sign In\",\n  \"menu.sign.out\": \"Sign Out\",\n  \"become.a.sponsor\": \"Become a Sponsor\",\n  \"zoom.to.content\": \"Back to content\",\n  \"zoom.to.selection\": \"Zoom to Selection\",\n  \"zoom.to.fit\": \"Zoom to Fit\",\n  \"zoom.to\": \"Zoom to\",\n  \"preferences.dark.mode\": \"Dark Mode\",\n  \"preferences.focus.mode\": \"Focus Mode\",\n  \"preferences.debug.mode\": \"Debug Mode\",\n  \"preferences.show.grid\": \"Show Grid\",\n  \"preferences.use.cad.selection\": \"Use CAD Selection\",\n  \"preferences.keep.stylemenu.open\": \"Keep Style Menu Open\",\n  \"preferences.always.show.snaps\": \"Always Show Snaps\",\n  \"preferences.rotate.handles\": \"Rotate Handles\",\n  \"preferences.binding.handles\": \"Binding Handles\",\n  \"preferences.clone.handles\": \"Clone Handles\",\n  undo: \"Undo\",\n  redo: \"Redo\",\n  cut: \"Cut\",\n  copy: \"Copy\",\n  paste: \"Paste\",\n  \"copy.as\": \"Copy As\",\n  \"export.as\": \"Export As\",\n  \"select.all\": \"Select All\",\n  \"select.none\": \"Select None\",\n  delete: \"Delete\",\n  \"new.project\": \"New Project\",\n  open: \"Open\",\n  save: \"Save\",\n  \"save.as\": \"Save As\",\n  \"upload.media\": \"Upload Media\",\n  \"create.page\": \"Create Page\",\n  \"new.page\": \"New Page\",\n  \"page.name\": \"Page Name\",\n  duplicate: \"Duplicate\",\n  cancel: \"Cancel\",\n  \"copy.invite.link\": \"Copy Invite Link\",\n  \"copy.readonly.link\": \"Copy ReadOnly Link\",\n  \"create.multiplayer.project\": \"Create a Multiplayer Project\",\n  \"copy.multiplayer.project\": \"Copy to Multiplayer Project\",\n  select: \"Select\",\n  eraser: \"Eraser\",\n  draw: \"Draw\",\n  arrow: \"Arrow\",\n  text: \"Text\",\n  sticky: \"Sticky\",\n  rectangle: \"Rectangle\",\n  ellipse: \"Ellipse\",\n  triangle: \"Triangle\",\n  line: \"Line\",\n  rotate: \"Rotate\",\n  \"lock.aspect.ratio\": \"Lock Aspect Ratio\",\n  \"unlock.aspect.ratio\": \"Unlock Aspect Ratio\",\n  group: \"Group\",\n  ungroup: \"Ungroup\",\n  \"move.to.back\": \"Move to Back\",\n  \"move.backward\": \"Move Backward\",\n  \"move.forward\": \"Move Forward\",\n  \"move.to.front\": \"Move to Front\",\n  \"reset.angle\": \"Reset Angle\",\n  lock: \"Lock\",\n  unlock: \"Unlock\",\n  \"align.distribute\": \"Align / Distribute\",\n  \"move.to.page\": \"Move to Page\",\n  \"flip.horizontal\": \"Flip Horizontal\",\n  \"flip.vertical\": \"Flip Vertical\",\n  move: \"Move\",\n  \"to.front\": \"To Front\",\n  forward: \"Forward\",\n  backward: \"Backward\",\n  back: \"To Back\",\n  language: \"Language\",\n  \"translation.link\": \"Learn More\",\n  \"dock.position\": \"Dock Position\",\n  bottom: \"Bottom\",\n  left: \"Left\",\n  right: \"Right\",\n  top: \"Top\",\n  page: \"Page\",\n  \"keyboard.shortcuts\": \"Keyboard shortcuts\",\n  search: \"Search\",\n  loading: \"Loading{dots}\",\n  \"export.background\": \"Export Background\",\n  transparent: \"Transparent\",\n  auto: \"Auto\",\n  light: \"Light\",\n  dark: \"Dark\",\n  github: \"Github\",\n  twitter: \"Twitter\",\n  discord: \"Discord\",\n  image: \"Image\",\n  \"align.left\": \"Align Left\",\n  \"align.center.x\": \"Align Horizontal Center\",\n  \"align.right\": \"Align Right\",\n  \"align.top\": \"Align Top\",\n  \"align.center.y\": \"Align Vertical Center\",\n  \"align.bottom\": \"Align Bottom\",\n  \"distribute.x\": \"Distribute Horizontal\",\n  \"distribute.y\": \"Distribute Vertical\",\n  \"stretch.x\": \"Stretch Horizontal\",\n  \"stretch.y\": \"Stretch Vertical\",\n  \"dialog.save.firsttime\": \"Do you want to save your current project?\",\n  \"dialog.save.again\": \"Do you want to save changes to your current project?\",\n  \"dialog.cancel\": \"Cancel\",\n  \"dialog.no\": \"No\",\n  \"dialog.yes\": \"Yes\",\n  \"enter.file.name\": \"Enter file name\"\n};\n\n// src/components/Tldraw/translations/FormattedMessage.tsx\nvar import_jsx_runtime = require(\"react/jsx-runtime\");\nfunction FormattedMessage({ id }) {\n  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(\"span\", { children: main_default[id] });\n}\nfunction useIntl() {\n  return {\n    formatMessage({ id }) {\n      return main_default[id];\n    }\n  };\n}\n\n// node_modules/@stitches/react/dist/index.mjs\nvar import_react31 = __toESM(require(\"react\"), 1);\nvar e3 = \"colors\";\nvar t3 = \"sizes\";\nvar r3 = \"space\";\nvar n3 = { gap: r3, gridGap: r3, columnGap: r3, gridColumnGap: r3, rowGap: r3, gridRowGap: r3, inset: r3, insetBlock: r3, insetBlockEnd: r3, insetBlockStart: r3, insetInline: r3, insetInlineEnd: r3, insetInlineStart: r3, margin: r3, marginTop: r3, marginRight: r3, marginBottom: r3, marginLeft: r3, marginBlock: r3, marginBlockEnd: r3, marginBlockStart: r3, marginInline: r3, marginInlineEnd: r3, marginInlineStart: r3, padding: r3, paddingTop: r3, paddingRight: r3, paddingBottom: r3, paddingLeft: r3, paddingBlock: r3, paddingBlockEnd: r3, paddingBlockStart: r3, paddingInline: r3, paddingInlineEnd: r3, paddingInlineStart: r3, top: r3, right: r3, bottom: r3, left: r3, scrollMargin: r3, scrollMarginTop: r3, scrollMarginRight: r3, scrollMarginBottom: r3, scrollMarginLeft: r3, scrollMarginX: r3, scrollMarginY: r3, scrollMarginBlock: r3, scrollMarginBlockEnd: r3, scrollMarginBlockStart: r3, scrollMarginInline: r3, scrollMarginInlineEnd: r3, scrollMarginInlineStart: r3, scrollPadding: r3, scrollPaddingTop: r3, scrollPaddingRight: r3, scrollPaddingBottom: r3, scrollPaddingLeft: r3, scrollPaddingX: r3, scrollPaddingY: r3, scrollPaddingBlock: r3, scrollPaddingBlockEnd: r3, scrollPaddingBlockStart: r3, scrollPaddingInline: r3, scrollPaddingInlineEnd: r3, scrollPaddingInlineStart: r3, fontSize: \"fontSizes\", background: e3, backgroundColor: e3, backgroundImage: e3, borderImage: e3, border: e3, borderBlock: e3, borderBlockEnd: e3, borderBlockStart: e3, borderBottom: e3, borderBottomColor: e3, borderColor: e3, borderInline: e3, borderInlineEnd: e3, borderInlineStart: e3, borderLeft: e3, borderLeftColor: e3, borderRight: e3, borderRightColor: e3, borderTop: e3, borderTopColor: e3, caretColor: e3, color: e3, columnRuleColor: e3, fill: e3, outline: e3, outlineColor: e3, stroke: e3, textDecorationColor: e3, fontFamily: \"fonts\", fontWeight: \"fontWeights\", lineHeight: \"lineHeights\", letterSpacing: \"letterSpacings\", blockSize: t3, minBlockSize: t3, maxBlockSize: t3, inlineSize: t3, minInlineSize: t3, maxInlineSize: t3, width: t3, minWidth: t3, maxWidth: t3, height: t3, minHeight: t3, maxHeight: t3, flexBasis: t3, gridTemplateColumns: t3, gridTemplateRows: t3, borderWidth: \"borderWidths\", borderTopWidth: \"borderWidths\", borderRightWidth: \"borderWidths\", borderBottomWidth: \"borderWidths\", borderLeftWidth: \"borderWidths\", borderStyle: \"borderStyles\", borderTopStyle: \"borderStyles\", borderRightStyle: \"borderStyles\", borderBottomStyle: \"borderStyles\", borderLeftStyle: \"borderStyles\", borderRadius: \"radii\", borderTopLeftRadius: \"radii\", borderTopRightRadius: \"radii\", borderBottomRightRadius: \"radii\", borderBottomLeftRadius: \"radii\", boxShadow: \"shadows\", textShadow: \"shadows\", transition: \"transitions\", zIndex: \"zIndices\" };\nvar i3 = (e5, t5) => \"function\" == typeof t5 ? { \"()\": Function.prototype.toString.call(t5) } : t5;\nvar o3 = () => {\n  const e5 = /* @__PURE__ */ Object.create(null);\n  return (t5, r5, ...n5) => {\n    const o5 = ((e6) => JSON.stringify(e6, i3))(t5);\n    return o5 in e5 ? e5[o5] : e5[o5] = r5(t5, ...n5);\n  };\n};\nvar l5 = Symbol.for(\"sxs.internal\");\nvar s3 = (e5, t5) => Object.defineProperties(e5, Object.getOwnPropertyDescriptors(t5));\nvar a5 = (e5) => {\n  for (const t5 in e5)\n    return true;\n  return false;\n};\nvar { hasOwnProperty: c3 } = Object.prototype;\nvar d4 = (e5) => e5.includes(\"-\") ? e5 : e5.replace(/[A-Z]/g, (e6) => \"-\" + e6.toLowerCase());\nvar g5 = /\\s+(?![^()]*\\))/;\nvar p4 = (e5) => (t5) => e5(...\"string\" == typeof t5 ? String(t5).split(g5) : [t5]);\nvar u3 = { appearance: (e5) => ({ WebkitAppearance: e5, appearance: e5 }), backfaceVisibility: (e5) => ({ WebkitBackfaceVisibility: e5, backfaceVisibility: e5 }), backdropFilter: (e5) => ({ WebkitBackdropFilter: e5, backdropFilter: e5 }), backgroundClip: (e5) => ({ WebkitBackgroundClip: e5, backgroundClip: e5 }), boxDecorationBreak: (e5) => ({ WebkitBoxDecorationBreak: e5, boxDecorationBreak: e5 }), clipPath: (e5) => ({ WebkitClipPath: e5, clipPath: e5 }), content: (e5) => ({ content: e5.includes('\"') || e5.includes(\"'\") || /^([A-Za-z]+\\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)$/.test(e5) ? e5 : `\"${e5}\"` }), hyphens: (e5) => ({ WebkitHyphens: e5, hyphens: e5 }), maskImage: (e5) => ({ WebkitMaskImage: e5, maskImage: e5 }), maskSize: (e5) => ({ WebkitMaskSize: e5, maskSize: e5 }), tabSize: (e5) => ({ MozTabSize: e5, tabSize: e5 }), textSizeAdjust: (e5) => ({ WebkitTextSizeAdjust: e5, textSizeAdjust: e5 }), userSelect: (e5) => ({ WebkitUserSelect: e5, userSelect: e5 }), marginBlock: p4((e5, t5) => ({ marginBlockStart: e5, marginBlockEnd: t5 || e5 })), marginInline: p4((e5, t5) => ({ marginInlineStart: e5, marginInlineEnd: t5 || e5 })), maxSize: p4((e5, t5) => ({ maxBlockSize: e5, maxInlineSize: t5 || e5 })), minSize: p4((e5, t5) => ({ minBlockSize: e5, minInlineSize: t5 || e5 })), paddingBlock: p4((e5, t5) => ({ paddingBlockStart: e5, paddingBlockEnd: t5 || e5 })), paddingInline: p4((e5, t5) => ({ paddingInlineStart: e5, paddingInlineEnd: t5 || e5 })) };\nvar h4 = /([\\d.]+)([^]*)/;\nvar f3 = (e5, t5) => e5.length ? e5.reduce((e6, r5) => (e6.push(...t5.map((e7) => e7.includes(\"&\") ? e7.replace(/&/g, /[ +>|~]/.test(r5) && /&.*&/.test(e7) ? `:is(${r5})` : r5) : r5 + \" \" + e7)), e6), []) : t5;\nvar m4 = (e5, t5) => e5 in b4 && \"string\" == typeof t5 ? t5.replace(/^((?:[^]*[^\\w-])?)(fit-content|stretch)((?:[^\\w-][^]*)?)$/, (t6, r5, n5, i4) => r5 + (\"stretch\" === n5 ? `-moz-available${i4};${d4(e5)}:${r5}-webkit-fill-available` : `-moz-fit-content${i4};${d4(e5)}:${r5}fit-content`) + i4) : String(t5);\nvar b4 = { blockSize: 1, height: 1, inlineSize: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, width: 1 };\nvar S3 = (e5) => e5 ? e5 + \"-\" : \"\";\nvar k4 = (e5, t5, r5) => e5.replace(/([+-])?((?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[Ee][+-]?\\d+)?)?(\\$|--)([$\\w-]+)/g, (e6, n5, i4, o5, l7) => \"$\" == o5 == !!i4 ? e6 : (n5 || \"--\" == o5 ? \"calc(\" : \"\") + \"var(--\" + (\"$\" === o5 ? S3(t5) + (l7.includes(\"$\") ? \"\" : S3(r5)) + l7.replace(/\\$/g, \"-\") : l7) + \")\" + (n5 || \"--\" == o5 ? \"*\" + (n5 || \"\") + (i4 || \"1\") + \")\" : \"\"));\nvar y4 = /\\s*,\\s*(?![^()]*\\))/;\nvar B3 = Object.prototype.toString;\nvar $4 = (e5, t5, r5, n5, i4) => {\n  let o5, l7, s5;\n  const a7 = (e6, t6, r6) => {\n    let c5, g6;\n    const p6 = (e7) => {\n      for (c5 in e7) {\n        const R7 = 64 === c5.charCodeAt(0), z5 = R7 && Array.isArray(e7[c5]) ? e7[c5] : [e7[c5]];\n        for (g6 of z5) {\n          const e8 = /[A-Z]/.test($5 = c5) ? $5 : $5.replace(/-[^]/g, (e9) => e9[1].toUpperCase()), z6 = \"object\" == typeof g6 && g6 && g6.toString === B3 && (!n5.utils[e8] || !t6.length);\n          if (e8 in n5.utils && !z6) {\n            const t7 = n5.utils[e8];\n            if (t7 !== l7) {\n              l7 = t7, p6(t7(g6)), l7 = null;\n              continue;\n            }\n          } else if (e8 in u3) {\n            const t7 = u3[e8];\n            if (t7 !== s5) {\n              s5 = t7, p6(t7(g6)), s5 = null;\n              continue;\n            }\n          }\n          if (R7 && (b6 = c5.slice(1) in n5.media ? \"@media \" + n5.media[c5.slice(1)] : c5, c5 = b6.replace(/\\(\\s*([\\w-]+)\\s*(=|<|<=|>|>=)\\s*([\\w-]+)\\s*(?:(<|<=|>|>=)\\s*([\\w-]+)\\s*)?\\)/g, (e9, t7, r7, n6, i5, o6) => {\n            const l8 = h4.test(t7), s6 = 0.0625 * (l8 ? -1 : 1), [a8, c6] = l8 ? [n6, t7] : [t7, n6];\n            return \"(\" + (\"=\" === r7[0] ? \"\" : \">\" === r7[0] === l8 ? \"max-\" : \"min-\") + a8 + \":\" + (\"=\" !== r7[0] && 1 === r7.length ? c6.replace(h4, (e10, t8, n7) => Number(t8) + s6 * (\">\" === r7 ? 1 : -1) + n7) : c6) + (i5 ? \") and (\" + (\">\" === i5[0] ? \"min-\" : \"max-\") + a8 + \":\" + (1 === i5.length ? o6.replace(h4, (e10, t8, r8) => Number(t8) + s6 * (\">\" === i5 ? -1 : 1) + r8) : o6) : \"\") + \")\";\n          })), z6) {\n            const e9 = R7 ? r6.concat(c5) : [...r6], n6 = R7 ? [...t6] : f3(t6, c5.split(y4));\n            void 0 !== o5 && i4(x4(...o5)), o5 = void 0, a7(g6, n6, e9);\n          } else\n            void 0 === o5 && (o5 = [[], t6, r6]), c5 = R7 || 36 !== c5.charCodeAt(0) ? c5 : `--${S3(n5.prefix)}${c5.slice(1).replace(/\\$/g, \"-\")}`, g6 = z6 ? g6 : \"number\" == typeof g6 ? g6 && e8 in I2 ? String(g6) + \"px\" : String(g6) : k4(m4(e8, null == g6 ? \"\" : g6), n5.prefix, n5.themeMap[e8]), o5[0].push(`${R7 ? `${c5} ` : `${d4(c5)}:`}${g6}`);\n        }\n      }\n      var b6, $5;\n    };\n    p6(e6), void 0 !== o5 && i4(x4(...o5)), o5 = void 0;\n  };\n  a7(e5, t5, r5);\n};\nvar x4 = (e5, t5, r5) => `${r5.map((e6) => `${e6}{`).join(\"\")}${t5.length ? `${t5.join(\",\")}{` : \"\"}${e5.join(\";\")}${t5.length ? \"}\" : \"\"}${Array(r5.length ? r5.length + 1 : 0).join(\"}\")}`;\nvar I2 = { animationDelay: 1, animationDuration: 1, backgroundSize: 1, blockSize: 1, border: 1, borderBlock: 1, borderBlockEnd: 1, borderBlockEndWidth: 1, borderBlockStart: 1, borderBlockStartWidth: 1, borderBlockWidth: 1, borderBottom: 1, borderBottomLeftRadius: 1, borderBottomRightRadius: 1, borderBottomWidth: 1, borderEndEndRadius: 1, borderEndStartRadius: 1, borderInlineEnd: 1, borderInlineEndWidth: 1, borderInlineStart: 1, borderInlineStartWidth: 1, borderInlineWidth: 1, borderLeft: 1, borderLeftWidth: 1, borderRadius: 1, borderRight: 1, borderRightWidth: 1, borderSpacing: 1, borderStartEndRadius: 1, borderStartStartRadius: 1, borderTop: 1, borderTopLeftRadius: 1, borderTopRightRadius: 1, borderTopWidth: 1, borderWidth: 1, bottom: 1, columnGap: 1, columnRule: 1, columnRuleWidth: 1, columnWidth: 1, containIntrinsicSize: 1, flexBasis: 1, fontSize: 1, gap: 1, gridAutoColumns: 1, gridAutoRows: 1, gridTemplateColumns: 1, gridTemplateRows: 1, height: 1, inlineSize: 1, inset: 1, insetBlock: 1, insetBlockEnd: 1, insetBlockStart: 1, insetInline: 1, insetInlineEnd: 1, insetInlineStart: 1, left: 1, letterSpacing: 1, margin: 1, marginBlock: 1, marginBlockEnd: 1, marginBlockStart: 1, marginBottom: 1, marginInline: 1, marginInlineEnd: 1, marginInlineStart: 1, marginLeft: 1, marginRight: 1, marginTop: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, offsetDistance: 1, offsetRotate: 1, outline: 1, outlineOffset: 1, outlineWidth: 1, overflowClipMargin: 1, padding: 1, paddingBlock: 1, paddingBlockEnd: 1, paddingBlockStart: 1, paddingBottom: 1, paddingInline: 1, paddingInlineEnd: 1, paddingInlineStart: 1, paddingLeft: 1, paddingRight: 1, paddingTop: 1, perspective: 1, right: 1, rowGap: 1, scrollMargin: 1, scrollMarginBlock: 1, scrollMarginBlockEnd: 1, scrollMarginBlockStart: 1, scrollMarginBottom: 1, scrollMarginInline: 1, scrollMarginInlineEnd: 1, scrollMarginInlineStart: 1, scrollMarginLeft: 1, scrollMarginRight: 1, scrollMarginTop: 1, scrollPadding: 1, scrollPaddingBlock: 1, scrollPaddingBlockEnd: 1, scrollPaddingBlockStart: 1, scrollPaddingBottom: 1, scrollPaddingInline: 1, scrollPaddingInlineEnd: 1, scrollPaddingInlineStart: 1, scrollPaddingLeft: 1, scrollPaddingRight: 1, scrollPaddingTop: 1, shapeMargin: 1, textDecoration: 1, textDecorationThickness: 1, textIndent: 1, textUnderlineOffset: 1, top: 1, transitionDelay: 1, transitionDuration: 1, verticalAlign: 1, width: 1, wordSpacing: 1 };\nvar R6 = (e5) => String.fromCharCode(e5 + (e5 > 25 ? 39 : 97));\nvar z4 = (e5) => ((e6) => {\n  let t5, r5 = \"\";\n  for (t5 = Math.abs(e6); t5 > 52; t5 = t5 / 52 | 0)\n    r5 = R6(t5 % 52) + r5;\n  return R6(t5 % 52) + r5;\n})(((e6, t5) => {\n  let r5 = t5.length;\n  for (; r5; )\n    e6 = 33 * e6 ^ t5.charCodeAt(--r5);\n  return e6;\n})(5381, JSON.stringify(e5)) >>> 0);\nvar W4 = [\"themed\", \"global\", \"styled\", \"onevar\", \"resonevar\", \"allvar\", \"inline\"];\nvar j3 = (e5) => {\n  if (e5.href && !e5.href.startsWith(location.origin))\n    return false;\n  try {\n    return !!e5.cssRules;\n  } catch (e6) {\n    return false;\n  }\n};\nvar E5 = (e5) => {\n  let t5;\n  const r5 = () => {\n    const { cssRules: e6 } = t5.sheet;\n    return [].map.call(e6, (r6, n6) => {\n      const { cssText: i4 } = r6;\n      let o5 = \"\";\n      if (i4.startsWith(\"--sxs\"))\n        return \"\";\n      if (e6[n6 - 1] && (o5 = e6[n6 - 1].cssText).startsWith(\"--sxs\")) {\n        if (!r6.cssRules.length)\n          return \"\";\n        for (const e7 in t5.rules)\n          if (t5.rules[e7].group === r6)\n            return `--sxs{--sxs:${[...t5.rules[e7].cache].join(\" \")}}${i4}`;\n        return r6.cssRules.length ? `${o5}${i4}` : \"\";\n      }\n      return i4;\n    }).join(\"\");\n  }, n5 = () => {\n    if (t5) {\n      const { rules: e6, sheet: r6 } = t5;\n      if (!r6.deleteRule) {\n        for (; 3 === Object(Object(r6.cssRules)[0]).type; )\n          r6.cssRules.splice(0, 1);\n        r6.cssRules = [];\n      }\n      for (const t6 in e6)\n        delete e6[t6];\n    }\n    const i4 = Object(e5).styleSheets || [];\n    for (const e6 of i4)\n      if (j3(e6)) {\n        for (let i5 = 0, o6 = e6.cssRules; o6[i5]; ++i5) {\n          const l8 = Object(o6[i5]);\n          if (1 !== l8.type)\n            continue;\n          const s5 = Object(o6[i5 + 1]);\n          if (4 !== s5.type)\n            continue;\n          ++i5;\n          const { cssText: a7 } = l8;\n          if (!a7.startsWith(\"--sxs\"))\n            continue;\n          const c5 = a7.slice(14, -3).trim().split(/\\s+/), d6 = W4[c5[0]];\n          d6 && (t5 || (t5 = { sheet: e6, reset: n5, rules: {}, toString: r5 }), t5.rules[d6] = { group: s5, index: i5, cache: new Set(c5) });\n        }\n        if (t5)\n          break;\n      }\n    if (!t5) {\n      const i5 = (e6, t6) => ({ type: t6, cssRules: [], insertRule(e7, t7) {\n        this.cssRules.splice(t7, 0, i5(e7, { import: 3, undefined: 1 }[(e7.toLowerCase().match(/^@([a-z]+)/) || [])[1]] || 4));\n      }, get cssText() {\n        return \"@media{}\" === e6 ? `@media{${[].map.call(this.cssRules, (e7) => e7.cssText).join(\"\")}}` : e6;\n      } });\n      t5 = { sheet: e5 ? (e5.head || e5).appendChild(document.createElement(\"style\")).sheet : i5(\"\", \"text/css\"), rules: {}, reset: n5, toString: r5 };\n    }\n    const { sheet: o5, rules: l7 } = t5;\n    for (let e6 = W4.length - 1; e6 >= 0; --e6) {\n      const t6 = W4[e6];\n      if (!l7[t6]) {\n        const r6 = W4[e6 + 1], n6 = l7[r6] ? l7[r6].index : o5.cssRules.length;\n        o5.insertRule(\"@media{}\", n6), o5.insertRule(`--sxs{--sxs:${e6}}`, n6), l7[t6] = { group: o5.cssRules[n6 + 1], index: n6, cache: /* @__PURE__ */ new Set([e6]) };\n      }\n      v4(l7[t6]);\n    }\n  };\n  return n5(), t5;\n};\nvar v4 = (e5) => {\n  const t5 = e5.group;\n  let r5 = t5.cssRules.length;\n  e5.apply = (e6) => {\n    try {\n      t5.insertRule(e6, r5), ++r5;\n    } catch (e7) {\n    }\n  };\n};\nvar T4 = Symbol();\nvar w5 = o3();\nvar M2 = (e5, t5) => w5(e5, () => (...r5) => {\n  let n5 = { type: null, composers: /* @__PURE__ */ new Set() };\n  for (const t6 of r5)\n    if (null != t6)\n      if (t6[l5]) {\n        null == n5.type && (n5.type = t6[l5].type);\n        for (const e6 of t6[l5].composers)\n          n5.composers.add(e6);\n      } else\n        t6.constructor !== Object || t6.$$typeof ? null == n5.type && (n5.type = t6) : n5.composers.add(C5(t6, e5));\n  return null == n5.type && (n5.type = \"span\"), n5.composers.size || n5.composers.add([\"PJLV\", {}, [], [], {}, []]), P2(e5, n5, t5);\n});\nvar C5 = ({ variants: e5, compoundVariants: t5, defaultVariants: r5, ...n5 }, i4) => {\n  const o5 = `${S3(i4.prefix)}c-${z4(n5)}`, l7 = [], s5 = [], d6 = /* @__PURE__ */ Object.create(null), g6 = [];\n  for (const e6 in r5)\n    d6[e6] = String(r5[e6]);\n  if (\"object\" == typeof e5 && e5)\n    for (const t6 in e5) {\n      p6 = d6, u5 = t6, c3.call(p6, u5) || (d6[t6] = \"undefined\");\n      const r6 = e5[t6];\n      for (const e6 in r6) {\n        const n6 = { [t6]: String(e6) };\n        \"undefined\" === String(e6) && g6.push(t6);\n        const i5 = r6[e6], o6 = [n6, i5, !a5(i5)];\n        l7.push(o6);\n      }\n    }\n  var p6, u5;\n  if (\"object\" == typeof t5 && t5)\n    for (const e6 of t5) {\n      let { css: t6, ...r6 } = e6;\n      t6 = \"object\" == typeof t6 && t6 || {};\n      for (const e7 in r6)\n        r6[e7] = String(r6[e7]);\n      const n6 = [r6, t6, !a5(t6)];\n      s5.push(n6);\n    }\n  return [o5, n5, l7, s5, d6, g6];\n};\nvar P2 = (e5, t5, r5) => {\n  const [n5, i4, o5, a7] = L4(t5.composers), c5 = \"function\" == typeof t5.type || t5.type.$$typeof ? ((e6) => {\n    function t6() {\n      for (let r6 = 0; r6 < t6[T4].length; r6++) {\n        const [n6, i5] = t6[T4][r6];\n        e6.rules[n6].apply(i5);\n      }\n      return t6[T4] = [], null;\n    }\n    return t6[T4] = [], t6.rules = {}, W4.forEach((e7) => t6.rules[e7] = { apply: (r6) => t6[T4].push([e7, r6]) }), t6;\n  })(r5) : null, d6 = (c5 || r5).rules, g6 = `.${n5}${i4.length > 1 ? `:where(.${i4.slice(1).join(\".\")})` : \"\"}`, p6 = (l7) => {\n    l7 = \"object\" == typeof l7 && l7 || A4;\n    const { css: s5, ...p7 } = l7, u5 = {};\n    for (const e6 in o5)\n      if (delete p7[e6], e6 in l7) {\n        let t6 = l7[e6];\n        \"object\" == typeof t6 && t6 ? u5[e6] = { \"@initial\": o5[e6], ...t6 } : (t6 = String(t6), u5[e6] = \"undefined\" !== t6 || a7.has(e6) ? t6 : o5[e6]);\n      } else\n        u5[e6] = o5[e6];\n    const h6 = /* @__PURE__ */ new Set([...i4]);\n    for (const [n6, i5, o6, l8] of t5.composers) {\n      r5.rules.styled.cache.has(n6) || (r5.rules.styled.cache.add(n6), $4(i5, [`.${n6}`], [], e5, (e6) => {\n        d6.styled.apply(e6);\n      }));\n      const t6 = O4(o6, u5, e5.media), s6 = O4(l8, u5, e5.media, true);\n      for (const i6 of t6)\n        if (void 0 !== i6)\n          for (const [t7, o7, l9] of i6) {\n            const i7 = `${n6}-${z4(o7)}-${t7}`;\n            h6.add(i7);\n            const s7 = (l9 ? r5.rules.resonevar : r5.rules.onevar).cache, a8 = l9 ? d6.resonevar : d6.onevar;\n            s7.has(i7) || (s7.add(i7), $4(o7, [`.${i7}`], [], e5, (e6) => {\n              a8.apply(e6);\n            }));\n          }\n      for (const t7 of s6)\n        if (void 0 !== t7)\n          for (const [i6, o7] of t7) {\n            const t8 = `${n6}-${z4(o7)}-${i6}`;\n            h6.add(t8), r5.rules.allvar.cache.has(t8) || (r5.rules.allvar.cache.add(t8), $4(o7, [`.${t8}`], [], e5, (e6) => {\n              d6.allvar.apply(e6);\n            }));\n          }\n    }\n    if (\"object\" == typeof s5 && s5) {\n      const t6 = `${n5}-i${z4(s5)}-css`;\n      h6.add(t6), r5.rules.inline.cache.has(t6) || (r5.rules.inline.cache.add(t6), $4(s5, [`.${t6}`], [], e5, (e6) => {\n        d6.inline.apply(e6);\n      }));\n    }\n    for (const e6 of String(l7.className || \"\").trim().split(/\\s+/))\n      e6 && h6.add(e6);\n    const f5 = p7.className = [...h6].join(\" \");\n    return { type: t5.type, className: f5, selector: g6, props: p7, toString: () => f5, deferredInjector: c5 };\n  };\n  return s3(p6, { className: n5, selector: g6, [l5]: t5, toString: () => (r5.rules.styled.cache.has(n5) || p6(), n5) });\n};\nvar L4 = (e5) => {\n  let t5 = \"\";\n  const r5 = [], n5 = {}, i4 = [];\n  for (const [o5, , , , l7, s5] of e5) {\n    \"\" === t5 && (t5 = o5), r5.push(o5), i4.push(...s5);\n    for (const e6 in l7) {\n      const t6 = l7[e6];\n      (void 0 === n5[e6] || \"undefined\" !== t6 || s5.includes(t6)) && (n5[e6] = t6);\n    }\n  }\n  return [t5, r5, n5, new Set(i4)];\n};\nvar O4 = (e5, t5, r5, n5) => {\n  const i4 = [];\n  e:\n    for (let [o5, l7, s5] of e5) {\n      if (s5)\n        continue;\n      let e6, a7 = 0, c5 = false;\n      for (e6 in o5) {\n        const n6 = o5[e6];\n        let i5 = t5[e6];\n        if (i5 !== n6) {\n          if (\"object\" != typeof i5 || !i5)\n            continue e;\n          {\n            let e7, t6, o6 = 0;\n            for (const l8 in i5) {\n              if (n6 === String(i5[l8])) {\n                if (\"@initial\" !== l8) {\n                  const e8 = l8.slice(1);\n                  (t6 = t6 || []).push(e8 in r5 ? r5[e8] : l8.replace(/^@media ?/, \"\")), c5 = true;\n                }\n                a7 += o6, e7 = true;\n              }\n              ++o6;\n            }\n            if (t6 && t6.length && (l7 = { [\"@media \" + t6.join(\", \")]: l7 }), !e7)\n              continue e;\n          }\n        }\n      }\n      (i4[a7] = i4[a7] || []).push([n5 ? \"cv\" : `${e6}-${o5[e6]}`, l7, c5]);\n    }\n  return i4;\n};\nvar A4 = {};\nvar N4 = o3();\nvar D5 = (e5, t5) => N4(e5, () => (...r5) => {\n  const n5 = () => {\n    for (let n6 of r5) {\n      n6 = \"object\" == typeof n6 && n6 || {};\n      let r6 = z4(n6);\n      if (!t5.rules.global.cache.has(r6)) {\n        if (t5.rules.global.cache.add(r6), \"@import\" in n6) {\n          let e6 = [].indexOf.call(t5.sheet.cssRules, t5.rules.themed.group) - 1;\n          for (let r7 of [].concat(n6[\"@import\"]))\n            r7 = r7.includes('\"') || r7.includes(\"'\") ? r7 : `\"${r7}\"`, t5.sheet.insertRule(`@import ${r7};`, e6++);\n          delete n6[\"@import\"];\n        }\n        $4(n6, [], [], e5, (e6) => {\n          t5.rules.global.apply(e6);\n        });\n      }\n    }\n    return \"\";\n  };\n  return s3(n5, { toString: n5 });\n});\nvar H4 = o3();\nvar V5 = (e5, t5) => H4(e5, () => (r5) => {\n  const n5 = `${S3(e5.prefix)}k-${z4(r5)}`, i4 = () => {\n    if (!t5.rules.global.cache.has(n5)) {\n      t5.rules.global.cache.add(n5);\n      const i5 = [];\n      $4(r5, [], [], e5, (e6) => i5.push(e6));\n      const o5 = `@keyframes ${n5}{${i5.join(\"\")}}`;\n      t5.rules.global.apply(o5);\n    }\n    return n5;\n  };\n  return s3(i4, { get name() {\n    return i4();\n  }, toString: i4 });\n});\nvar G4 = class {\n  constructor(e5, t5, r5, n5) {\n    this.token = null == e5 ? \"\" : String(e5), this.value = null == t5 ? \"\" : String(t5), this.scale = null == r5 ? \"\" : String(r5), this.prefix = null == n5 ? \"\" : String(n5);\n  }\n  get computedValue() {\n    return \"var(\" + this.variable + \")\";\n  }\n  get variable() {\n    return \"--\" + S3(this.prefix) + S3(this.scale) + this.token;\n  }\n  toString() {\n    return this.computedValue;\n  }\n};\nvar F3 = o3();\nvar J2 = (e5, t5) => F3(e5, () => (r5, n5) => {\n  n5 = \"object\" == typeof r5 && r5 || Object(n5);\n  const i4 = `.${r5 = (r5 = \"string\" == typeof r5 ? r5 : \"\") || `${S3(e5.prefix)}t-${z4(n5)}`}`, o5 = {}, l7 = [];\n  for (const t6 in n5) {\n    o5[t6] = {};\n    for (const r6 in n5[t6]) {\n      const i5 = `--${S3(e5.prefix)}${t6}-${r6}`, s6 = k4(String(n5[t6][r6]), e5.prefix, t6);\n      o5[t6][r6] = new G4(r6, s6, t6, e5.prefix), l7.push(`${i5}:${s6}`);\n    }\n  }\n  const s5 = () => {\n    if (l7.length && !t5.rules.themed.cache.has(r5)) {\n      t5.rules.themed.cache.add(r5);\n      const i5 = `${n5 === e5.theme ? \":root,\" : \"\"}.${r5}{${l7.join(\";\")}}`;\n      t5.rules.themed.apply(i5);\n    }\n    return r5;\n  };\n  return { ...o5, get className() {\n    return s5();\n  }, selector: i4, toString: s5 };\n});\nvar U3 = o3();\nvar X2;\nvar Y2 = o3();\nvar q3 = (e5) => {\n  const t5 = ((e6) => {\n    let t6 = false;\n    const r5 = U3(e6, (e7) => {\n      t6 = true;\n      const r6 = \"prefix\" in (e7 = \"object\" == typeof e7 && e7 || {}) ? String(e7.prefix) : \"\", i4 = \"object\" == typeof e7.media && e7.media || {}, o5 = \"object\" == typeof e7.root ? e7.root || null : globalThis.document || null, l7 = \"object\" == typeof e7.theme && e7.theme || {}, s5 = { prefix: r6, media: i4, theme: l7, themeMap: \"object\" == typeof e7.themeMap && e7.themeMap || { ...n3 }, utils: \"object\" == typeof e7.utils && e7.utils || {} }, a7 = E5(o5), c5 = { css: M2(s5, a7), globalCss: D5(s5, a7), keyframes: V5(s5, a7), createTheme: J2(s5, a7), reset() {\n        a7.reset(), c5.theme.toString();\n      }, theme: {}, sheet: a7, config: s5, prefix: r6, getCssText: a7.toString, toString: a7.toString };\n      return String(c5.theme = c5.createTheme(l7)), c5;\n    });\n    return t6 || r5.reset(), r5;\n  })(e5);\n  return t5.styled = (({ config: e6, sheet: t6 }) => Y2(e6, () => {\n    const r5 = M2(e6, t6);\n    return (...e7) => {\n      const t7 = r5(...e7), n5 = t7[l5].type, i4 = import_react31.default.forwardRef((e8, r6) => {\n        const i5 = e8 && e8.as || n5, { props: o5, deferredInjector: l7 } = t7(e8);\n        return delete o5.as, o5.ref = r6, l7 ? import_react31.default.createElement(import_react31.default.Fragment, null, import_react31.default.createElement(i5, o5), import_react31.default.createElement(l7, null)) : import_react31.default.createElement(i5, o5);\n      });\n      return i4.className = t7.className, i4.displayName = `Styled.${n5.displayName || n5.name || n5}`, i4.selector = t7.selector, i4.toString = () => t7.selector, i4[l5] = t7[l5], i4;\n    };\n  }))(t5), t5;\n};\nvar K4 = () => X2 || (X2 = q3());\nvar re2 = (...e5) => K4().styled(...e5);\n\n// src/components/Tldraw/styles/stitches.config.ts\nvar { styled, createTheme } = q3({\n  themeMap: {\n    ...n3\n  },\n  theme: {\n    colors: {\n      bounds: \"rgba(65, 132, 244, 1.000)\",\n      boundsBg: \"rgba(65, 132, 244, 0.05)\",\n      hover: \"#ececec\",\n      overlay: \"rgba(0, 0, 0, 0.15)\",\n      overlayContrast: \"rgba(255, 255, 255, 0.15)\",\n      panel: \"#fefefe\",\n      panelContrast: \"#ffffff\",\n      selected: \"rgba(66, 133, 244, 1.000)\",\n      selectedContrast: \"#fefefe\",\n      text: \"#333333\",\n      tooltip: \"#1d1d1d\",\n      tooltipContrast: \"#ffffff\",\n      warn: \"rgba(255, 100, 100, 1)\",\n      canvas: \"rgb(248, 249, 250)\"\n    },\n    shadows: {\n      2: \"0px 1px 1px rgba(0, 0, 0, 0.14)\",\n      3: \"0px 2px 3px rgba(0, 0, 0, 0.14)\",\n      4: \"0px 4px 5px -1px rgba(0, 0, 0, 0.14)\",\n      8: \"0px 12px 17px rgba(0, 0, 0, 0.14)\",\n      12: \"0px 12px 17px rgba(0, 0, 0, 0.14)\",\n      24: \"0px 24px 38px rgba(0, 0, 0, 0.14)\",\n      key: \"1px 1px rgba(0,0,0,1)\",\n      panel: `0px 0px 16px -1px rgba(0, 0, 0, 0.05), \n        0px 0px 16px -8px rgba(0, 0, 0, 0.05), \n        0px 0px 16px -12px rgba(0, 0, 0, 0.12),\n        0px 0px 2px 0px rgba(0, 0, 0, 0.08)`\n    },\n    space: {\n      0: \"2px\",\n      1: \"3px\",\n      2: \"4px\",\n      3: \"8px\",\n      4: \"12px\",\n      5: \"16px\",\n      6: \"32px\",\n      7: \"48px\"\n    },\n    fontSizes: {\n      0: \"10px\",\n      1: \"12px\",\n      2: \"13px\",\n      3: \"16px\",\n      4: \"18px\"\n    },\n    fonts: {\n      ui: '\"Recursive\", system-ui, sans-serif',\n      body: '\"Recursive\", system-ui, sans-serif',\n      mono: '\"Recursive Mono\", monospace'\n    },\n    fontWeights: {},\n    lineHeights: {},\n    letterSpacings: {},\n    sizes: {},\n    borderWidths: {\n      0: \"$1\"\n    },\n    borderStyles: {},\n    radii: {\n      0: \"2px\",\n      1: \"4px\",\n      2: \"8px\",\n      3: \"12px\",\n      4: \"16px\"\n    },\n    zIndices: {},\n    transitions: {}\n  },\n  media: {\n    micro: \"(max-width: 370px)\",\n    sm: \"(min-width: 640px)\",\n    md: \"(min-width: 768px)\",\n    lg: \"(min-width: 1024px)\"\n  },\n  utils: {\n    zStrokeWidth: () => (value) => {\n      if (Array.isArray(value)) {\n        return {\n          strokeWidth: `calc(${value[0]}px / var(--camera-zoom))`\n        };\n      }\n      return {\n        strokeWidth: `calc(${value}px / var(--camera-zoom))`\n      };\n    }\n  }\n});\n\n// src/components/Tldraw/components/Primitives/Divider/Divider.tsx\nvar Divider = styled(\"hr\", {\n  height: 0,\n  paddingTop: 1,\n  width: \"calc(100%+8px)\",\n  backgroundColor: \"$hover\",\n  border: \"none\",\n  margin: \"$2 -4px\"\n});\n\n// src/components/Tldraw/components/Primitives/MenuContent/MenuContent.ts\nvar MenuContent = styled(\"div\", {\n  position: \"relative\",\n  overflow: \"hidden\",\n  userSelect: \"none\",\n  display: \"flex\",\n  flexDirection: \"column\",\n  zIndex: 99997,\n  minWidth: 180,\n  pointerEvents: \"all\",\n  backgroundColor: \"$panel\",\n  border: \"1px solid $panelContrast\",\n  boxShadow: \"$panel\",\n  padding: \"$2 $2\",\n  borderRadius: \"$3\",\n  font: \"$ui\",\n  maxHeight: \"100vh\",\n  overflowY: \"auto\",\n  overflowX: \"hidden\",\n  \"&::webkit-scrollbar\": {\n    display: \"none\"\n  },\n  \"-ms-overflow-style\": \"none\",\n  scrollbarWidth: \"none\",\n  variants: {\n    size: {\n      small: {\n        minWidth: 72\n      }\n    },\n    overflow: {\n      true: {\n        maxHeight: \"60vh\"\n      }\n    }\n  }\n});\n\n// node_modules/@radix-ui/react-dropdown-menu/dist/index.module.js\nvar import_react33 = require(\"react\");\nvar $d08ef79370b62062$var$DROPDOWN_MENU_NAME = \"DropdownMenu\";\nvar [$d08ef79370b62062$var$createDropdownMenuContext, $d08ef79370b62062$export$c0623cd925aeb687] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($d08ef79370b62062$var$DROPDOWN_MENU_NAME, [\n  $6cc32821e9371a1c$export$4027731b685e72eb\n]);\nvar $d08ef79370b62062$var$useMenuScope = $6cc32821e9371a1c$export$4027731b685e72eb();\nvar [$d08ef79370b62062$var$DropdownMenuProvider, $d08ef79370b62062$var$useDropdownMenuContext] = $d08ef79370b62062$var$createDropdownMenuContext($d08ef79370b62062$var$DROPDOWN_MENU_NAME);\nvar $d08ef79370b62062$export$e44a253a59704894 = (props) => {\n  const { __scopeDropdownMenu, children, dir, open: openProp, defaultOpen, onOpenChange, modal = true } = props;\n  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);\n  const triggerRef = (0, import_react33.useRef)(null);\n  const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange\n  });\n  return /* @__PURE__ */ (0, import_react33.createElement)($d08ef79370b62062$var$DropdownMenuProvider, {\n    scope: __scopeDropdownMenu,\n    triggerId: $1746a345f3d73bb7$export$f680877a34711e37(),\n    triggerRef,\n    contentId: $1746a345f3d73bb7$export$f680877a34711e37(),\n    open,\n    onOpenChange: setOpen,\n    onOpenToggle: (0, import_react33.useCallback)(\n      () => setOpen(\n        (prevOpen) => !prevOpen\n      ),\n      [\n        setOpen\n      ]\n    ),\n    modal\n  }, /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$be92b6f5f03c0fe9, _extends({}, menuScope, {\n    open,\n    onOpenChange: setOpen,\n    dir,\n    modal\n  }), children));\n};\nvar $d08ef79370b62062$var$TRIGGER_NAME = \"DropdownMenuTrigger\";\nvar $d08ef79370b62062$export$d2469213b3befba9 = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {\n  const { __scopeDropdownMenu, disabled = false, ...triggerProps } = props;\n  const context = $d08ef79370b62062$var$useDropdownMenuContext($d08ef79370b62062$var$TRIGGER_NAME, __scopeDropdownMenu);\n  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);\n  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$b688253958b8dfe7, _extends({\n    asChild: true\n  }, menuScope), /* @__PURE__ */ (0, import_react33.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({\n    type: \"button\",\n    id: context.triggerId,\n    \"aria-haspopup\": \"menu\",\n    \"aria-expanded\": context.open,\n    \"aria-controls\": context.open ? context.contentId : void 0,\n    \"data-state\": context.open ? \"open\" : \"closed\",\n    \"data-disabled\": disabled ? \"\" : void 0,\n    disabled\n  }, triggerProps, {\n    ref: $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, context.triggerRef),\n    onPointerDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDown, (event) => {\n      if (!disabled && event.button === 0 && event.ctrlKey === false) {\n        context.onOpenToggle();\n        if (!context.open)\n          event.preventDefault();\n      }\n    }),\n    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {\n      if (disabled)\n        return;\n      if ([\n        \"Enter\",\n        \" \"\n      ].includes(event.key))\n        context.onOpenToggle();\n      if (event.key === \"ArrowDown\")\n        context.onOpenChange(true);\n      if ([\n        \"Enter\",\n        \" \",\n        \"ArrowDown\"\n      ].includes(event.key))\n        event.preventDefault();\n    })\n  })));\n});\nvar $d08ef79370b62062$export$cd369b4d4d54efc9 = (props) => {\n  const { __scopeDropdownMenu, ...portalProps } = props;\n  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);\n  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$602eac185826482c, _extends({}, menuScope, portalProps));\n};\nvar $d08ef79370b62062$var$CONTENT_NAME = \"DropdownMenuContent\";\nvar $d08ef79370b62062$export$6e76d93a37c01248 = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {\n  const { __scopeDropdownMenu, ...contentProps } = props;\n  const context = $d08ef79370b62062$var$useDropdownMenuContext($d08ef79370b62062$var$CONTENT_NAME, __scopeDropdownMenu);\n  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);\n  const hasInteractedOutsideRef = (0, import_react33.useRef)(false);\n  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$7c6e2c02157bb7d2, _extends({\n    id: context.contentId,\n    \"aria-labelledby\": context.triggerId\n  }, menuScope, contentProps, {\n    ref: forwardedRef,\n    onCloseAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onCloseAutoFocus, (event) => {\n      var _context$triggerRef$c;\n      if (!hasInteractedOutsideRef.current)\n        (_context$triggerRef$c = context.triggerRef.current) === null || _context$triggerRef$c === void 0 || _context$triggerRef$c.focus();\n      hasInteractedOutsideRef.current = false;\n      event.preventDefault();\n    }),\n    onInteractOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onInteractOutside, (event) => {\n      const originalEvent = event.detail.originalEvent;\n      const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;\n      const isRightClick = originalEvent.button === 2 || ctrlLeftClick;\n      if (!context.modal || isRightClick)\n        hasInteractedOutsideRef.current = true;\n    }),\n    style: {\n      ...props.style,\n      [\"--radix-dropdown-menu-content-transform-origin\"]: \"var(--radix-popper-transform-origin)\"\n    }\n  }));\n});\nvar $d08ef79370b62062$export$ed97964d1871885d = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {\n  const { __scopeDropdownMenu, ...itemProps } = props;\n  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);\n  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$6d08773d2e66f8f2, _extends({}, menuScope, itemProps, {\n    ref: forwardedRef\n  }));\n});\nvar $d08ef79370b62062$export$53a69729da201fa9 = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {\n  const { __scopeDropdownMenu, ...checkboxItemProps } = props;\n  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);\n  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$16ce288f89fa631c, _extends({}, menuScope, checkboxItemProps, {\n    ref: forwardedRef\n  }));\n});\nvar $d08ef79370b62062$export$3323ad73d55f587e = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {\n  const { __scopeDropdownMenu, ...radioGroupProps } = props;\n  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);\n  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$a98f0dcb43a68a25, _extends({}, menuScope, radioGroupProps, {\n    ref: forwardedRef\n  }));\n});\nvar $d08ef79370b62062$export$e4f69b41b1637536 = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {\n  const { __scopeDropdownMenu, ...radioItemProps } = props;\n  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);\n  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$371ab307eab489c0, _extends({}, menuScope, radioItemProps, {\n    ref: forwardedRef\n  }));\n});\nvar $d08ef79370b62062$export$42355ae145153fb6 = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {\n  const { __scopeDropdownMenu, ...itemIndicatorProps } = props;\n  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);\n  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$c3468e2714d175fa, _extends({}, menuScope, itemIndicatorProps, {\n    ref: forwardedRef\n  }));\n});\nvar $d08ef79370b62062$export$da160178fd3bc7e9 = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {\n  const { __scopeDropdownMenu, ...separatorProps } = props;\n  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);\n  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$1ff3c3f08ae963c0, _extends({}, menuScope, separatorProps, {\n    ref: forwardedRef\n  }));\n});\nvar $d08ef79370b62062$export$34b8980744021ec5 = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {\n  const { __scopeDropdownMenu, ...arrowProps } = props;\n  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);\n  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$21b07c8f274aebd5, _extends({}, menuScope, arrowProps, {\n    ref: forwardedRef\n  }));\n});\nvar $d08ef79370b62062$export$2f307d81a64f5442 = (props) => {\n  const { __scopeDropdownMenu, children, open: openProp, onOpenChange, defaultOpen } = props;\n  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);\n  const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange\n  });\n  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$d7a01e11500dfb6f, _extends({}, menuScope, {\n    open,\n    onOpenChange: setOpen\n  }), children);\n};\nvar $d08ef79370b62062$export$21dcb7ec56f874cf = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {\n  const { __scopeDropdownMenu, ...subTriggerProps } = props;\n  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);\n  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$2ea8a7a591ac5eac, _extends({}, menuScope, subTriggerProps, {\n    ref: forwardedRef\n  }));\n});\nvar $d08ef79370b62062$export$f34ec8bc2482cc5f = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {\n  const { __scopeDropdownMenu, ...subContentProps } = props;\n  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);\n  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$6d4de93b380beddf, _extends({}, menuScope, subContentProps, {\n    ref: forwardedRef,\n    style: {\n      ...props.style,\n      [\"--radix-dropdown-menu-content-transform-origin\"]: \"var(--radix-popper-transform-origin)\"\n    }\n  }));\n});\nvar $d08ef79370b62062$export$be92b6f5f03c0fe9 = $d08ef79370b62062$export$e44a253a59704894;\nvar $d08ef79370b62062$export$41fb9f06171c75f4 = $d08ef79370b62062$export$d2469213b3befba9;\nvar $d08ef79370b62062$export$602eac185826482c = $d08ef79370b62062$export$cd369b4d4d54efc9;\nvar $d08ef79370b62062$export$7c6e2c02157bb7d2 = $d08ef79370b62062$export$6e76d93a37c01248;\nvar $d08ef79370b62062$export$6d08773d2e66f8f2 = $d08ef79370b62062$export$ed97964d1871885d;\nvar $d08ef79370b62062$export$16ce288f89fa631c = $d08ef79370b62062$export$53a69729da201fa9;\nvar $d08ef79370b62062$export$a98f0dcb43a68a25 = $d08ef79370b62062$export$3323ad73d55f587e;\nvar $d08ef79370b62062$export$371ab307eab489c0 = $d08ef79370b62062$export$e4f69b41b1637536;\nvar $d08ef79370b62062$export$c3468e2714d175fa = $d08ef79370b62062$export$42355ae145153fb6;\nvar $d08ef79370b62062$export$1ff3c3f08ae963c0 = $d08ef79370b62062$export$da160178fd3bc7e9;\nvar $d08ef79370b62062$export$21b07c8f274aebd5 = $d08ef79370b62062$export$34b8980744021ec5;\nvar $d08ef79370b62062$export$d7a01e11500dfb6f = $d08ef79370b62062$export$2f307d81a64f5442;\nvar $d08ef79370b62062$export$2ea8a7a591ac5eac = $d08ef79370b62062$export$21dcb7ec56f874cf;\nvar $d08ef79370b62062$export$6d4de93b380beddf = $d08ef79370b62062$export$f34ec8bc2482cc5f;\n\n// src/components/Tldraw/components/Primitives/RowButton/RowButton.tsx\nvar React9 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/components/Primitives/Kbd/Kbd.tsx\nvar import_jsx_runtime2 = require(\"react/jsx-runtime\");\nvar commandKey = () => C3.isDarwin() ? \"\\u2318\" : \"Ctrl\";\nfunction Kbd({ variant, children }) {\n  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(StyledKbd, { variant, children: children.split(\"\").map((k6, index2) => {\n    return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"span\", { children: k6.replace(\"#\", commandKey()) }, index2);\n  }) });\n}\nvar StyledKbd = styled(\"kbd\", {\n  marginLeft: \"$3\",\n  textShadow: \"$2\",\n  textAlign: \"center\",\n  fontSize: \"$0\",\n  fontFamily: \"$ui\",\n  color: \"$text\",\n  background: \"none\",\n  fontWeight: 400,\n  gap: \"$1\",\n  display: \"flex\",\n  alignItems: \"center\",\n  \"& > span\": {\n    padding: \"$0\",\n    borderRadius: \"$0\",\n    display: \"flex\",\n    alignItems: \"center\",\n    justifyContent: \"center\"\n  },\n  variants: {\n    variant: {\n      tooltip: {\n        \"& > span\": {\n          color: \"$tooltipContrast\",\n          background: \"$overlayContrast\",\n          boxShadow: \"$key\",\n          width: \"20px\",\n          height: \"20px\"\n        }\n      },\n      menu: {}\n    }\n  }\n});\n\n// src/components/Tldraw/components/Primitives/SmallIcon/SmallIcon.tsx\nvar SmallIcon = styled(\"div\", {\n  height: \"100%\",\n  borderRadius: \"4px\",\n  marginRight: \"1px\",\n  width: \"fit-content\",\n  display: \"grid\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  outline: \"none\",\n  border: \"none\",\n  pointerEvents: \"all\",\n  cursor: \"pointer\",\n  color: \"currentColor\",\n  \"& svg\": {\n    height: 16,\n    width: 16,\n    strokeWidth: 1\n  },\n  \"& > *\": {\n    gridRow: 1,\n    gridColumn: 1\n  }\n});\n\n// src/components/Tldraw/components/breakpoints.tsx\nvar breakpoints = {\n  \"@initial\": \"mobile\",\n  \"@micro\": \"micro\",\n  \"@sm\": \"small\",\n  \"@md\": \"medium\",\n  \"@lg\": \"large\"\n};\n\n// src/components/Tldraw/components/Primitives/RowButton/RowButton.tsx\nvar import_jsx_runtime3 = require(\"react/jsx-runtime\");\nvar RowButton = React9.forwardRef(\n  ({ onClick, isActive = false, isWarning = false, hasIndicator = false, hasArrow = false, disabled = false, variant, kbd, children, ...rest }, reference) => {\n    return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(\n      StyledRowButton,\n      {\n        ref: reference,\n        bp: breakpoints,\n        isWarning,\n        isActive,\n        disabled,\n        onClick,\n        variant,\n        ...rest,\n        children: /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(StyledRowButtonInner, { children: [\n          children,\n          kbd ? /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Kbd, { variant: \"menu\", children: kbd }) : void 0,\n          hasIndicator && /* @__PURE__ */ (0, import_jsx_runtime3.jsx)($d08ef79370b62062$export$c3468e2714d175fa, { dir: \"ltr\", children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(SmallIcon, { children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(CheckIcon, {}) }) }),\n          hasArrow && /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(SmallIcon, { children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(ChevronRightIcon, {}) })\n        ] })\n      }\n    );\n  }\n);\nvar StyledRowButtonInner = styled(\"div\", {\n  height: \"100%\",\n  width: \"100%\",\n  backgroundColor: \"$panel\",\n  borderRadius: \"$2\",\n  display: \"flex\",\n  gap: \"$1\",\n  flexDirection: \"row\",\n  alignItems: \"center\",\n  padding: \"0 $3\",\n  justifyContent: \"space-between\",\n  border: \"1px solid transparent\",\n  \"& svg\": {\n    position: \"relative\",\n    stroke: \"$overlay\",\n    strokeWidth: 1,\n    zIndex: 1\n  },\n  [`& > ${SmallIcon}`]: {\n    paddingLeft: \"$3\"\n  }\n});\nvar StyledRowButton = styled(\"button\", {\n  position: \"relative\",\n  width: \"100%\",\n  background: \"none\",\n  border: \"none\",\n  cursor: \"pointer\",\n  height: 32,\n  minHeight: 32,\n  outline: \"none\",\n  color: \"$text\",\n  fontFamily: \"$ui\",\n  fontWeight: 400,\n  fontSize: \"$1\",\n  borderRadius: 4,\n  userSelect: \"none\",\n  margin: 0,\n  padding: \"0 0\",\n  \"&[data-disabled]\": {\n    opacity: 0.3\n  },\n  \"&:disabled\": {\n    opacity: 0.3\n  },\n  [`&:focus:not(:disabled) ${StyledRowButtonInner}`]: {\n    backgroundColor: \"$hover\"\n  },\n  \"& a\": {\n    textDecoration: \"none\",\n    color: \"$text\"\n  },\n  variants: {\n    bp: {\n      mobile: {},\n      small: {}\n    },\n    variant: {\n      styleMenu: {\n        margin: \"$1 0 $1 0\"\n      },\n      wide: {\n        gridColumn: \"1 / span 4\"\n      }\n    },\n    size: {\n      icon: {\n        padding: \"4px \",\n        width: \"auto\"\n      }\n    },\n    isWarning: {\n      true: {\n        color: \"$warn\"\n      }\n    },\n    isActive: {\n      true: {\n        backgroundColor: \"$hover\"\n      },\n      false: {}\n    }\n  }\n});\n\n// src/components/Tldraw/components/Primitives/ToolButton/ToolButton.tsx\nvar React15 = __toESM(require(\"react\"));\n\n// node_modules/@radix-ui/react-tooltip/dist/index.module.js\nvar import_react35 = require(\"react\");\n\n// node_modules/@radix-ui/react-visually-hidden/dist/index.module.js\nvar import_react34 = require(\"react\");\nvar $ea1ef594cf570d83$export$439d29a4e110a164 = /* @__PURE__ */ (0, import_react34.forwardRef)((props, forwardedRef) => {\n  return /* @__PURE__ */ (0, import_react34.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({}, props, {\n    ref: forwardedRef,\n    style: {\n      position: \"absolute\",\n      border: 0,\n      width: 1,\n      height: 1,\n      padding: 0,\n      margin: -1,\n      overflow: \"hidden\",\n      clip: \"rect(0, 0, 0, 0)\",\n      whiteSpace: \"nowrap\",\n      wordWrap: \"normal\",\n      ...props.style\n    }\n  }));\n});\nvar $ea1ef594cf570d83$export$be92b6f5f03c0fe9 = $ea1ef594cf570d83$export$439d29a4e110a164;\n\n// node_modules/@radix-ui/react-tooltip/dist/index.module.js\nvar [$a093c7e1ec25a057$var$createTooltipContext, $a093c7e1ec25a057$export$1c540a2224f0d865] = $c512c27ab02ef895$export$50c7b4e9d9f19c1(\"Tooltip\", [\n  $cf1ac5d9fe0e8206$export$722aac194ae923\n]);\nvar $a093c7e1ec25a057$var$usePopperScope = $cf1ac5d9fe0e8206$export$722aac194ae923();\nvar $a093c7e1ec25a057$var$PROVIDER_NAME = \"TooltipProvider\";\nvar $a093c7e1ec25a057$var$DEFAULT_DELAY_DURATION = 700;\nvar $a093c7e1ec25a057$var$TOOLTIP_OPEN = \"tooltip.open\";\nvar [$a093c7e1ec25a057$var$TooltipProviderContextProvider, $a093c7e1ec25a057$var$useTooltipProviderContext] = $a093c7e1ec25a057$var$createTooltipContext($a093c7e1ec25a057$var$PROVIDER_NAME);\nvar $a093c7e1ec25a057$export$f78649fb9ca566b8 = (props) => {\n  const { __scopeTooltip, delayDuration = $a093c7e1ec25a057$var$DEFAULT_DELAY_DURATION, skipDelayDuration = 300, disableHoverableContent = false, children } = props;\n  const [isOpenDelayed, setIsOpenDelayed] = (0, import_react35.useState)(true);\n  const isPointerInTransitRef = (0, import_react35.useRef)(false);\n  const skipDelayTimerRef = (0, import_react35.useRef)(0);\n  (0, import_react35.useEffect)(() => {\n    const skipDelayTimer = skipDelayTimerRef.current;\n    return () => window.clearTimeout(skipDelayTimer);\n  }, []);\n  return /* @__PURE__ */ (0, import_react35.createElement)($a093c7e1ec25a057$var$TooltipProviderContextProvider, {\n    scope: __scopeTooltip,\n    isOpenDelayed,\n    delayDuration,\n    onOpen: (0, import_react35.useCallback)(() => {\n      window.clearTimeout(skipDelayTimerRef.current);\n      setIsOpenDelayed(false);\n    }, []),\n    onClose: (0, import_react35.useCallback)(() => {\n      window.clearTimeout(skipDelayTimerRef.current);\n      skipDelayTimerRef.current = window.setTimeout(\n        () => setIsOpenDelayed(true),\n        skipDelayDuration\n      );\n    }, [\n      skipDelayDuration\n    ]),\n    isPointerInTransitRef,\n    onPointerInTransitChange: (0, import_react35.useCallback)((inTransit) => {\n      isPointerInTransitRef.current = inTransit;\n    }, []),\n    disableHoverableContent\n  }, children);\n};\nvar $a093c7e1ec25a057$var$TOOLTIP_NAME = \"Tooltip\";\nvar [$a093c7e1ec25a057$var$TooltipContextProvider, $a093c7e1ec25a057$var$useTooltipContext] = $a093c7e1ec25a057$var$createTooltipContext($a093c7e1ec25a057$var$TOOLTIP_NAME);\nvar $a093c7e1ec25a057$export$28c660c63b792dea = (props) => {\n  const { __scopeTooltip, children, open: openProp, defaultOpen = false, onOpenChange, disableHoverableContent: disableHoverableContentProp, delayDuration: delayDurationProp } = props;\n  const providerContext = $a093c7e1ec25a057$var$useTooltipProviderContext($a093c7e1ec25a057$var$TOOLTIP_NAME, props.__scopeTooltip);\n  const popperScope = $a093c7e1ec25a057$var$usePopperScope(__scopeTooltip);\n  const [trigger2, setTrigger] = (0, import_react35.useState)(null);\n  const contentId = $1746a345f3d73bb7$export$f680877a34711e37();\n  const openTimerRef = (0, import_react35.useRef)(0);\n  const disableHoverableContent = disableHoverableContentProp !== null && disableHoverableContentProp !== void 0 ? disableHoverableContentProp : providerContext.disableHoverableContent;\n  const delayDuration = delayDurationProp !== null && delayDurationProp !== void 0 ? delayDurationProp : providerContext.delayDuration;\n  const wasOpenDelayedRef = (0, import_react35.useRef)(false);\n  const [open1 = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: (open) => {\n      if (open) {\n        providerContext.onOpen();\n        document.dispatchEvent(new CustomEvent($a093c7e1ec25a057$var$TOOLTIP_OPEN));\n      } else\n        providerContext.onClose();\n      onOpenChange === null || onOpenChange === void 0 || onOpenChange(open);\n    }\n  });\n  const stateAttribute = (0, import_react35.useMemo)(() => {\n    return open1 ? wasOpenDelayedRef.current ? \"delayed-open\" : \"instant-open\" : \"closed\";\n  }, [\n    open1\n  ]);\n  const handleOpen = (0, import_react35.useCallback)(() => {\n    window.clearTimeout(openTimerRef.current);\n    wasOpenDelayedRef.current = false;\n    setOpen(true);\n  }, [\n    setOpen\n  ]);\n  const handleClose = (0, import_react35.useCallback)(() => {\n    window.clearTimeout(openTimerRef.current);\n    setOpen(false);\n  }, [\n    setOpen\n  ]);\n  const handleDelayedOpen = (0, import_react35.useCallback)(() => {\n    window.clearTimeout(openTimerRef.current);\n    openTimerRef.current = window.setTimeout(() => {\n      wasOpenDelayedRef.current = true;\n      setOpen(true);\n    }, delayDuration);\n  }, [\n    delayDuration,\n    setOpen\n  ]);\n  (0, import_react35.useEffect)(() => {\n    return () => window.clearTimeout(openTimerRef.current);\n  }, []);\n  return /* @__PURE__ */ (0, import_react35.createElement)($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9, popperScope, /* @__PURE__ */ (0, import_react35.createElement)($a093c7e1ec25a057$var$TooltipContextProvider, {\n    scope: __scopeTooltip,\n    contentId,\n    open: open1,\n    stateAttribute,\n    trigger: trigger2,\n    onTriggerChange: setTrigger,\n    onTriggerEnter: (0, import_react35.useCallback)(() => {\n      if (providerContext.isOpenDelayed)\n        handleDelayedOpen();\n      else\n        handleOpen();\n    }, [\n      providerContext.isOpenDelayed,\n      handleDelayedOpen,\n      handleOpen\n    ]),\n    onTriggerLeave: (0, import_react35.useCallback)(() => {\n      if (disableHoverableContent)\n        handleClose();\n      else\n        window.clearTimeout(openTimerRef.current);\n    }, [\n      handleClose,\n      disableHoverableContent\n    ]),\n    onOpen: handleOpen,\n    onClose: handleClose,\n    disableHoverableContent\n  }, children));\n};\nvar $a093c7e1ec25a057$var$TRIGGER_NAME = \"TooltipTrigger\";\nvar $a093c7e1ec25a057$export$8c610744efcf8a1d = /* @__PURE__ */ (0, import_react35.forwardRef)((props, forwardedRef) => {\n  const { __scopeTooltip, ...triggerProps } = props;\n  const context = $a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$TRIGGER_NAME, __scopeTooltip);\n  const providerContext = $a093c7e1ec25a057$var$useTooltipProviderContext($a093c7e1ec25a057$var$TRIGGER_NAME, __scopeTooltip);\n  const popperScope = $a093c7e1ec25a057$var$usePopperScope(__scopeTooltip);\n  const ref = (0, import_react35.useRef)(null);\n  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref, context.onTriggerChange);\n  const isPointerDownRef = (0, import_react35.useRef)(false);\n  const hasPointerMoveOpenedRef = (0, import_react35.useRef)(false);\n  const handlePointerUp = (0, import_react35.useCallback)(\n    () => isPointerDownRef.current = false,\n    []\n  );\n  (0, import_react35.useEffect)(() => {\n    return () => document.removeEventListener(\"pointerup\", handlePointerUp);\n  }, [\n    handlePointerUp\n  ]);\n  return /* @__PURE__ */ (0, import_react35.createElement)($cf1ac5d9fe0e8206$export$b688253958b8dfe7, _extends({\n    asChild: true\n  }, popperScope), /* @__PURE__ */ (0, import_react35.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({\n    \"aria-describedby\": context.open ? context.contentId : void 0,\n    \"data-state\": context.stateAttribute\n  }, triggerProps, {\n    ref: composedRefs,\n    onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, (event) => {\n      if (event.pointerType === \"touch\")\n        return;\n      if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {\n        context.onTriggerEnter();\n        hasPointerMoveOpenedRef.current = true;\n      }\n    }),\n    onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerLeave, () => {\n      context.onTriggerLeave();\n      hasPointerMoveOpenedRef.current = false;\n    }),\n    onPointerDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDown, () => {\n      isPointerDownRef.current = true;\n      document.addEventListener(\"pointerup\", handlePointerUp, {\n        once: true\n      });\n    }),\n    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocus, () => {\n      if (!isPointerDownRef.current)\n        context.onOpen();\n    }),\n    onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlur, context.onClose),\n    onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, context.onClose)\n  })));\n});\nvar $a093c7e1ec25a057$var$PORTAL_NAME = \"TooltipPortal\";\nvar [$a093c7e1ec25a057$var$PortalProvider, $a093c7e1ec25a057$var$usePortalContext] = $a093c7e1ec25a057$var$createTooltipContext($a093c7e1ec25a057$var$PORTAL_NAME, {\n  forceMount: void 0\n});\nvar $a093c7e1ec25a057$var$CONTENT_NAME = \"TooltipContent\";\nvar $a093c7e1ec25a057$export$e9003e2be37ec060 = /* @__PURE__ */ (0, import_react35.forwardRef)((props, forwardedRef) => {\n  const portalContext = $a093c7e1ec25a057$var$usePortalContext($a093c7e1ec25a057$var$CONTENT_NAME, props.__scopeTooltip);\n  const { forceMount = portalContext.forceMount, side = \"top\", ...contentProps } = props;\n  const context = $a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$CONTENT_NAME, props.__scopeTooltip);\n  return /* @__PURE__ */ (0, import_react35.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {\n    present: forceMount || context.open\n  }, context.disableHoverableContent ? /* @__PURE__ */ (0, import_react35.createElement)($a093c7e1ec25a057$var$TooltipContentImpl, _extends({\n    side\n  }, contentProps, {\n    ref: forwardedRef\n  })) : /* @__PURE__ */ (0, import_react35.createElement)($a093c7e1ec25a057$var$TooltipContentHoverable, _extends({\n    side\n  }, contentProps, {\n    ref: forwardedRef\n  })));\n});\nvar $a093c7e1ec25a057$var$TooltipContentHoverable = /* @__PURE__ */ (0, import_react35.forwardRef)((props, forwardedRef) => {\n  const context = $a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$CONTENT_NAME, props.__scopeTooltip);\n  const providerContext = $a093c7e1ec25a057$var$useTooltipProviderContext($a093c7e1ec25a057$var$CONTENT_NAME, props.__scopeTooltip);\n  const ref = (0, import_react35.useRef)(null);\n  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);\n  const [pointerGraceArea, setPointerGraceArea] = (0, import_react35.useState)(null);\n  const { trigger: trigger2, onClose } = context;\n  const content = ref.current;\n  const { onPointerInTransitChange } = providerContext;\n  const handleRemoveGraceArea = (0, import_react35.useCallback)(() => {\n    setPointerGraceArea(null);\n    onPointerInTransitChange(false);\n  }, [\n    onPointerInTransitChange\n  ]);\n  const handleCreateGraceArea = (0, import_react35.useCallback)((event, hoverTarget) => {\n    const currentTarget = event.currentTarget;\n    const exitPoint = {\n      x: event.clientX,\n      y: event.clientY\n    };\n    const exitSide = $a093c7e1ec25a057$var$getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());\n    const bleed = exitSide === \"right\" || exitSide === \"bottom\" ? -5 : 5;\n    const isXAxis = exitSide === \"right\" || exitSide === \"left\";\n    const startPoint = isXAxis ? {\n      x: event.clientX + bleed,\n      y: event.clientY\n    } : {\n      x: event.clientX,\n      y: event.clientY + bleed\n    };\n    const hoverTargetPoints = $a093c7e1ec25a057$var$getPointsFromRect(hoverTarget.getBoundingClientRect());\n    const graceArea = $a093c7e1ec25a057$var$getHull([\n      startPoint,\n      ...hoverTargetPoints\n    ]);\n    setPointerGraceArea(graceArea);\n    onPointerInTransitChange(true);\n  }, [\n    onPointerInTransitChange\n  ]);\n  (0, import_react35.useEffect)(() => {\n    return () => handleRemoveGraceArea();\n  }, [\n    handleRemoveGraceArea\n  ]);\n  (0, import_react35.useEffect)(() => {\n    if (trigger2 && content) {\n      const handleTriggerLeave = (event) => handleCreateGraceArea(event, content);\n      const handleContentLeave = (event) => handleCreateGraceArea(event, trigger2);\n      trigger2.addEventListener(\"pointerleave\", handleTriggerLeave);\n      content.addEventListener(\"pointerleave\", handleContentLeave);\n      return () => {\n        trigger2.removeEventListener(\"pointerleave\", handleTriggerLeave);\n        content.removeEventListener(\"pointerleave\", handleContentLeave);\n      };\n    }\n  }, [\n    trigger2,\n    content,\n    handleCreateGraceArea,\n    handleRemoveGraceArea\n  ]);\n  (0, import_react35.useEffect)(() => {\n    if (pointerGraceArea) {\n      const handleTrackPointerGrace = (event) => {\n        const target = event.target;\n        const pointerPosition = {\n          x: event.clientX,\n          y: event.clientY\n        };\n        const hasEnteredTarget = (trigger2 === null || trigger2 === void 0 ? void 0 : trigger2.contains(target)) || (content === null || content === void 0 ? void 0 : content.contains(target));\n        const isPointerOutsideGraceArea = !$a093c7e1ec25a057$var$isPointInPolygon(pointerPosition, pointerGraceArea);\n        if (hasEnteredTarget)\n          handleRemoveGraceArea();\n        else if (isPointerOutsideGraceArea) {\n          handleRemoveGraceArea();\n          onClose();\n        }\n      };\n      document.addEventListener(\"pointermove\", handleTrackPointerGrace);\n      return () => document.removeEventListener(\"pointermove\", handleTrackPointerGrace);\n    }\n  }, [\n    trigger2,\n    content,\n    pointerGraceArea,\n    onClose,\n    handleRemoveGraceArea\n  ]);\n  return /* @__PURE__ */ (0, import_react35.createElement)($a093c7e1ec25a057$var$TooltipContentImpl, _extends({}, props, {\n    ref: composedRefs\n  }));\n});\nvar [$a093c7e1ec25a057$var$VisuallyHiddenContentContextProvider, $a093c7e1ec25a057$var$useVisuallyHiddenContentContext] = $a093c7e1ec25a057$var$createTooltipContext($a093c7e1ec25a057$var$TOOLTIP_NAME, {\n  isInside: false\n});\nvar $a093c7e1ec25a057$var$TooltipContentImpl = /* @__PURE__ */ (0, import_react35.forwardRef)((props, forwardedRef) => {\n  const { __scopeTooltip, children, \"aria-label\": ariaLabel, onEscapeKeyDown, onPointerDownOutside, ...contentProps } = props;\n  const context = $a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$CONTENT_NAME, __scopeTooltip);\n  const popperScope = $a093c7e1ec25a057$var$usePopperScope(__scopeTooltip);\n  const { onClose } = context;\n  (0, import_react35.useEffect)(() => {\n    document.addEventListener($a093c7e1ec25a057$var$TOOLTIP_OPEN, onClose);\n    return () => document.removeEventListener($a093c7e1ec25a057$var$TOOLTIP_OPEN, onClose);\n  }, [\n    onClose\n  ]);\n  (0, import_react35.useEffect)(() => {\n    if (context.trigger) {\n      const handleScroll2 = (event) => {\n        const target = event.target;\n        if (target !== null && target !== void 0 && target.contains(context.trigger))\n          onClose();\n      };\n      window.addEventListener(\"scroll\", handleScroll2, {\n        capture: true\n      });\n      return () => window.removeEventListener(\"scroll\", handleScroll2, {\n        capture: true\n      });\n    }\n  }, [\n    context.trigger,\n    onClose\n  ]);\n  return /* @__PURE__ */ (0, import_react35.createElement)($5cb92bef7577960e$export$177fb62ff3ec1f22, {\n    asChild: true,\n    disableOutsidePointerEvents: false,\n    onEscapeKeyDown,\n    onPointerDownOutside,\n    onFocusOutside: (event) => event.preventDefault(),\n    onDismiss: onClose\n  }, /* @__PURE__ */ (0, import_react35.createElement)($cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2, _extends({\n    \"data-state\": context.stateAttribute\n  }, popperScope, contentProps, {\n    ref: forwardedRef,\n    style: {\n      ...contentProps.style,\n      [\"--radix-tooltip-content-transform-origin\"]: \"var(--radix-popper-transform-origin)\"\n    }\n  }), /* @__PURE__ */ (0, import_react35.createElement)($5e63c961fc1ce211$export$d9f1ccf0bdb05d45, null, children), /* @__PURE__ */ (0, import_react35.createElement)($a093c7e1ec25a057$var$VisuallyHiddenContentContextProvider, {\n    scope: __scopeTooltip,\n    isInside: true\n  }, /* @__PURE__ */ (0, import_react35.createElement)($ea1ef594cf570d83$export$be92b6f5f03c0fe9, {\n    id: context.contentId,\n    role: \"tooltip\"\n  }, ariaLabel || children))));\n});\nvar $a093c7e1ec25a057$var$ARROW_NAME = \"TooltipArrow\";\nvar $a093c7e1ec25a057$export$c27ee0ad710f7559 = /* @__PURE__ */ (0, import_react35.forwardRef)((props, forwardedRef) => {\n  const { __scopeTooltip, ...arrowProps } = props;\n  const popperScope = $a093c7e1ec25a057$var$usePopperScope(__scopeTooltip);\n  const visuallyHiddenContentContext = $a093c7e1ec25a057$var$useVisuallyHiddenContentContext($a093c7e1ec25a057$var$ARROW_NAME, __scopeTooltip);\n  return visuallyHiddenContentContext.isInside ? null : /* @__PURE__ */ (0, import_react35.createElement)($cf1ac5d9fe0e8206$export$21b07c8f274aebd5, _extends({}, popperScope, arrowProps, {\n    ref: forwardedRef\n  }));\n});\nfunction $a093c7e1ec25a057$var$getExitSideFromRect(point, rect) {\n  const top2 = Math.abs(rect.top - point.y);\n  const bottom = Math.abs(rect.bottom - point.y);\n  const right = Math.abs(rect.right - point.x);\n  const left = Math.abs(rect.left - point.x);\n  switch (Math.min(top2, bottom, right, left)) {\n    case left:\n      return \"left\";\n    case right:\n      return \"right\";\n    case top2:\n      return \"top\";\n    case bottom:\n      return \"bottom\";\n    default:\n      return null;\n  }\n}\nfunction $a093c7e1ec25a057$var$getPointsFromRect(rect) {\n  const { top: top2, right, bottom, left } = rect;\n  return [\n    {\n      x: left,\n      y: top2\n    },\n    {\n      x: right,\n      y: top2\n    },\n    {\n      x: right,\n      y: bottom\n    },\n    {\n      x: left,\n      y: bottom\n    }\n  ];\n}\nfunction $a093c7e1ec25a057$var$isPointInPolygon(point, polygon) {\n  const { x: x5, y: y6 } = point;\n  let inside = false;\n  for (let i4 = 0, j4 = polygon.length - 1; i4 < polygon.length; j4 = i4++) {\n    const xi = polygon[i4].x;\n    const yi = polygon[i4].y;\n    const xj = polygon[j4].x;\n    const yj = polygon[j4].y;\n    const intersect = yi > y6 !== yj > y6 && x5 < (xj - xi) * (y6 - yi) / (yj - yi) + xi;\n    if (intersect)\n      inside = !inside;\n  }\n  return inside;\n}\nfunction $a093c7e1ec25a057$var$getHull(points) {\n  const newPoints = points.slice();\n  newPoints.sort((a7, b6) => {\n    if (a7.x < b6.x)\n      return -1;\n    else if (a7.x > b6.x)\n      return 1;\n    else if (a7.y < b6.y)\n      return -1;\n    else if (a7.y > b6.y)\n      return 1;\n    else\n      return 0;\n  });\n  return $a093c7e1ec25a057$var$getHullPresorted(newPoints);\n}\nfunction $a093c7e1ec25a057$var$getHullPresorted(points) {\n  if (points.length <= 1)\n    return points.slice();\n  const upperHull = [];\n  for (let i4 = 0; i4 < points.length; i4++) {\n    const p6 = points[i4];\n    while (upperHull.length >= 2) {\n      const q4 = upperHull[upperHull.length - 1];\n      const r5 = upperHull[upperHull.length - 2];\n      if ((q4.x - r5.x) * (p6.y - r5.y) >= (q4.y - r5.y) * (p6.x - r5.x))\n        upperHull.pop();\n      else\n        break;\n    }\n    upperHull.push(p6);\n  }\n  upperHull.pop();\n  const lowerHull = [];\n  for (let i1 = points.length - 1; i1 >= 0; i1--) {\n    const p6 = points[i1];\n    while (lowerHull.length >= 2) {\n      const q4 = lowerHull[lowerHull.length - 1];\n      const r5 = lowerHull[lowerHull.length - 2];\n      if ((q4.x - r5.x) * (p6.y - r5.y) >= (q4.y - r5.y) * (p6.x - r5.x))\n        lowerHull.pop();\n      else\n        break;\n    }\n    lowerHull.push(p6);\n  }\n  lowerHull.pop();\n  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y)\n    return upperHull;\n  else\n    return upperHull.concat(lowerHull);\n}\nvar $a093c7e1ec25a057$export$2881499e37b75b9a = $a093c7e1ec25a057$export$f78649fb9ca566b8;\nvar $a093c7e1ec25a057$export$be92b6f5f03c0fe9 = $a093c7e1ec25a057$export$28c660c63b792dea;\nvar $a093c7e1ec25a057$export$41fb9f06171c75f4 = $a093c7e1ec25a057$export$8c610744efcf8a1d;\nvar $a093c7e1ec25a057$export$7c6e2c02157bb7d2 = $a093c7e1ec25a057$export$e9003e2be37ec060;\nvar $a093c7e1ec25a057$export$21b07c8f274aebd5 = $a093c7e1ec25a057$export$c27ee0ad710f7559;\n\n// src/components/Tldraw/components/Primitives/Tooltip/Tooltip.tsx\nvar import_jsx_runtime4 = require(\"react/jsx-runtime\");\nfunction Tooltip({ children, label, kbd: kbdProperty, id, side = \"top\" }) {\n  return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(\"span\", { id, children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)($a093c7e1ec25a057$export$2881499e37b75b9a, { children: /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)($a093c7e1ec25a057$export$be92b6f5f03c0fe9, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime4.jsx)($a093c7e1ec25a057$export$41fb9f06171c75f4, { dir: \"ltr\", asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(\"span\", { children }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(StyledContent, { dir: \"ltr\", side, sideOffset: 8, children: [\n      label,\n      kbdProperty ? /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Kbd, { variant: \"tooltip\", children: kbdProperty }) : null,\n      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(StyledArrow, {})\n    ] })\n  ] }) }) });\n}\nvar StyledContent = styled($a093c7e1ec25a057$export$7c6e2c02157bb7d2, {\n  borderRadius: 3,\n  padding: \"$3 $3 $3 $3\",\n  fontSize: \"$1\",\n  backgroundColor: \"$tooltip\",\n  color: \"$tooltipContrast\",\n  boxShadow: \"$3\",\n  display: \"flex\",\n  alignItems: \"center\",\n  fontFamily: \"$ui\",\n  userSelect: \"none\"\n});\nvar StyledArrow = styled($a093c7e1ec25a057$export$21b07c8f274aebd5, {\n  fill: \"$tooltip\",\n  margin: \"0 8px\"\n});\n\n// src/components/Tldraw/hooks/useFileSystem.ts\nvar React10 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/hooks/useFileSystemHandlers.ts\nvar React11 = __toESM(require(\"react\"));\nfunction useFileSystemHandlers() {\n  const app = useTldrawApp();\n  const onOpenMedia = React11.useCallback(\n    (event) => {\n      if (event !== void 0 && app.callbacks.onOpenMedia !== void 0)\n        event.preventDefault();\n      app.callbacks.onOpenMedia?.(app);\n    },\n    [app]\n  );\n  return {\n    onOpenMedia\n  };\n}\n\n// src/components/Tldraw/hooks/useKeyboardShortcuts.tsx\nvar React12 = __toESM(require(\"react\"));\n\n// node_modules/hotkeys-js/dist/hotkeys.esm.js\nvar isff = typeof navigator !== \"undefined\" ? navigator.userAgent.toLowerCase().indexOf(\"firefox\") > 0 : false;\nfunction addEvent(object, event, method, useCapture) {\n  if (object.addEventListener) {\n    object.addEventListener(event, method, useCapture);\n  } else if (object.attachEvent) {\n    object.attachEvent(\"on\".concat(event), function() {\n      method(window.event);\n    });\n  }\n}\nfunction getMods(modifier, key) {\n  var mods = key.slice(0, key.length - 1);\n  for (var i4 = 0; i4 < mods.length; i4++) {\n    mods[i4] = modifier[mods[i4].toLowerCase()];\n  }\n  return mods;\n}\nfunction getKeys(key) {\n  if (typeof key !== \"string\")\n    key = \"\";\n  key = key.replace(/\\s/g, \"\");\n  var keys = key.split(\",\");\n  var index2 = keys.lastIndexOf(\"\");\n  for (; index2 >= 0; ) {\n    keys[index2 - 1] += \",\";\n    keys.splice(index2, 1);\n    index2 = keys.lastIndexOf(\"\");\n  }\n  return keys;\n}\nfunction compareArray(a1, a22) {\n  var arr1 = a1.length >= a22.length ? a1 : a22;\n  var arr2 = a1.length >= a22.length ? a22 : a1;\n  var isIndex = true;\n  for (var i4 = 0; i4 < arr1.length; i4++) {\n    if (arr2.indexOf(arr1[i4]) === -1)\n      isIndex = false;\n  }\n  return isIndex;\n}\nvar _keyMap = {\n  backspace: 8,\n  tab: 9,\n  clear: 12,\n  enter: 13,\n  return: 13,\n  esc: 27,\n  escape: 27,\n  space: 32,\n  left: 37,\n  up: 38,\n  right: 39,\n  down: 40,\n  del: 46,\n  delete: 46,\n  ins: 45,\n  insert: 45,\n  home: 36,\n  end: 35,\n  pageup: 33,\n  pagedown: 34,\n  capslock: 20,\n  num_0: 96,\n  num_1: 97,\n  num_2: 98,\n  num_3: 99,\n  num_4: 100,\n  num_5: 101,\n  num_6: 102,\n  num_7: 103,\n  num_8: 104,\n  num_9: 105,\n  num_multiply: 106,\n  num_add: 107,\n  num_enter: 108,\n  num_subtract: 109,\n  num_decimal: 110,\n  num_divide: 111,\n  \"\\u21EA\": 20,\n  \",\": 188,\n  \".\": 190,\n  \"/\": 191,\n  \"`\": 192,\n  \"-\": isff ? 173 : 189,\n  \"=\": isff ? 61 : 187,\n  \";\": isff ? 59 : 186,\n  \"'\": 222,\n  \"[\": 219,\n  \"]\": 221,\n  \"\\\\\": 220\n};\nvar _modifier = {\n  \"\\u21E7\": 16,\n  shift: 16,\n  \"\\u2325\": 18,\n  alt: 18,\n  option: 18,\n  \"\\u2303\": 17,\n  ctrl: 17,\n  control: 17,\n  \"\\u2318\": 91,\n  cmd: 91,\n  command: 91\n};\nvar modifierMap = {\n  16: \"shiftKey\",\n  18: \"altKey\",\n  17: \"ctrlKey\",\n  91: \"metaKey\",\n  shiftKey: 16,\n  ctrlKey: 17,\n  altKey: 18,\n  metaKey: 91\n};\nvar _mods = {\n  16: false,\n  18: false,\n  17: false,\n  91: false\n};\nvar _handlers = {};\nfor (k6 = 1; k6 < 20; k6++) {\n  _keyMap[\"f\".concat(k6)] = 111 + k6;\n}\nvar k6;\nvar _downKeys = [];\nvar winListendFocus = false;\nvar _scope = \"all\";\nvar elementHasBindEvent = [];\nvar code = function code2(x5) {\n  return _keyMap[x5.toLowerCase()] || _modifier[x5.toLowerCase()] || x5.toUpperCase().charCodeAt(0);\n};\nfunction setScope(scope) {\n  _scope = scope || \"all\";\n}\nfunction getScope() {\n  return _scope || \"all\";\n}\nfunction getPressedKeyCodes() {\n  return _downKeys.slice(0);\n}\nfunction filter(event) {\n  var target = event.target || event.srcElement;\n  var tagName = target.tagName;\n  var flag = true;\n  if (target.isContentEditable || (tagName === \"INPUT\" || tagName === \"TEXTAREA\" || tagName === \"SELECT\") && !target.readOnly) {\n    flag = false;\n  }\n  return flag;\n}\nfunction isPressed(keyCode) {\n  if (typeof keyCode === \"string\") {\n    keyCode = code(keyCode);\n  }\n  return _downKeys.indexOf(keyCode) !== -1;\n}\nfunction deleteScope(scope, newScope) {\n  var handlers;\n  var i4;\n  if (!scope)\n    scope = getScope();\n  for (var key in _handlers) {\n    if (Object.prototype.hasOwnProperty.call(_handlers, key)) {\n      handlers = _handlers[key];\n      for (i4 = 0; i4 < handlers.length; ) {\n        if (handlers[i4].scope === scope)\n          handlers.splice(i4, 1);\n        else\n          i4++;\n      }\n    }\n  }\n  if (getScope() === scope)\n    setScope(newScope || \"all\");\n}\nfunction clearModifier(event) {\n  var key = event.keyCode || event.which || event.charCode;\n  var i4 = _downKeys.indexOf(key);\n  if (i4 >= 0) {\n    _downKeys.splice(i4, 1);\n  }\n  if (event.key && event.key.toLowerCase() === \"meta\") {\n    _downKeys.splice(0, _downKeys.length);\n  }\n  if (key === 93 || key === 224)\n    key = 91;\n  if (key in _mods) {\n    _mods[key] = false;\n    for (var k6 in _modifier) {\n      if (_modifier[k6] === key)\n        hotkeys[k6] = false;\n    }\n  }\n}\nfunction unbind(keysInfo) {\n  if (typeof keysInfo === \"undefined\") {\n    Object.keys(_handlers).forEach(function(key) {\n      return delete _handlers[key];\n    });\n  } else if (Array.isArray(keysInfo)) {\n    keysInfo.forEach(function(info) {\n      if (info.key)\n        eachUnbind(info);\n    });\n  } else if (typeof keysInfo === \"object\") {\n    if (keysInfo.key)\n      eachUnbind(keysInfo);\n  } else if (typeof keysInfo === \"string\") {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    var scope = args[0], method = args[1];\n    if (typeof scope === \"function\") {\n      method = scope;\n      scope = \"\";\n    }\n    eachUnbind({\n      key: keysInfo,\n      scope,\n      method,\n      splitKey: \"+\"\n    });\n  }\n}\nvar eachUnbind = function eachUnbind2(_ref) {\n  var key = _ref.key, scope = _ref.scope, method = _ref.method, _ref$splitKey = _ref.splitKey, splitKey = _ref$splitKey === void 0 ? \"+\" : _ref$splitKey;\n  var multipleKeys = getKeys(key);\n  multipleKeys.forEach(function(originKey) {\n    var unbindKeys = originKey.split(splitKey);\n    var len = unbindKeys.length;\n    var lastKey = unbindKeys[len - 1];\n    var keyCode = lastKey === \"*\" ? \"*\" : code(lastKey);\n    if (!_handlers[keyCode])\n      return;\n    if (!scope)\n      scope = getScope();\n    var mods = len > 1 ? getMods(_modifier, unbindKeys) : [];\n    _handlers[keyCode] = _handlers[keyCode].filter(function(record) {\n      var isMatchingMethod = method ? record.method === method : true;\n      return !(isMatchingMethod && record.scope === scope && compareArray(record.mods, mods));\n    });\n  });\n};\nfunction eventHandler(event, handler, scope, element) {\n  if (handler.element !== element) {\n    return;\n  }\n  var modifiersMatch;\n  if (handler.scope === scope || handler.scope === \"all\") {\n    modifiersMatch = handler.mods.length > 0;\n    for (var y6 in _mods) {\n      if (Object.prototype.hasOwnProperty.call(_mods, y6)) {\n        if (!_mods[y6] && handler.mods.indexOf(+y6) > -1 || _mods[y6] && handler.mods.indexOf(+y6) === -1) {\n          modifiersMatch = false;\n        }\n      }\n    }\n    if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === \"*\") {\n      if (handler.method(event, handler) === false) {\n        if (event.preventDefault)\n          event.preventDefault();\n        else\n          event.returnValue = false;\n        if (event.stopPropagation)\n          event.stopPropagation();\n        if (event.cancelBubble)\n          event.cancelBubble = true;\n      }\n    }\n  }\n}\nfunction dispatch(event, element) {\n  var asterisk = _handlers[\"*\"];\n  var key = event.keyCode || event.which || event.charCode;\n  if (!hotkeys.filter.call(this, event))\n    return;\n  if (key === 93 || key === 224)\n    key = 91;\n  if (_downKeys.indexOf(key) === -1 && key !== 229)\n    _downKeys.push(key);\n  [\"ctrlKey\", \"altKey\", \"shiftKey\", \"metaKey\"].forEach(function(keyName) {\n    var keyNum = modifierMap[keyName];\n    if (event[keyName] && _downKeys.indexOf(keyNum) === -1) {\n      _downKeys.push(keyNum);\n    } else if (!event[keyName] && _downKeys.indexOf(keyNum) > -1) {\n      _downKeys.splice(_downKeys.indexOf(keyNum), 1);\n    } else if (keyName === \"metaKey\" && event[keyName] && _downKeys.length === 3) {\n      if (!(event.ctrlKey || event.shiftKey || event.altKey)) {\n        _downKeys = _downKeys.slice(_downKeys.indexOf(keyNum));\n      }\n    }\n  });\n  if (key in _mods) {\n    _mods[key] = true;\n    for (var k6 in _modifier) {\n      if (_modifier[k6] === key)\n        hotkeys[k6] = true;\n    }\n    if (!asterisk)\n      return;\n  }\n  for (var e5 in _mods) {\n    if (Object.prototype.hasOwnProperty.call(_mods, e5)) {\n      _mods[e5] = event[modifierMap[e5]];\n    }\n  }\n  if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState(\"AltGraph\")) {\n    if (_downKeys.indexOf(17) === -1) {\n      _downKeys.push(17);\n    }\n    if (_downKeys.indexOf(18) === -1) {\n      _downKeys.push(18);\n    }\n    _mods[17] = true;\n    _mods[18] = true;\n  }\n  var scope = getScope();\n  if (asterisk) {\n    for (var i4 = 0; i4 < asterisk.length; i4++) {\n      if (asterisk[i4].scope === scope && (event.type === \"keydown\" && asterisk[i4].keydown || event.type === \"keyup\" && asterisk[i4].keyup)) {\n        eventHandler(event, asterisk[i4], scope, element);\n      }\n    }\n  }\n  if (!(key in _handlers))\n    return;\n  for (var _i = 0; _i < _handlers[key].length; _i++) {\n    if (event.type === \"keydown\" && _handlers[key][_i].keydown || event.type === \"keyup\" && _handlers[key][_i].keyup) {\n      if (_handlers[key][_i].key) {\n        var record = _handlers[key][_i];\n        var splitKey = record.splitKey;\n        var keyShortcut = record.key.split(splitKey);\n        var _downKeysCurrent = [];\n        for (var a7 = 0; a7 < keyShortcut.length; a7++) {\n          _downKeysCurrent.push(code(keyShortcut[a7]));\n        }\n        if (_downKeysCurrent.sort().join(\"\") === _downKeys.sort().join(\"\")) {\n          eventHandler(event, record, scope, element);\n        }\n      }\n    }\n  }\n}\nfunction isElementBind(element) {\n  return elementHasBindEvent.indexOf(element) > -1;\n}\nfunction hotkeys(key, option, method) {\n  _downKeys = [];\n  var keys = getKeys(key);\n  var mods = [];\n  var scope = \"all\";\n  var element = document;\n  var i4 = 0;\n  var keyup = false;\n  var keydown = true;\n  var splitKey = \"+\";\n  var capture = false;\n  if (method === void 0 && typeof option === \"function\") {\n    method = option;\n  }\n  if (Object.prototype.toString.call(option) === \"[object Object]\") {\n    if (option.scope)\n      scope = option.scope;\n    if (option.element)\n      element = option.element;\n    if (option.keyup)\n      keyup = option.keyup;\n    if (option.keydown !== void 0)\n      keydown = option.keydown;\n    if (option.capture !== void 0)\n      capture = option.capture;\n    if (typeof option.splitKey === \"string\")\n      splitKey = option.splitKey;\n  }\n  if (typeof option === \"string\")\n    scope = option;\n  for (; i4 < keys.length; i4++) {\n    key = keys[i4].split(splitKey);\n    mods = [];\n    if (key.length > 1)\n      mods = getMods(_modifier, key);\n    key = key[key.length - 1];\n    key = key === \"*\" ? \"*\" : code(key);\n    if (!(key in _handlers))\n      _handlers[key] = [];\n    _handlers[key].push({\n      keyup,\n      keydown,\n      scope,\n      mods,\n      shortcut: keys[i4],\n      method,\n      key: keys[i4],\n      splitKey,\n      element\n    });\n  }\n  if (typeof element !== \"undefined\" && !isElementBind(element) && window) {\n    elementHasBindEvent.push(element);\n    addEvent(element, \"keydown\", function(e5) {\n      dispatch(e5, element);\n    }, capture);\n    if (!winListendFocus) {\n      winListendFocus = true;\n      addEvent(window, \"focus\", function() {\n        _downKeys = [];\n      }, capture);\n    }\n    addEvent(element, \"keyup\", function(e5) {\n      dispatch(e5, element);\n      clearModifier(e5);\n    }, capture);\n  }\n}\nfunction trigger(shortcut) {\n  var scope = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"all\";\n  Object.keys(_handlers).forEach(function(key) {\n    var data = _handlers[key].find(function(item) {\n      return item.scope === scope && item.shortcut === shortcut;\n    });\n    if (data && data.method) {\n      data.method();\n    }\n  });\n}\nvar _api = {\n  setScope,\n  getScope,\n  deleteScope,\n  getPressedKeyCodes,\n  isPressed,\n  filter,\n  trigger,\n  unbind,\n  keyMap: _keyMap,\n  modifier: _modifier,\n  modifierMap\n};\nfor (a7 in _api) {\n  if (Object.prototype.hasOwnProperty.call(_api, a7)) {\n    hotkeys[a7] = _api[a7];\n  }\n}\nvar a7;\nif (typeof window !== \"undefined\") {\n  _hotkeys = window.hotkeys;\n  hotkeys.noConflict = function(deep) {\n    if (deep && window.hotkeys === hotkeys) {\n      window.hotkeys = _hotkeys;\n    }\n    return hotkeys;\n  };\n  window.hotkeys = hotkeys;\n}\nvar _hotkeys;\n\n// node_modules/react-hotkeys-hook/dist/react-hotkeys-hook.esm.js\nvar import_react36 = require(\"react\");\nhotkeys.filter = function() {\n  return true;\n};\nvar tagFilter = function tagFilter2(_ref, enableOnTags) {\n  var target = _ref.target;\n  var targetTagName = target && target.tagName;\n  return Boolean(targetTagName && enableOnTags && enableOnTags.includes(targetTagName));\n};\nvar isKeyboardEventTriggeredByInput = function isKeyboardEventTriggeredByInput2(ev) {\n  return tagFilter(ev, [\"INPUT\", \"TEXTAREA\", \"SELECT\"]);\n};\nfunction useHotkeys(keys, callback, options, deps) {\n  if (options instanceof Array) {\n    deps = options;\n    options = void 0;\n  }\n  var _ref2 = options || {}, enableOnTags = _ref2.enableOnTags, filter2 = _ref2.filter, keyup = _ref2.keyup, keydown = _ref2.keydown, _ref2$filterPreventDe = _ref2.filterPreventDefault, filterPreventDefault = _ref2$filterPreventDe === void 0 ? true : _ref2$filterPreventDe, _ref2$enabled = _ref2.enabled, enabled = _ref2$enabled === void 0 ? true : _ref2$enabled, _ref2$enableOnContent = _ref2.enableOnContentEditable, enableOnContentEditable = _ref2$enableOnContent === void 0 ? false : _ref2$enableOnContent;\n  var ref = (0, import_react36.useRef)(null);\n  var memoisedCallback = (0, import_react36.useCallback)(function(keyboardEvent, hotkeysEvent) {\n    var _keyboardEvent$target, _ref$current;\n    if (filter2 && !filter2(keyboardEvent)) {\n      return !filterPreventDefault;\n    }\n    if (isKeyboardEventTriggeredByInput(keyboardEvent) && !tagFilter(keyboardEvent, enableOnTags) || (_keyboardEvent$target = keyboardEvent.target) != null && _keyboardEvent$target.isContentEditable && !enableOnContentEditable) {\n      return true;\n    }\n    if (ref.current === null || document.activeElement === ref.current || (_ref$current = ref.current) != null && _ref$current.contains(document.activeElement)) {\n      callback(keyboardEvent, hotkeysEvent);\n      return true;\n    }\n    return false;\n  }, deps ? [ref, enableOnTags, filter2].concat(deps) : [ref, enableOnTags, filter2]);\n  (0, import_react36.useEffect)(function() {\n    if (!enabled) {\n      hotkeys.unbind(keys, memoisedCallback);\n      return;\n    }\n    if (keyup && keydown !== true) {\n      options.keydown = false;\n    }\n    hotkeys(keys, options || {}, memoisedCallback);\n    return function() {\n      return hotkeys.unbind(keys, memoisedCallback);\n    };\n  }, [memoisedCallback, keys, enabled]);\n  return ref;\n}\nvar isHotkeyPressed = hotkeys.isPressed;\n\n// src/components/Tldraw/types.ts\nvar TDEventHandler = class {\n  onPinchStart;\n  onPinchEnd;\n  onPinch;\n  onKeyDown;\n  onKeyUp;\n  onPointerMove;\n  onPointerUp;\n  onPan;\n  onZoom;\n  onPointerDown;\n  onPointCanvas;\n  onDoubleClickCanvas;\n  onRightPointCanvas;\n  onDragCanvas;\n  onReleaseCanvas;\n  onPointShape;\n  onDoubleClickShape;\n  onRightPointShape;\n  onDragShape;\n  onHoverShape;\n  onUnhoverShape;\n  onReleaseShape;\n  onPointBounds;\n  onDoubleClickBounds;\n  onRightPointBounds;\n  onDragBounds;\n  onHoverBounds;\n  onUnhoverBounds;\n  onReleaseBounds;\n  onPointBoundsHandle;\n  onDoubleClickBoundsHandle;\n  onRightPointBoundsHandle;\n  onDragBoundsHandle;\n  onHoverBoundsHandle;\n  onUnhoverBoundsHandle;\n  onReleaseBoundsHandle;\n  onPointHandle;\n  onDoubleClickHandle;\n  onRightPointHandle;\n  onDragHandle;\n  onHoverHandle;\n  onUnhoverHandle;\n  onReleaseHandle;\n  onShapeBlur;\n  onShapeClone;\n};\nvar SizeStyle = /* @__PURE__ */ ((SizeStyle2) => {\n  SizeStyle2[\"Large\"] = \"large\";\n  SizeStyle2[\"Medium\"] = \"medium\";\n  SizeStyle2[\"Small\"] = \"small\";\n  return SizeStyle2;\n})(SizeStyle || {});\nvar DashStyle = /* @__PURE__ */ ((DashStyle2) => {\n  DashStyle2[\"Dashed\"] = \"dashed\";\n  DashStyle2[\"Dotted\"] = \"dotted\";\n  DashStyle2[\"Draw\"] = \"draw\";\n  DashStyle2[\"Solid\"] = \"solid\";\n  return DashStyle2;\n})(DashStyle || {});\nvar AlignStyle = /* @__PURE__ */ ((AlignStyle2) => {\n  AlignStyle2[\"End\"] = \"end\";\n  AlignStyle2[\"Justify\"] = \"justify\";\n  AlignStyle2[\"Middle\"] = \"middle\";\n  AlignStyle2[\"Start\"] = \"start\";\n  return AlignStyle2;\n})(AlignStyle || {});\nvar FontStyle = /* @__PURE__ */ ((FontStyle2) => {\n  FontStyle2[\"Mono\"] = \"mono\";\n  FontStyle2[\"Sans\"] = \"sans\";\n  FontStyle2[\"Script\"] = \"script\";\n  FontStyle2[\"Serif\"] = \"serif\";\n  return FontStyle2;\n})(FontStyle || {});\nvar TDExportBackground = /* @__PURE__ */ ((TDExportBackground2) => {\n  TDExportBackground2[\"Auto\"] = \"auto\";\n  TDExportBackground2[\"Dark\"] = \"dark\";\n  TDExportBackground2[\"Light\"] = \"light\";\n  TDExportBackground2[\"Transparent\"] = \"transparent\";\n  return TDExportBackground2;\n})(TDExportBackground || {});\n\n// src/components/Tldraw/state/shapes/StickyUtil/constants.ts\nvar STICKY_TEXT_AREA_CLASS_NAME = \"tl-sticky-edit-text-area\";\n\n// src/components/Tldraw/hooks/useKeyboardShortcuts.tsx\nfunction useKeyboardShortcuts(reference) {\n  const app = useTldrawApp();\n  const hotKeySetting = {};\n  const canHandleEvent = React12.useCallback(\n    (ignoreMenus = false) => {\n      const containerElement = reference.current;\n      if (!app.isMouseInBound)\n        return false;\n      if (document.activeElement?.classList?.contains(STICKY_TEXT_AREA_CLASS_NAME))\n        return false;\n      if (ignoreMenus && (app.isMenuOpen || app.settings.keepStyleMenuOpen))\n        return true;\n      return containerElement !== null && (document.activeElement === containerElement || containerElement.contains(document.activeElement));\n    },\n    [reference, app]\n  );\n  React12.useEffect(() => {\n    if (!app)\n      return;\n    const handleCut = (event) => {\n      if (!canHandleEvent(true))\n        return;\n      if (app.readOnly) {\n        app.copy(void 0, event);\n        return;\n      }\n      app.cut(void 0, event);\n    };\n    const handleCopy = (event) => {\n      if (!canHandleEvent(true))\n        return;\n      app.copy(void 0, event);\n    };\n    const handlePaste = (event) => {\n      if (!canHandleEvent(true))\n        return;\n      if (app.readOnly)\n        return;\n      void app.paste(void 0, event);\n    };\n    reference.current?.addEventListener(\"cut\", handleCut);\n    reference.current?.addEventListener(\"copy\", handleCopy);\n    reference.current?.addEventListener(\"paste\", handlePaste);\n    return () => {\n      reference.current?.removeEventListener(\"cut\", handleCut);\n      reference.current?.removeEventListener(\"copy\", handleCopy);\n      reference.current?.removeEventListener(\"paste\", handlePaste);\n    };\n  }, [app]);\n  useHotkeys(\n    \"v,1\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.selectTool(\"select\");\n    },\n    hotKeySetting,\n    [app, reference.current]\n  ).current = reference.current;\n  useHotkeys(\n    \"d,p,2\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.selectTool(\"draw\" /* Draw */);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"e,3\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.selectTool(\"erase\");\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"r,4\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.selectTool(\"rectangle\" /* Rectangle */);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"o,5\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.selectTool(\"ellipse\" /* Ellipse */);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"g,6\",\n    () => {\n      if (!canHandleEvent())\n        return;\n      app.selectTool(\"triangle\" /* Triangle */);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"l,7\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.selectTool(\"line\" /* Line */);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"a,8\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.selectTool(\"arrow\" /* Arrow */);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"t,9\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.selectTool(\"text\" /* Text */);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"s,0\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.selectTool(\"sticky\" /* Sticky */);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"ctrl+.,\\u2318+.\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.toggleFocusMode();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"ctrl+shift+g,\\u2318+shift+g\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.toggleGrid();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  const { onOpenMedia } = useFileSystemHandlers();\n  useHotkeys(\n    \"ctrl+u,\\u2318+u\",\n    (event) => {\n      if (!canHandleEvent())\n        return;\n      onOpenMedia(event);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"\\u2318+z,ctrl+z\",\n    (event) => {\n      event?.preventDefault();\n      event?.stopPropagation();\n      if (!canHandleEvent(true))\n        return;\n      if (app.session === void 0) {\n        app.undo();\n      } else {\n        app.cancelSession();\n      }\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"ctrl+shift+z,\\u2318+shift+z\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      if (app.session === void 0) {\n        app.redo();\n      } else {\n        app.cancelSession();\n      }\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"\\u2318+u,ctrl+u\",\n    () => {\n      if (!canHandleEvent())\n        return;\n      app.undoSelect();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"ctrl+shift-u,\\u2318+shift+u\",\n    () => {\n      if (!canHandleEvent())\n        return;\n      app.redoSelect();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"ctrl+=,\\u2318+=,ctrl+num_add,\\u2318+num_add\",\n    (event) => {\n      if (!canHandleEvent(true))\n        return;\n      app.zoomIn();\n      event?.preventDefault();\n      event?.stopPropagation();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"ctrl+-,\\u2318+-,ctrl+num_subtract,\\u2318+num_subtract\",\n    (event) => {\n      if (!canHandleEvent(true))\n        return;\n      app.zoomOut();\n      event?.preventDefault();\n      event?.stopPropagation();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"shift+0,ctrl+numpad_0,\\u2318+numpad_0\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.resetZoom();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"shift+1\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.zoomToFit();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"shift+2\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.zoomToSelection();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"ctrl+d,\\u2318+d\",\n    (event) => {\n      if (!canHandleEvent())\n        return;\n      app.duplicate();\n      event?.preventDefault();\n      event?.stopPropagation();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"shift+h\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.flipHorizontal();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"shift+v\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.flipVertical();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"escape\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.cancel();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"backspace,del\",\n    () => {\n      if (!canHandleEvent())\n        return;\n      app.delete();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"\\u2318+a,ctrl+a\",\n    (event) => {\n      if (!canHandleEvent(true))\n        return;\n      event.preventDefault();\n      app.selectAll();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"up\",\n    () => {\n      if (!canHandleEvent())\n        return;\n      app.nudge([0, -1], false);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"right\",\n    () => {\n      if (!canHandleEvent())\n        return;\n      app.nudge([1, 0], false);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"down\",\n    () => {\n      if (!canHandleEvent())\n        return;\n      app.nudge([0, 1], false);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"left\",\n    () => {\n      if (!canHandleEvent())\n        return;\n      app.nudge([-1, 0], false);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"shift+up\",\n    () => {\n      if (!canHandleEvent())\n        return;\n      app.nudge([0, -1], true);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"shift+right\",\n    () => {\n      if (!canHandleEvent())\n        return;\n      app.nudge([1, 0], true);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"shift+down\",\n    () => {\n      if (!canHandleEvent())\n        return;\n      app.nudge([0, 1], true);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"shift+left\",\n    () => {\n      if (!canHandleEvent())\n        return;\n      app.nudge([-1, 0], true);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"\\u2318+shift+l,ctrl+shift+l\",\n    () => {\n      if (!canHandleEvent())\n        return;\n      app.toggleLocked();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"\\u2318+g,ctrl+g\",\n    (event) => {\n      if (!canHandleEvent())\n        return;\n      event?.preventDefault();\n      event?.stopPropagation();\n      app.group();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"\\u2318+shift+g,ctrl+shift+g\",\n    (event) => {\n      if (!canHandleEvent())\n        return;\n      event?.preventDefault();\n      event?.stopPropagation();\n      app.ungroup();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"[\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.moveBackward();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"]\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.moveForward();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"shift+[\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.moveToBack();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"shift+]\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.moveToFront();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"ctrl+shift+backspace,\\u2318+shift+backspace\",\n    (event) => {\n      if (!canHandleEvent())\n        return;\n      if (app.settings.isDebugMode) {\n        app.resetDocument();\n      }\n      event?.preventDefault();\n      event?.stopPropagation();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"alt+command+l,alt+ctrl+l\",\n    (event) => {\n      if (!canHandleEvent(true))\n        return;\n      app.style({ textAlign: \"start\" /* Start */ });\n      event?.preventDefault();\n      event?.stopPropagation();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"alt+command+t,alt+ctrl+t\",\n    (event) => {\n      if (!canHandleEvent(true))\n        return;\n      app.style({ textAlign: \"middle\" /* Middle */ });\n      event?.preventDefault();\n      event?.stopPropagation();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"alt+command+r,alt+ctrl+r\",\n    (event) => {\n      if (!canHandleEvent(true))\n        return;\n      app.style({ textAlign: \"end\" /* End */ });\n      event?.preventDefault();\n      event?.stopPropagation();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n}\n\n// src/components/Tldraw/hooks/useTldrawApp.tsx\nvar React13 = __toESM(require(\"react\"));\nvar TldrawContext = React13.createContext({});\nvar useForceUpdate = () => {\n  const [_state, setState] = React13.useState(0);\n  React13.useEffect(() => setState(1));\n};\nfunction useTldrawApp() {\n  const context = React13.useContext(TldrawContext);\n  return context;\n}\nvar ContainerContext = React13.createContext({});\nfunction useContainer() {\n  const context = React13.useContext(ContainerContext);\n  useForceUpdate();\n  return context;\n}\n\n// src/components/Tldraw/hooks/useDialog.ts\nvar React14 = __toESM(require(\"react\"));\nvar AlertDialogContext = React14.createContext({});\nvar useDialog = () => {\n  const context = React14.useContext(AlertDialogContext);\n  if (!context)\n    throw new Error(\"useCtx must be inside a Provider with a value\");\n  return context;\n};\n\n// src/components/Tldraw/components/Primitives/ToolButton/ToolButton.tsx\nvar import_jsx_runtime5 = require(\"react/jsx-runtime\");\nvar ToolButton = React15.forwardRef(\n  ({ onSelect, onClick, onDoubleClick, variant, children, isToolLocked = false, disabled = false, isActive = false, onKeyDown, id, ...rest }, reference) => {\n    return /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(\n      StyledToolButton,\n      {\n        ref: reference,\n        isActive,\n        variant,\n        onClick,\n        disabled,\n        onPointerDown: onSelect,\n        onDoubleClick,\n        onKeyDown,\n        bp: breakpoints,\n        id,\n        ...rest,\n        children: [\n          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(StyledToolButtonInner, { children }),\n          isToolLocked && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(ToolLockIndicator, {})\n        ]\n      }\n    );\n  }\n);\nfunction ToolButtonWithTooltip({ label, kbd, isLocked, ...rest }) {\n  const app = useTldrawApp();\n  const handleDoubleClick = React15.useCallback(() => {\n    app.toggleToolLock();\n  }, []);\n  const handleKeyDown = React15.useCallback((e5) => {\n    if (e5.key === \" \" && app.isForcePanning) {\n      e5.preventDefault();\n    }\n  }, []);\n  return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Tooltip, { label: label[0].toUpperCase() + label.slice(1), kbd, children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(ToolButton, { ...rest, variant: \"primary\", isToolLocked: isLocked && rest.isActive, onDoubleClick: handleDoubleClick, onKeyDown: handleKeyDown }) });\n}\nvar StyledToolButtonInner = styled(\"div\", {\n  position: \"relative\",\n  height: \"100%\",\n  width: \"100%\",\n  backgroundColor: \"$panel\",\n  borderRadius: \"$2\",\n  margin: \"0\",\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  fontFamily: \"$ui\",\n  color: \"inherit\",\n  userSelect: \"none\",\n  boxSizing: \"border-box\",\n  border: \"1px solid transparent\",\n  \"-webkit-tap-highlight-color\": \"transparent\",\n  \"tap-highlight-color\": \"transparent\"\n});\nvar StyledToolButton = styled(\"button\", {\n  position: \"relative\",\n  color: \"$text\",\n  fontSize: \"$0\",\n  background: \"none\",\n  margin: \"0\",\n  padding: \"$2\",\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  outline: \"none\",\n  cursor: \"pointer\",\n  pointerEvents: \"all\",\n  height: \"40px\",\n  width: \"40px\",\n  border: \"1px solid $panel\",\n  \"-webkit-tap-highlight-color\": \"transparent\",\n  \"tap-highlight-color\": \"transparent\",\n  [`&:disabled ${StyledToolButtonInner}`]: {\n    opacity: 0.618\n  },\n  variants: {\n    variant: {\n      primary: {\n        marginTop: \"0\"\n      },\n      icon: {\n        [`& ${StyledToolButtonInner}`]: {\n          display: \"grid\",\n          \"& > *\": {\n            gridRow: 1,\n            gridColumn: 1\n          }\n        }\n      },\n      text: {\n        width: \"auto\",\n        [`& ${StyledToolButtonInner}`]: {\n          fontSize: \"$1\",\n          padding: \"0 $3\",\n          gap: \"$3\"\n        }\n      },\n      circle: {\n        padding: 0,\n        height: 32,\n        width: 32,\n        border: \"none\",\n        [`& ${StyledToolButtonInner}`]: {\n          border: \"1px solid $panelContrast\",\n          borderRadius: \"100%\",\n          boxShadow: \"$panel\"\n        },\n        [`& ${StyledToolButtonInner} > svg`]: {\n          width: 14,\n          height: 14\n        }\n      }\n    },\n    isActive: {\n      true: {},\n      false: {}\n    },\n    bp: {\n      mobile: {\n        padding: 0\n      },\n      small: {}\n    }\n  },\n  compoundVariants: [\n    {\n      variant: \"primary\",\n      bp: \"mobile\",\n      css: {\n        height: 40,\n        width: 36,\n        [`& ${StyledToolButtonInner} > svg`]: {\n          width: 16,\n          height: 16\n        }\n      }\n    },\n    {\n      variant: \"primary\",\n      bp: \"small\",\n      css: {\n        height: \"44px\",\n        width: \"44px\",\n        [`& ${StyledToolButtonInner} > svg`]: {\n          width: 20,\n          height: 20\n        }\n      }\n    },\n    {\n      isActive: true,\n      css: {\n        [`${StyledToolButtonInner}`]: {\n          backgroundColor: \"$selected\",\n          color: \"$selectedContrast\"\n        }\n      }\n    },\n    {\n      isActive: false,\n      bp: \"small\",\n      css: {\n        [`&:hover:not(:disabled) ${StyledToolButtonInner}`]: {\n          backgroundColor: \"$hover\"\n        },\n        [`&:focus:not(:disabled) ${StyledToolButtonInner}`]: {\n          backgroundColor: \"$hover\"\n        }\n      }\n    }\n  ]\n});\nvar ToolLockIndicator = styled(\"div\", {\n  position: \"absolute\",\n  width: 10,\n  height: 10,\n  backgroundColor: \"$selected\",\n  borderRadius: \"100%\",\n  bottom: -2,\n  border: \"2px solid $panel\",\n  zIndex: 100\n});\n\n// src/components/Tldraw/components/ContextMenu/ContextMenu.tsx\nvar import_jsx_runtime6 = require(\"react/jsx-runtime\");\nvar numberOfSelectedIdsSelector = (s5) => {\n  return s5.document.pageStates[s5.appState.currentPageId].selectedIds.length;\n};\nvar isDebugModeSelector = (s5) => {\n  return s5.settings.isDebugMode;\n};\nvar hasGroupSelectedSelector = (s5) => {\n  return s5.document.pageStates[s5.appState.currentPageId].selectedIds.some((id) => s5.document.pages[s5.appState.currentPageId].shapes[id].children !== void 0);\n};\nvar preventDefault = (e5) => e5.stopPropagation();\nvar _ContextMenu = ({ onBlur, children }) => {\n  const container = useContainer();\n  return /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)($1b0217ee4a91d156$export$be92b6f5f03c0fe9, { dir: \"ltr\", children: [\n    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)($1b0217ee4a91d156$export$41fb9f06171c75f4, { dir: \"ltr\", children }),\n    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)($1b0217ee4a91d156$export$602eac185826482c, { container: container.current, children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)($1b0217ee4a91d156$export$7c6e2c02157bb7d2, { onEscapeKeyDown: preventDefault, tabIndex: -1, onBlur, asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(MenuContent, { id: \"TD-ContextMenu\", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(InnerMenu, {}) }) }) })\n  ] });\n};\nvar InnerMenu = React16.memo(function InnerMenu2() {\n  const app = useTldrawApp();\n  const intl = useIntl();\n  const numberOfSelectedIds = app.useStore(numberOfSelectedIdsSelector);\n  const isDebugMode = app.useStore(isDebugModeSelector);\n  const hasGroupSelected = app.useStore(hasGroupSelectedSelector);\n  const handleFlipHorizontal = React16.useCallback(() => {\n    app.flipHorizontal();\n  }, [app]);\n  const handleFlipVertical = React16.useCallback(() => {\n    app.flipVertical();\n  }, [app]);\n  const handleDuplicate = React16.useCallback(() => {\n    app.duplicate();\n  }, [app]);\n  const handleLock = React16.useCallback(() => {\n    app.toggleLocked();\n  }, [app]);\n  const handleGroup = React16.useCallback(() => {\n    app.group();\n  }, [app]);\n  const handleMoveToBack = React16.useCallback(() => {\n    app.moveToBack();\n  }, [app]);\n  const handleMoveBackward = React16.useCallback(() => {\n    app.moveBackward();\n  }, [app]);\n  const handleMoveForward = React16.useCallback(() => {\n    app.moveForward();\n  }, [app]);\n  const handleMoveToFront = React16.useCallback(() => {\n    app.moveToFront();\n  }, [app]);\n  const handleDelete = React16.useCallback(() => {\n    app.delete();\n  }, [app]);\n  const handleCut = React16.useCallback(() => {\n    app.cut();\n  }, [app]);\n  const handleCopy = React16.useCallback(() => {\n    app.copy();\n  }, [app]);\n  const handlePaste = React16.useCallback(() => {\n    app.paste();\n  }, [app]);\n  const handleCopySVG = React16.useCallback(() => {\n    app.copyImage(\"svg\" /* SVG */, { scale: 1, quality: 1, transparentBackground: false });\n  }, [app]);\n  const handleCopyPNG = React16.useCallback(() => {\n    app.copyImage(\"png\" /* PNG */, { scale: 2, quality: 1, transparentBackground: true });\n  }, [app]);\n  const handleUndo = React16.useCallback(() => {\n    app.undo();\n  }, [app]);\n  const handleRedo = React16.useCallback(() => {\n    app.redo();\n  }, [app]);\n  const handleExportPNG = React16.useCallback(async () => {\n    app.exportImage(\"png\" /* PNG */, { scale: 2, quality: 1 });\n  }, [app]);\n  const handleExportJPG = React16.useCallback(async () => {\n    app.exportImage(\"jpeg\" /* JPG */, { scale: 2, quality: 1 });\n  }, [app]);\n  const handleExportWEBP = React16.useCallback(async () => {\n    app.exportImage(\"webp\" /* WEBP */, { scale: 2, quality: 1 });\n  }, [app]);\n  const handleExportSVG = React16.useCallback(async () => {\n    app.exportImage(\"svg\" /* SVG */, { scale: 1, quality: 1 });\n  }, [app]);\n  const handleCopyJSON = React16.useCallback(async () => {\n    app.copyJson();\n  }, [app]);\n  const handleExportJSON = React16.useCallback(async () => {\n    app.exportJson();\n  }, [app]);\n  const hasSelection = numberOfSelectedIds > 0;\n  const hasTwoOrMore = numberOfSelectedIds > 1;\n  const hasThreeOrMore = numberOfSelectedIds > 2;\n  return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: hasSelection ? /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMRowButton, { onClick: handleDuplicate, kbd: \"#D\", id: \"TD-ContextMenu-Duplicate\", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(FormattedMessage, { id: \"duplicate\" }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMRowButton, { onClick: handleFlipHorizontal, kbd: \"\\u21E7H\", id: \"TD-ContextMenu-Flip_Horizontal\", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(FormattedMessage, { id: \"flip.horizontal\" }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMRowButton, { onClick: handleFlipVertical, kbd: \"\\u21E7V\", id: \"TD-ContextMenu-Flip_Vertical\", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(FormattedMessage, { id: \"flip.vertical\" }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(CMRowButton, { onClick: handleLock, kbd: \"#\\u21E7L\", id: \"TD-ContextMenu- Lock_Unlock\", children: [\n      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(FormattedMessage, { id: \"lock\" }),\n      \" / \",\n      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(FormattedMessage, { id: \"unlock\" })\n    ] }),\n    (hasTwoOrMore || hasGroupSelected) && /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(Divider, {}),\n    hasTwoOrMore && /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMRowButton, { onClick: handleGroup, kbd: \"#G\", id: \"TD-ContextMenu-Group\", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(FormattedMessage, { id: \"group\" }) }),\n    hasGroupSelected && /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMRowButton, { onClick: handleGroup, kbd: \"#G\", id: \"TD-ContextMenu-Ungroup\", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(FormattedMessage, { id: \"ungroup\" }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(Divider, {}),\n    /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(ContextMenuSubMenu, { label: intl.formatMessage({ id: \"move\" }), id: \"TD-ContextMenu-Move\", children: [\n      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMRowButton, { onClick: handleMoveToFront, kbd: \"\\u21E7]\", id: \"TD-ContextMenu-Move-To_Front\", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(FormattedMessage, { id: \"to.front\" }) }),\n      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMRowButton, { onClick: handleMoveForward, kbd: \"]\", id: \"TD-ContextMenu-Move-Forward\", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(FormattedMessage, { id: \"forward\" }) }),\n      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMRowButton, { onClick: handleMoveBackward, kbd: \"[\", id: \"TD-ContextMenu-Move-Backward\", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(FormattedMessage, { id: \"backward\" }) }),\n      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMRowButton, { onClick: handleMoveToBack, kbd: \"\\u21E7[\", id: \"TD-ContextMenu-Move-To_Back\", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(FormattedMessage, { id: \"back\" }) })\n    ] }),\n    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(MoveToPageMenu, {}),\n    hasTwoOrMore && /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(AlignDistributeSubMenu, { hasTwoOrMore, hasThreeOrMore }),\n    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(Divider, {}),\n    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMRowButton, { onClick: handleCut, kbd: \"#X\", id: \"TD-ContextMenu-Cut\", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(FormattedMessage, { id: \"cut\" }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMRowButton, { onClick: handleCopy, kbd: \"#C\", id: \"TD-ContextMenu-Copy\", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(FormattedMessage, { id: \"copy\" }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMRowButton, { onClick: handlePaste, kbd: \"#V\", id: \"TD-ContextMenu-Paste\", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(FormattedMessage, { id: \"paste\" }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(Divider, {}),\n    /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(ContextMenuSubMenu, { label: `${intl.formatMessage({ id: \"copy.as\" })}...`, size: \"small\", id: \"TD-ContextMenu-Copy-As\", children: [\n      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMRowButton, { onClick: handleCopySVG, id: \"TD-ContextMenu-Copy-as-SVG\", children: \"SVG\" }),\n      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMRowButton, { onClick: handleCopyPNG, id: \"TD-ContextMenu-Copy-As-PNG\", children: \"PNG\" }),\n      isDebugMode && /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMRowButton, { onClick: handleCopyJSON, id: \"TD-ContextMenu-Copy_as_JSON\", children: \"JSON\" })\n    ] }),\n    /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(ContextMenuSubMenu, { label: `${intl.formatMessage({ id: \"export.as\" })}...`, size: \"small\", id: \"TD-ContextMenu-Export\", children: [\n      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMRowButton, { onClick: handleExportSVG, id: \"TD-ContextMenu-Export-SVG\", children: \"SVG\" }),\n      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMRowButton, { onClick: handleExportPNG, id: \"TD-ContextMenu-Export-PNG\", children: \"PNG\" }),\n      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMRowButton, { onClick: handleExportJPG, id: \"TD-ContextMenu-Export-JPG\", children: \"JPG\" }),\n      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMRowButton, { onClick: handleExportWEBP, id: \"TD-ContextMenu-Export-WEBP\", children: \"WEBP\" }),\n      isDebugMode && /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMRowButton, { onClick: handleExportJSON, id: \"TD-ContextMenu-Export-JSON\", children: \"JSON\" })\n    ] }),\n    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(Divider, {}),\n    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMRowButton, { onClick: handleDelete, kbd: \"\\u232B\", id: \"TD-ContextMenu-Delete\", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(FormattedMessage, { id: \"delete\" }) })\n  ] }) : /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMRowButton, { onClick: handlePaste, kbd: \"#V\", id: \"TD-ContextMenu-Paste\", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(FormattedMessage, { id: \"paste\" }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMRowButton, { onClick: handleUndo, kbd: \"#Z\", id: \"TD-ContextMenu-Undo\", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(FormattedMessage, { id: \"undo\" }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMRowButton, { onClick: handleRedo, kbd: \"#\\u21E7Z\", id: \"TD-ContextMenu-Redo\", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(FormattedMessage, { id: \"redo\" }) })\n  ] }) });\n});\nfunction AlignDistributeSubMenu({ hasThreeOrMore }) {\n  const app = useTldrawApp();\n  const alignTop = React16.useCallback(() => {\n    app.align(\"top\" /* Top */);\n  }, [app]);\n  const alignCenterVertical = React16.useCallback(() => {\n    app.align(\"centerVertical\" /* CenterVertical */);\n  }, [app]);\n  const alignBottom = React16.useCallback(() => {\n    app.align(\"bottom\" /* Bottom */);\n  }, [app]);\n  const stretchVertically = React16.useCallback(() => {\n    app.stretch(\"vertical\" /* Vertical */);\n  }, [app]);\n  const distributeVertically = React16.useCallback(() => {\n    app.distribute(\"vertical\" /* Vertical */);\n  }, [app]);\n  const alignLeft = React16.useCallback(() => {\n    app.align(\"left\" /* Left */);\n  }, [app]);\n  const alignCenterHorizontal = React16.useCallback(() => {\n    app.align(\"centerHorizontal\" /* CenterHorizontal */);\n  }, [app]);\n  const alignRight = React16.useCallback(() => {\n    app.align(\"right\" /* Right */);\n  }, [app]);\n  const stretchHorizontally = React16.useCallback(() => {\n    app.stretch(\"horizontal\" /* Horizontal */);\n  }, [app]);\n  const distributeHorizontally = React16.useCallback(() => {\n    app.distribute(\"horizontal\" /* Horizontal */);\n  }, [app]);\n  const container = useContainer();\n  return /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)($1b0217ee4a91d156$export$d7a01e11500dfb6f, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMSubTriggerButton, { id: \"TD-ContextMenu-Align-Distribute-Trigger\", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(FormattedMessage, { id: \"align.distribute\" }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)($1b0217ee4a91d156$export$602eac185826482c, { container: container.current, children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)($1b0217ee4a91d156$export$6d4de93b380beddf, { asChild: true, sideOffset: 4, alignOffset: -2, children: /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(StyledGridContent, { numberOfSelected: hasThreeOrMore ? \"threeOrMore\" : \"twoOrMore\", children: [\n      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMIconButton, { onClick: alignLeft, id: \"TD-ContextMenu-Align_Distribute-AlignLeft\", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(AlignLeftIcon, {}) }),\n      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMIconButton, { onClick: alignCenterHorizontal, id: \"TD-ContextMenu-Align_Distribute-AlignCenterHorizontal\", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(AlignCenterHorizontallyIcon, {}) }),\n      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMIconButton, { onClick: alignRight, id: \"TD-ContextMenu-Align_Distribute-AlignRight\", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(AlignRightIcon, {}) }),\n      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMIconButton, { onClick: stretchHorizontally, id: \"TD-ContextMenu-Align_Distribute-StretchHorizontal\", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(StretchHorizontallyIcon, {}) }),\n      hasThreeOrMore && /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMIconButton, { onClick: distributeHorizontally, id: \"TD-ContextMenu-Align_Distribute-SpaceEvenlyHorizontal\", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(SpaceEvenlyHorizontallyIcon, {}) }),\n      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMIconButton, { onClick: alignTop, id: \"TD-ContextMenu-Align_Distribute-AlignTop\", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(AlignTopIcon, {}) }),\n      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMIconButton, { onClick: alignCenterVertical, id: \"TD-ContextMenu-Align_Distribute-AlignCenterVertical\", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(AlignCenterVerticallyIcon, {}) }),\n      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMIconButton, { onClick: alignBottom, id: \"TD-ContextMenu-Align_Distribute-AlignBottom\", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(AlignBottomIcon, {}) }),\n      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMIconButton, { onClick: stretchVertically, id: \"TD-ContextMenu-Align_Distribute-StretchVertical\", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(StretchVerticallyIcon, {}) }),\n      hasThreeOrMore && /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMIconButton, { onClick: distributeVertically, id: \"TD-ContextMenu-Align_Distribute-SpaceEvenlyVertical\", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(SpaceEvenlyVerticallyIcon, {}) }),\n      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMArrow, { offset: 13 })\n    ] }) }) })\n  ] });\n}\nvar StyledGridContent = styled(MenuContent, {\n  display: \"grid\",\n  variants: {\n    numberOfSelected: {\n      threeOrMore: {\n        gridTemplateColumns: \"repeat(5, auto)\"\n      },\n      twoOrMore: {\n        gridTemplateColumns: \"repeat(4, auto)\"\n      }\n    }\n  }\n});\nvar currentPageIdSelector = (s5) => s5.appState.currentPageId;\nvar documentPagesSelector = (s5) => s5.document.pages;\nfunction MoveToPageMenu() {\n  const app = useTldrawApp();\n  const currentPageId = app.useStore(currentPageIdSelector);\n  const documentPages = app.useStore(documentPagesSelector);\n  const sorted = Object.values(documentPages).sort((a7, b6) => (a7.childIndex || 0) - (b6.childIndex || 0)).filter((a7) => a7.id !== currentPageId);\n  const container = useContainer();\n  if (sorted.length === 0)\n    return null;\n  return /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)($1b0217ee4a91d156$export$d7a01e11500dfb6f, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMSubTriggerButton, { children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(FormattedMessage, { id: \"move.to.page\" }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)($1b0217ee4a91d156$export$602eac185826482c, { container: container.current, children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)($1b0217ee4a91d156$export$6d4de93b380beddf, { sideOffset: 4, alignOffset: -2, asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(MenuContent, { children: [\n      sorted.map(({ id, name }, index2) => /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMRowButton, { disabled: id === currentPageId, onClick: () => app.moveToPage(id), children: name || `Page ${index2}` }, id)),\n      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMArrow, { offset: 13 })\n    ] }) }) })\n  ] });\n}\nfunction ContextMenuSubMenu({ children, label, size, id }) {\n  const container = useContainer();\n  return /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)($1b0217ee4a91d156$export$d7a01e11500dfb6f, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMSubTriggerButton, { children: label }),\n    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)($1b0217ee4a91d156$export$602eac185826482c, { container: container.current, children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)($1b0217ee4a91d156$export$6d4de93b380beddf, { sideOffset: 4, alignOffset: -2, asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(MenuContent, { size, children: [\n      children,\n      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CMArrow, { offset: 13 })\n    ] }) }) })\n  ] });\n}\nvar CMArrow = styled($1b0217ee4a91d156$export$f47d0a58228a61e2, {\n  fill: \"$panel\"\n});\nfunction CMIconButton({ onSelect, ...rest }) {\n  return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)($1b0217ee4a91d156$export$16a26dc176a49100, { dir: \"ltr\", onSelect, asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(ToolButton, { ...rest }) });\n}\nvar CMRowButton = ({ id, ...rest }) => {\n  return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)($1b0217ee4a91d156$export$16a26dc176a49100, { asChild: true, id, children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(RowButton, { ...rest }) });\n};\nvar CMSubTriggerButton = ({ id, ...rest }) => {\n  return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)($1b0217ee4a91d156$export$2ea8a7a591ac5eac, { asChild: true, id, children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(RowButton, { hasArrow: true, ...rest }) });\n};\nvar ContextMenu = React16.memo(_ContextMenu);\n\n// src/components/Tldraw/components/Primitives/IconButton/IconButton.tsx\nvar IconButton = styled(\"button\", {\n  position: \"relative\",\n  height: \"32px\",\n  width: \"32px\",\n  backgroundColor: \"$panel\",\n  borderRadius: \"4px\",\n  padding: \"0\",\n  margin: \"0\",\n  outline: \"none\",\n  border: \"none\",\n  pointerEvents: \"all\",\n  fontSize: \"$0\",\n  color: \"$text\",\n  cursor: \"pointer\",\n  display: \"grid\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  \"& > *\": {\n    gridRow: 1,\n    gridColumn: 1\n  },\n  \"&:disabled\": {\n    opacity: \"0.5\"\n  },\n  \"& > span\": {\n    width: \"100%\",\n    height: \"100%\",\n    display: \"flex\",\n    alignItems: \"center\"\n  },\n  variants: {\n    bp: {\n      mobile: {\n        backgroundColor: \"transparent\"\n      },\n      small: {\n        \"&:hover:not(:disabled)\": {\n          backgroundColor: \"$hover\"\n        }\n      }\n    },\n    size: {\n      small: {\n        height: 32,\n        width: 32,\n        \"& svg:nth-of-type(1)\": {\n          height: \"16px\",\n          width: \"16px\"\n        }\n      },\n      medium: {\n        height: 44,\n        width: 44,\n        \"& svg:nth-of-type(1)\": {\n          height: \"18px\",\n          width: \"18px\"\n        }\n      },\n      large: {\n        height: 44,\n        width: 44,\n        \"& svg:nth-of-type(1)\": {\n          height: \"20px\",\n          width: \"20px\"\n        }\n      }\n    },\n    isActive: {\n      true: {\n        color: \"$selected\"\n      }\n    }\n  }\n});\n\n// src/components/Tldraw/components/FocusButton/FocusButton.tsx\nvar import_jsx_runtime7 = require(\"react/jsx-runtime\");\nfunction FocusButton({ onSelect }) {\n  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(StyledButtonContainer, { children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(IconButton, { onClick: onSelect, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(DotFilledIcon, {}) }) });\n}\nvar StyledButtonContainer = styled(\"div\", {\n  opacity: 1,\n  zIndex: 100,\n  backgroundColor: \"transparent\",\n  \"& svg\": {\n    color: \"$text\"\n  },\n  \"&:hover svg\": {\n    color: \"$text\"\n  }\n});\n\n// src/components/Tldraw/components/Loading/Loading.tsx\nvar import_jsx_runtime8 = require(\"react/jsx-runtime\");\nvar loadingSelector = (s5) => s5.appState.isLoading;\nfunction Loading() {\n  const app = useTldrawApp();\n  const isLoading = app.useStore(loadingSelector);\n  return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(StyledLoadingPanelContainer, { hidden: !isLoading, children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(FormattedMessage, { id: \"loading\", values: { dots: \"...\" } }) });\n}\nvar StyledLoadingPanelContainer = styled(\"div\", {\n  position: \"absolute\",\n  top: 0,\n  left: \"50%\",\n  transform: `translate(-50%, 0)`,\n  borderBottomLeftRadius: \"12px\",\n  borderBottomRightRadius: \"12px\",\n  padding: \"8px 16px\",\n  fontFamily: \"var(--fonts-ui)\",\n  fontSize: \"var(--fontSizes-1)\",\n  boxShadow: \"var(--shadows-panel)\",\n  backgroundColor: \"white\",\n  zIndex: 200,\n  pointerEvents: \"none\",\n  \"& > div > *\": {\n    pointerEvents: \"all\"\n  },\n  variants: {\n    transform: {\n      hidden: {\n        transform: `translate(-50%, 100%)`\n      },\n      visible: {\n        transform: `translate(-50%, 0%)`\n      }\n    }\n  }\n});\n\n// node_modules/@radix-ui/react-alert-dialog/dist/index.module.js\nvar import_react38 = require(\"react\");\n\n// node_modules/@radix-ui/react-dialog/dist/index.module.js\nvar import_react37 = require(\"react\");\nvar $5d3850c4d0b4e6c7$var$DIALOG_NAME = \"Dialog\";\nvar [$5d3850c4d0b4e6c7$var$createDialogContext, $5d3850c4d0b4e6c7$export$cc702773b8ea3e41] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($5d3850c4d0b4e6c7$var$DIALOG_NAME);\nvar [$5d3850c4d0b4e6c7$var$DialogProvider, $5d3850c4d0b4e6c7$var$useDialogContext] = $5d3850c4d0b4e6c7$var$createDialogContext($5d3850c4d0b4e6c7$var$DIALOG_NAME);\nvar $5d3850c4d0b4e6c7$export$3ddf2d174ce01153 = (props) => {\n  const { __scopeDialog, children, open: openProp, defaultOpen, onOpenChange, modal = true } = props;\n  const triggerRef = (0, import_react37.useRef)(null);\n  const contentRef = (0, import_react37.useRef)(null);\n  const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange\n  });\n  return /* @__PURE__ */ (0, import_react37.createElement)($5d3850c4d0b4e6c7$var$DialogProvider, {\n    scope: __scopeDialog,\n    triggerRef,\n    contentRef,\n    contentId: $1746a345f3d73bb7$export$f680877a34711e37(),\n    titleId: $1746a345f3d73bb7$export$f680877a34711e37(),\n    descriptionId: $1746a345f3d73bb7$export$f680877a34711e37(),\n    open,\n    onOpenChange: setOpen,\n    onOpenToggle: (0, import_react37.useCallback)(\n      () => setOpen(\n        (prevOpen) => !prevOpen\n      ),\n      [\n        setOpen\n      ]\n    ),\n    modal\n  }, children);\n};\nvar $5d3850c4d0b4e6c7$var$TRIGGER_NAME = \"DialogTrigger\";\nvar $5d3850c4d0b4e6c7$export$2e1e1122cf0cba88 = /* @__PURE__ */ (0, import_react37.forwardRef)((props, forwardedRef) => {\n  const { __scopeDialog, ...triggerProps } = props;\n  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$TRIGGER_NAME, __scopeDialog);\n  const composedTriggerRef = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.triggerRef);\n  return /* @__PURE__ */ (0, import_react37.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({\n    type: \"button\",\n    \"aria-haspopup\": \"dialog\",\n    \"aria-expanded\": context.open,\n    \"aria-controls\": context.contentId,\n    \"data-state\": $5d3850c4d0b4e6c7$var$getState(context.open)\n  }, triggerProps, {\n    ref: composedTriggerRef,\n    onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, context.onOpenToggle)\n  }));\n});\nvar $5d3850c4d0b4e6c7$var$PORTAL_NAME = \"DialogPortal\";\nvar [$5d3850c4d0b4e6c7$var$PortalProvider, $5d3850c4d0b4e6c7$var$usePortalContext] = $5d3850c4d0b4e6c7$var$createDialogContext($5d3850c4d0b4e6c7$var$PORTAL_NAME, {\n  forceMount: void 0\n});\nvar $5d3850c4d0b4e6c7$export$dad7c95542bacce0 = (props) => {\n  const { __scopeDialog, forceMount, children, container } = props;\n  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$PORTAL_NAME, __scopeDialog);\n  return /* @__PURE__ */ (0, import_react37.createElement)($5d3850c4d0b4e6c7$var$PortalProvider, {\n    scope: __scopeDialog,\n    forceMount\n  }, import_react37.Children.map(\n    children,\n    (child) => /* @__PURE__ */ (0, import_react37.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {\n      present: forceMount || context.open\n    }, /* @__PURE__ */ (0, import_react37.createElement)($f1701beae083dbae$export$602eac185826482c, {\n      asChild: true,\n      container\n    }, child))\n  ));\n};\nvar $5d3850c4d0b4e6c7$var$OVERLAY_NAME = \"DialogOverlay\";\nvar $5d3850c4d0b4e6c7$export$bd1d06c79be19e17 = /* @__PURE__ */ (0, import_react37.forwardRef)((props, forwardedRef) => {\n  const portalContext = $5d3850c4d0b4e6c7$var$usePortalContext($5d3850c4d0b4e6c7$var$OVERLAY_NAME, props.__scopeDialog);\n  const { forceMount = portalContext.forceMount, ...overlayProps } = props;\n  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$OVERLAY_NAME, props.__scopeDialog);\n  return context.modal ? /* @__PURE__ */ (0, import_react37.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {\n    present: forceMount || context.open\n  }, /* @__PURE__ */ (0, import_react37.createElement)($5d3850c4d0b4e6c7$var$DialogOverlayImpl, _extends({}, overlayProps, {\n    ref: forwardedRef\n  }))) : null;\n});\nvar $5d3850c4d0b4e6c7$var$DialogOverlayImpl = /* @__PURE__ */ (0, import_react37.forwardRef)((props, forwardedRef) => {\n  const { __scopeDialog, ...overlayProps } = props;\n  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$OVERLAY_NAME, __scopeDialog);\n  return /* @__PURE__ */ (0, import_react37.createElement)(Combination_default, {\n    as: $5e63c961fc1ce211$export$8c6ed5c666ac1360,\n    allowPinchZoom: true,\n    shards: [\n      context.contentRef\n    ]\n  }, /* @__PURE__ */ (0, import_react37.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({\n    \"data-state\": $5d3850c4d0b4e6c7$var$getState(context.open)\n  }, overlayProps, {\n    ref: forwardedRef,\n    style: {\n      pointerEvents: \"auto\",\n      ...overlayProps.style\n    }\n  })));\n});\nvar $5d3850c4d0b4e6c7$var$CONTENT_NAME = \"DialogContent\";\nvar $5d3850c4d0b4e6c7$export$b6d9565de1e068cf = /* @__PURE__ */ (0, import_react37.forwardRef)((props, forwardedRef) => {\n  const portalContext = $5d3850c4d0b4e6c7$var$usePortalContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);\n  const { forceMount = portalContext.forceMount, ...contentProps } = props;\n  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);\n  return /* @__PURE__ */ (0, import_react37.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {\n    present: forceMount || context.open\n  }, context.modal ? /* @__PURE__ */ (0, import_react37.createElement)($5d3850c4d0b4e6c7$var$DialogContentModal, _extends({}, contentProps, {\n    ref: forwardedRef\n  })) : /* @__PURE__ */ (0, import_react37.createElement)($5d3850c4d0b4e6c7$var$DialogContentNonModal, _extends({}, contentProps, {\n    ref: forwardedRef\n  })));\n});\nvar $5d3850c4d0b4e6c7$var$DialogContentModal = /* @__PURE__ */ (0, import_react37.forwardRef)((props, forwardedRef) => {\n  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);\n  const contentRef = (0, import_react37.useRef)(null);\n  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.contentRef, contentRef);\n  (0, import_react37.useEffect)(() => {\n    const content = contentRef.current;\n    if (content)\n      return hideOthers(content);\n  }, []);\n  return /* @__PURE__ */ (0, import_react37.createElement)($5d3850c4d0b4e6c7$var$DialogContentImpl, _extends({}, props, {\n    ref: composedRefs,\n    trapFocus: context.open,\n    disableOutsidePointerEvents: true,\n    onCloseAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onCloseAutoFocus, (event) => {\n      var _context$triggerRef$c;\n      event.preventDefault();\n      (_context$triggerRef$c = context.triggerRef.current) === null || _context$triggerRef$c === void 0 || _context$triggerRef$c.focus();\n    }),\n    onPointerDownOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownOutside, (event) => {\n      const originalEvent = event.detail.originalEvent;\n      const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;\n      const isRightClick = originalEvent.button === 2 || ctrlLeftClick;\n      if (isRightClick)\n        event.preventDefault();\n    }),\n    onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(\n      props.onFocusOutside,\n      (event) => event.preventDefault()\n    )\n  }));\n});\nvar $5d3850c4d0b4e6c7$var$DialogContentNonModal = /* @__PURE__ */ (0, import_react37.forwardRef)((props, forwardedRef) => {\n  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);\n  const hasInteractedOutsideRef = (0, import_react37.useRef)(false);\n  return /* @__PURE__ */ (0, import_react37.createElement)($5d3850c4d0b4e6c7$var$DialogContentImpl, _extends({}, props, {\n    ref: forwardedRef,\n    trapFocus: false,\n    disableOutsidePointerEvents: false,\n    onCloseAutoFocus: (event) => {\n      var _props$onCloseAutoFoc;\n      (_props$onCloseAutoFoc = props.onCloseAutoFocus) === null || _props$onCloseAutoFoc === void 0 || _props$onCloseAutoFoc.call(props, event);\n      if (!event.defaultPrevented) {\n        var _context$triggerRef$c2;\n        if (!hasInteractedOutsideRef.current)\n          (_context$triggerRef$c2 = context.triggerRef.current) === null || _context$triggerRef$c2 === void 0 || _context$triggerRef$c2.focus();\n        event.preventDefault();\n      }\n      hasInteractedOutsideRef.current = false;\n    },\n    onInteractOutside: (event) => {\n      var _props$onInteractOuts, _context$triggerRef$c3;\n      (_props$onInteractOuts = props.onInteractOutside) === null || _props$onInteractOuts === void 0 || _props$onInteractOuts.call(props, event);\n      if (!event.defaultPrevented)\n        hasInteractedOutsideRef.current = true;\n      const target = event.target;\n      const targetIsTrigger = (_context$triggerRef$c3 = context.triggerRef.current) === null || _context$triggerRef$c3 === void 0 ? void 0 : _context$triggerRef$c3.contains(target);\n      if (targetIsTrigger)\n        event.preventDefault();\n    }\n  }));\n});\nvar $5d3850c4d0b4e6c7$var$DialogContentImpl = /* @__PURE__ */ (0, import_react37.forwardRef)((props, forwardedRef) => {\n  const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;\n  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, __scopeDialog);\n  const contentRef = (0, import_react37.useRef)(null);\n  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, contentRef);\n  $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c();\n  return /* @__PURE__ */ (0, import_react37.createElement)(import_react37.Fragment, null, /* @__PURE__ */ (0, import_react37.createElement)($d3863c46a17e8a28$export$20e40289641fbbb6, {\n    asChild: true,\n    loop: true,\n    trapped: trapFocus,\n    onMountAutoFocus: onOpenAutoFocus,\n    onUnmountAutoFocus: onCloseAutoFocus\n  }, /* @__PURE__ */ (0, import_react37.createElement)($5cb92bef7577960e$export$177fb62ff3ec1f22, _extends({\n    role: \"dialog\",\n    id: context.contentId,\n    \"aria-describedby\": context.descriptionId,\n    \"aria-labelledby\": context.titleId,\n    \"data-state\": $5d3850c4d0b4e6c7$var$getState(context.open)\n  }, contentProps, {\n    ref: composedRefs,\n    onDismiss: () => context.onOpenChange(false)\n  }))), false);\n});\nvar $5d3850c4d0b4e6c7$var$TITLE_NAME = \"DialogTitle\";\nvar $5d3850c4d0b4e6c7$var$DESCRIPTION_NAME = \"DialogDescription\";\nvar $5d3850c4d0b4e6c7$export$94e94c2ec2c954d5 = /* @__PURE__ */ (0, import_react37.forwardRef)((props, forwardedRef) => {\n  const { __scopeDialog, ...descriptionProps } = props;\n  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$DESCRIPTION_NAME, __scopeDialog);\n  return /* @__PURE__ */ (0, import_react37.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.p, _extends({\n    id: context.descriptionId\n  }, descriptionProps, {\n    ref: forwardedRef\n  }));\n});\nvar $5d3850c4d0b4e6c7$var$CLOSE_NAME = \"DialogClose\";\nvar $5d3850c4d0b4e6c7$export$fba2fb7cd781b7ac = /* @__PURE__ */ (0, import_react37.forwardRef)((props, forwardedRef) => {\n  const { __scopeDialog, ...closeProps } = props;\n  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CLOSE_NAME, __scopeDialog);\n  return /* @__PURE__ */ (0, import_react37.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({\n    type: \"button\"\n  }, closeProps, {\n    ref: forwardedRef,\n    onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(\n      props.onClick,\n      () => context.onOpenChange(false)\n    )\n  }));\n});\nfunction $5d3850c4d0b4e6c7$var$getState(open) {\n  return open ? \"open\" : \"closed\";\n}\nvar $5d3850c4d0b4e6c7$var$TITLE_WARNING_NAME = \"DialogTitleWarning\";\nvar [$5d3850c4d0b4e6c7$export$69b62a49393917d6, $5d3850c4d0b4e6c7$var$useWarningContext] = $c512c27ab02ef895$export$fd42f52fd3ae1109($5d3850c4d0b4e6c7$var$TITLE_WARNING_NAME, {\n  contentName: $5d3850c4d0b4e6c7$var$CONTENT_NAME,\n  titleName: $5d3850c4d0b4e6c7$var$TITLE_NAME,\n  docsSlug: \"dialog\"\n});\nvar $5d3850c4d0b4e6c7$export$be92b6f5f03c0fe9 = $5d3850c4d0b4e6c7$export$3ddf2d174ce01153;\nvar $5d3850c4d0b4e6c7$export$41fb9f06171c75f4 = $5d3850c4d0b4e6c7$export$2e1e1122cf0cba88;\nvar $5d3850c4d0b4e6c7$export$602eac185826482c = $5d3850c4d0b4e6c7$export$dad7c95542bacce0;\nvar $5d3850c4d0b4e6c7$export$c6fdb837b070b4ff = $5d3850c4d0b4e6c7$export$bd1d06c79be19e17;\nvar $5d3850c4d0b4e6c7$export$7c6e2c02157bb7d2 = $5d3850c4d0b4e6c7$export$b6d9565de1e068cf;\nvar $5d3850c4d0b4e6c7$export$393edc798c47379d = $5d3850c4d0b4e6c7$export$94e94c2ec2c954d5;\nvar $5d3850c4d0b4e6c7$export$f39c2d165cd861fe = $5d3850c4d0b4e6c7$export$fba2fb7cd781b7ac;\n\n// node_modules/@radix-ui/react-alert-dialog/dist/index.module.js\nvar $905f4ae918aab1aa$var$ROOT_NAME = \"AlertDialog\";\nvar [$905f4ae918aab1aa$var$createAlertDialogContext, $905f4ae918aab1aa$export$b8891880751c2c5b] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($905f4ae918aab1aa$var$ROOT_NAME, [\n  $5d3850c4d0b4e6c7$export$cc702773b8ea3e41\n]);\nvar $905f4ae918aab1aa$var$useDialogScope = $5d3850c4d0b4e6c7$export$cc702773b8ea3e41();\nvar $905f4ae918aab1aa$export$de466dd8317b0b75 = (props) => {\n  const { __scopeAlertDialog, ...alertDialogProps } = props;\n  const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);\n  return /* @__PURE__ */ (0, import_react38.createElement)($5d3850c4d0b4e6c7$export$be92b6f5f03c0fe9, _extends({}, dialogScope, alertDialogProps, {\n    modal: true\n  }));\n};\nvar $905f4ae918aab1aa$export$6edd7a623ef0f40b = /* @__PURE__ */ (0, import_react38.forwardRef)((props, forwardedRef) => {\n  const { __scopeAlertDialog, ...triggerProps } = props;\n  const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);\n  return /* @__PURE__ */ (0, import_react38.createElement)($5d3850c4d0b4e6c7$export$41fb9f06171c75f4, _extends({}, dialogScope, triggerProps, {\n    ref: forwardedRef\n  }));\n});\nvar $905f4ae918aab1aa$export$660f2bfdb986706c = (props) => {\n  const { __scopeAlertDialog, ...portalProps } = props;\n  const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);\n  return /* @__PURE__ */ (0, import_react38.createElement)($5d3850c4d0b4e6c7$export$602eac185826482c, _extends({}, dialogScope, portalProps));\n};\nvar $905f4ae918aab1aa$export$a707a4895ce23256 = /* @__PURE__ */ (0, import_react38.forwardRef)((props, forwardedRef) => {\n  const { __scopeAlertDialog, ...overlayProps } = props;\n  const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);\n  return /* @__PURE__ */ (0, import_react38.createElement)($5d3850c4d0b4e6c7$export$c6fdb837b070b4ff, _extends({}, dialogScope, overlayProps, {\n    ref: forwardedRef\n  }));\n});\nvar $905f4ae918aab1aa$var$CONTENT_NAME = \"AlertDialogContent\";\nvar [$905f4ae918aab1aa$var$AlertDialogContentProvider, $905f4ae918aab1aa$var$useAlertDialogContentContext] = $905f4ae918aab1aa$var$createAlertDialogContext($905f4ae918aab1aa$var$CONTENT_NAME);\nvar $905f4ae918aab1aa$export$94e6af45f0af4efd = /* @__PURE__ */ (0, import_react38.forwardRef)((props, forwardedRef) => {\n  const { __scopeAlertDialog, children, ...contentProps } = props;\n  const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);\n  const contentRef = (0, import_react38.useRef)(null);\n  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, contentRef);\n  const cancelRef = (0, import_react38.useRef)(null);\n  return /* @__PURE__ */ (0, import_react38.createElement)($5d3850c4d0b4e6c7$export$69b62a49393917d6, {\n    contentName: $905f4ae918aab1aa$var$CONTENT_NAME,\n    titleName: $905f4ae918aab1aa$var$TITLE_NAME,\n    docsSlug: \"alert-dialog\"\n  }, /* @__PURE__ */ (0, import_react38.createElement)($905f4ae918aab1aa$var$AlertDialogContentProvider, {\n    scope: __scopeAlertDialog,\n    cancelRef\n  }, /* @__PURE__ */ (0, import_react38.createElement)($5d3850c4d0b4e6c7$export$7c6e2c02157bb7d2, _extends({\n    role: \"alertdialog\"\n  }, dialogScope, contentProps, {\n    ref: composedRefs,\n    onOpenAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(contentProps.onOpenAutoFocus, (event) => {\n      var _cancelRef$current;\n      event.preventDefault();\n      (_cancelRef$current = cancelRef.current) === null || _cancelRef$current === void 0 || _cancelRef$current.focus({\n        preventScroll: true\n      });\n    }),\n    onPointerDownOutside: (event) => event.preventDefault(),\n    onInteractOutside: (event) => event.preventDefault()\n  }), /* @__PURE__ */ (0, import_react38.createElement)($5e63c961fc1ce211$export$d9f1ccf0bdb05d45, null, children), false)));\n});\nvar $905f4ae918aab1aa$var$TITLE_NAME = \"AlertDialogTitle\";\nvar $905f4ae918aab1aa$export$a23b55cde55ad9a5 = /* @__PURE__ */ (0, import_react38.forwardRef)((props, forwardedRef) => {\n  const { __scopeAlertDialog, ...descriptionProps } = props;\n  const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);\n  return /* @__PURE__ */ (0, import_react38.createElement)($5d3850c4d0b4e6c7$export$393edc798c47379d, _extends({}, dialogScope, descriptionProps, {\n    ref: forwardedRef\n  }));\n});\nvar $905f4ae918aab1aa$export$b454f818c58ee85d = /* @__PURE__ */ (0, import_react38.forwardRef)((props, forwardedRef) => {\n  const { __scopeAlertDialog, ...actionProps } = props;\n  const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);\n  return /* @__PURE__ */ (0, import_react38.createElement)($5d3850c4d0b4e6c7$export$f39c2d165cd861fe, _extends({}, dialogScope, actionProps, {\n    ref: forwardedRef\n  }));\n});\nvar $905f4ae918aab1aa$var$CANCEL_NAME = \"AlertDialogCancel\";\nvar $905f4ae918aab1aa$export$2f67a923571aaea0 = /* @__PURE__ */ (0, import_react38.forwardRef)((props, forwardedRef) => {\n  const { __scopeAlertDialog, ...cancelProps } = props;\n  const { cancelRef } = $905f4ae918aab1aa$var$useAlertDialogContentContext($905f4ae918aab1aa$var$CANCEL_NAME, __scopeAlertDialog);\n  const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);\n  const ref = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, cancelRef);\n  return /* @__PURE__ */ (0, import_react38.createElement)($5d3850c4d0b4e6c7$export$f39c2d165cd861fe, _extends({}, dialogScope, cancelProps, {\n    ref\n  }));\n});\nvar $905f4ae918aab1aa$export$be92b6f5f03c0fe9 = $905f4ae918aab1aa$export$de466dd8317b0b75;\nvar $905f4ae918aab1aa$export$41fb9f06171c75f4 = $905f4ae918aab1aa$export$6edd7a623ef0f40b;\nvar $905f4ae918aab1aa$export$602eac185826482c = $905f4ae918aab1aa$export$660f2bfdb986706c;\nvar $905f4ae918aab1aa$export$c6fdb837b070b4ff = $905f4ae918aab1aa$export$a707a4895ce23256;\nvar $905f4ae918aab1aa$export$7c6e2c02157bb7d2 = $905f4ae918aab1aa$export$94e6af45f0af4efd;\nvar $905f4ae918aab1aa$export$e19cd5f9376f8cee = $905f4ae918aab1aa$export$b454f818c58ee85d;\nvar $905f4ae918aab1aa$export$848c9b7ead0df967 = $905f4ae918aab1aa$export$2f67a923571aaea0;\nvar $905f4ae918aab1aa$export$393edc798c47379d = $905f4ae918aab1aa$export$a23b55cde55ad9a5;\n\n// src/components/Tldraw/components/Primitives/AlertDialog/AlertDialog.tsx\nvar import_jsx_runtime9 = require(\"react/jsx-runtime\");\nfunction Content({ children, onClose, container }) {\n  const handleKeyDown = (event) => {\n    switch (event.key) {\n      case \"Escape\": {\n        onClose?.();\n        break;\n      }\n    }\n  };\n  return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)($905f4ae918aab1aa$export$602eac185826482c, { container, children: [\n    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(StyledOverlay, {}),\n    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(StyledContent2, { onKeyDown: handleKeyDown, children })\n  ] });\n}\nvar StyledDescription = styled($905f4ae918aab1aa$export$393edc798c47379d, {\n  marginBottom: 20,\n  color: \"$text\",\n  fontSize: \"$2\",\n  lineHeight: 1.5,\n  textAlign: \"center\",\n  maxWidth: \"62%\",\n  minWidth: 0,\n  alignSelf: \"center\"\n});\nvar AlertDialogRoot = $905f4ae918aab1aa$export$be92b6f5f03c0fe9;\nvar AlertDialogContent = Content;\nvar AlertDialogDescription = StyledDescription;\nvar AlertDialogAction = $905f4ae918aab1aa$export$e19cd5f9376f8cee;\nvar AlertDialogCancel = $905f4ae918aab1aa$export$848c9b7ead0df967;\nvar AlertDialog = ({ container }) => {\n  const { setDialogState, dialogState, onCancel, onNo, onYes } = useDialog();\n  const intl = useIntl();\n  const descriptions = {\n    saveFirstTime: intl.formatMessage({ id: \"dialog.save.firsttime\" }),\n    saveAgain: intl.formatMessage({ id: \"dialog.save.again\" })\n  };\n  return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(AlertDialogRoot, { open: dialogState !== null, children: /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(AlertDialogContent, { onClose: () => setDialogState(null), container, children: [\n    dialogState && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(AlertDialogDescription, { children: descriptions[dialogState] }),\n    /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(\n      \"div\",\n      {\n        style: {\n          width: \"100%\",\n          gap: \"$6\",\n          display: \"flex\",\n          justifyContent: \"space-between\"\n        },\n        children: [\n          onCancel != void 0 && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(AlertDialogCancel, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(\n            Button,\n            {\n              css: { color: \"$text\" },\n              onClick: () => {\n                onCancel();\n                setDialogState(null);\n              },\n              children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(FormattedMessage, { id: \"dialog.cancel\" })\n            }\n          ) }),\n          /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(\"div\", { style: { flexShrink: 0 }, children: [\n            onNo != void 0 && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(AlertDialogAction, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(\n              Button,\n              {\n                onClick: () => {\n                  onNo();\n                  setDialogState(null);\n                },\n                children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(FormattedMessage, { id: \"dialog.no\" })\n              }\n            ) }),\n            onYes != void 0 && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(AlertDialogAction, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(\n              Button,\n              {\n                css: { backgroundColor: \"#2F80ED\", color: \"White\" },\n                onClick: () => {\n                  onYes();\n                  setDialogState(null);\n                },\n                children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(FormattedMessage, { id: \"dialog.yes\" })\n              }\n            ) })\n          ] })\n        ]\n      }\n    )\n  ] }) });\n};\nvar StyledOverlay = styled($905f4ae918aab1aa$export$c6fdb837b070b4ff, {\n  position: \"fixed\",\n  inset: 0,\n  backgroundColor: \"rgba(0, 0, 0, .15)\",\n  pointerEvents: \"all\"\n});\nvar StyledDialogOverlay = styled($905f4ae918aab1aa$export$c6fdb837b070b4ff, {\n  backgroundColor: \"rgba(0, 0, 0, .15)\",\n  position: \"absolute\",\n  pointerEvents: \"all\",\n  inset: 0\n});\nvar StyledContent2 = styled($905f4ae918aab1aa$export$7c6e2c02157bb7d2, {\n  position: \"fixed\",\n  font: \"$ui\",\n  top: \"50%\",\n  left: \"50%\",\n  transform: \"translate(-50%, -50%)\",\n  width: \"max-content\",\n  padding: \"$3\",\n  pointerEvents: \"all\",\n  backgroundColor: \"$panel\",\n  borderRadius: \"$3\",\n  display: \"flex\",\n  flexDirection: \"column\",\n  justifyContent: \"center\",\n  fontFamily: \"$ui\",\n  border: \"1px solid $panelContrast\",\n  boxShadow: \"$panel\"\n});\nvar Button = styled(\"button\", {\n  all: \"unset\",\n  display: \"inline-flex\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  borderRadius: \"$2\",\n  padding: \"0 15px\",\n  fontSize: \"$1\",\n  lineHeight: 1,\n  fontWeight: \"normal\",\n  height: 36,\n  color: \"$text\",\n  cursor: \"pointer\",\n  minWidth: 48\n});\n\n// src/components/Tldraw/components/ToolsPanel/ToolsPanel.tsx\nvar React22 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/components/ToolsPanel/ActionButton.tsx\nvar React17 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/components/Primitives/DropdownMenu/DMItem.tsx\nvar import_jsx_runtime10 = require(\"react/jsx-runtime\");\nfunction DMItem({ onSelect, id, ...rest }) {\n  return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)($d08ef79370b62062$export$6d08773d2e66f8f2, { dir: \"ltr\", asChild: true, onSelect, id, children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(RowButton, { ...rest }) });\n}\n\n// src/components/Tldraw/components/preventEvent.ts\nvar preventEvent = (e5) => e5.preventDefault();\n\n// src/components/Tldraw/components/Primitives/DropdownMenu/DMCheckboxItem.tsx\nvar import_jsx_runtime11 = require(\"react/jsx-runtime\");\nfunction DMCheckboxItem({ checked, disabled = false, variant, onCheckedChange, kbd, id, children }) {\n  return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)($d08ef79370b62062$export$16ce288f89fa631c, { dir: \"ltr\", onSelect: preventEvent, onCheckedChange, checked, disabled, asChild: true, id, children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(RowButton, { kbd, variant, hasIndicator: true, children }) });\n}\n\n// src/components/Tldraw/components/stopPropagation.ts\nvar stopPropagation = (e5) => e5.stopPropagation();\n\n// src/components/Tldraw/components/Primitives/DropdownMenu/DMContent.tsx\nvar import_jsx_runtime12 = require(\"react/jsx-runtime\");\nfunction DMContent({ sideOffset = 4, alignOffset = 0, children, align, variant, id, overflow = false, side = \"bottom\" }) {\n  const container = useContainer();\n  return /* @__PURE__ */ (0, import_jsx_runtime12.jsx)($d08ef79370b62062$export$602eac185826482c, { container: container.current, dir: \"ltr\", children: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)($d08ef79370b62062$export$7c6e2c02157bb7d2, { align, alignOffset, sideOffset, onEscapeKeyDown: stopPropagation, asChild: true, id, side, children: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(StyledContent3, { variant, overflow, children }) }) });\n}\nvar StyledContent3 = styled(MenuContent, {\n  width: \"fit-content\",\n  height: \"fit-content\",\n  minWidth: 0,\n  maxHeight: \"100vh\",\n  overflowY: \"auto\",\n  overflowX: \"hidden\",\n  \"&::webkit-scrollbar\": {\n    display: \"none\"\n  },\n  \"-ms-overflow-style\": \"none\",\n  scrollbarWidth: \"none\",\n  variants: {\n    variant: {\n      horizontal: {\n        flexDirection: \"row\"\n      },\n      menu: {\n        minWidth: 128\n      }\n    },\n    overflow: {\n      true: {\n        maxHeight: \"60vh\"\n      }\n    }\n  }\n});\n\n// src/components/Tldraw/components/Primitives/DropdownMenu/DMDivider.tsx\nvar DMDivider = styled($d08ef79370b62062$export$1ff3c3f08ae963c0, {\n  backgroundColor: \"$hover\",\n  height: 1,\n  marginTop: \"$2\",\n  marginRight: \"-$2\",\n  marginBottom: \"$2\",\n  marginLeft: \"-$2\"\n});\n\n// src/components/Tldraw/components/Primitives/DropdownMenu/DMRadioItem.tsx\nvar DMRadioItem = styled($d08ef79370b62062$export$371ab307eab489c0, {\n  height: \"32px\",\n  width: \"32px\",\n  backgroundColor: \"$panel\",\n  borderRadius: \"4px\",\n  padding: \"0\",\n  margin: \"0\",\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  outline: \"none\",\n  border: \"none\",\n  pointerEvents: \"all\",\n  cursor: \"pointer\",\n  variants: {\n    isActive: {\n      true: {\n        backgroundColor: \"$selected\",\n        color: \"white\"\n      },\n      false: {}\n    },\n    bp: {\n      mobile: {},\n      small: {}\n    }\n  },\n  compoundVariants: [\n    {\n      isActive: false,\n      bp: \"small\",\n      css: {\n        \"&:focus\": {\n          backgroundColor: \"$hover\"\n        },\n        \"&:hover:not(:disabled)\": {\n          backgroundColor: \"$hover\"\n        }\n      }\n    }\n  ]\n});\n\n// src/components/Tldraw/components/Primitives/DropdownMenu/DMSubMenu.tsx\nvar import_jsx_runtime13 = require(\"react/jsx-runtime\");\nfunction DMSubMenu({ children, size, overflow = false, disabled = false, label, id }) {\n  return /* @__PURE__ */ (0, import_jsx_runtime13.jsxs)($d08ef79370b62062$export$d7a01e11500dfb6f, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime13.jsx)($d08ef79370b62062$export$2ea8a7a591ac5eac, { dir: \"ltr\", asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(RowButton, { disabled, hasArrow: true, children: label }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime13.jsx)($d08ef79370b62062$export$6d4de93b380beddf, { asChild: true, sideOffset: 4, alignOffset: -4, children: /* @__PURE__ */ (0, import_jsx_runtime13.jsxs)(MenuContent, { size, overflow, children: [\n      children,\n      /* @__PURE__ */ (0, import_jsx_runtime13.jsx)($d08ef79370b62062$export$21b07c8f274aebd5, { offset: 13 })\n    ] }) })\n  ] }, id);\n}\n\n// src/components/Tldraw/components/Primitives/DropdownMenu/DMTriggerIcon.tsx\nvar import_jsx_runtime14 = require(\"react/jsx-runtime\");\nfunction DMTriggerIcon({ id, children, ...rest }) {\n  return /* @__PURE__ */ (0, import_jsx_runtime14.jsx)($d08ef79370b62062$export$41fb9f06171c75f4, { asChild: true, id, children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(ToolButton, { ...rest, children }) });\n}\n\n// src/components/Tldraw/components/ToolsPanel/ActionButton.tsx\nvar import_jsx_runtime15 = require(\"react/jsx-runtime\");\nvar dockPositionState = (s5) => s5.settings.dockPosition;\nvar selectedShapesCountSelector = (s5) => s5.document.pageStates[s5.appState.currentPageId].selectedIds.length;\nvar isAllLockedSelector = (s5) => {\n  const page = s5.document.pages[s5.appState.currentPageId];\n  const { selectedIds } = s5.document.pageStates[s5.appState.currentPageId];\n  return selectedIds.every((id) => page.shapes[id].isLocked);\n};\nvar isAllAspectLockedSelector = (s5) => {\n  const page = s5.document.pages[s5.appState.currentPageId];\n  const { selectedIds } = s5.document.pageStates[s5.appState.currentPageId];\n  return selectedIds.every((id) => page.shapes[id].isAspectRatioLocked);\n};\nvar isAllGroupedSelector = (s5) => {\n  const page = s5.document.pages[s5.appState.currentPageId];\n  const selectedShapes = s5.document.pageStates[s5.appState.currentPageId].selectedIds.map((id) => page.shapes[id]);\n  return selectedShapes.every(\n    (shape) => shape.children !== void 0 || shape.parentId === selectedShapes[0].parentId && selectedShapes[0].parentId !== s5.appState.currentPageId\n  );\n};\nvar hasSelectionSelector = (s5) => {\n  const { selectedIds } = s5.document.pageStates[s5.appState.currentPageId];\n  return selectedIds.length > 0;\n};\nvar hasMultipleSelectionSelector = (s5) => {\n  const { selectedIds } = s5.document.pageStates[s5.appState.currentPageId];\n  return selectedIds.length > 1;\n};\nfunction ActionButton() {\n  const app = useTldrawApp();\n  const intl = useIntl();\n  const isAllLocked = app.useStore(isAllLockedSelector);\n  const isAllAspectLocked = app.useStore(isAllAspectLockedSelector);\n  const isAllGrouped = app.useStore(isAllGroupedSelector);\n  const hasSelection = app.useStore(hasSelectionSelector);\n  const hasMultipleSelection = app.useStore(hasMultipleSelectionSelector);\n  const selectedShapesCount = app.useStore(selectedShapesCountSelector);\n  const dockPosition = app.useStore(dockPositionState);\n  const hasTwoOrMore = selectedShapesCount > 1;\n  const hasThreeOrMore = selectedShapesCount > 2;\n  const handleRotate = React17.useCallback(() => {\n    app.rotate();\n  }, [app]);\n  const handleDuplicate = React17.useCallback(() => {\n    app.duplicate();\n  }, [app]);\n  const handleToggleLocked = React17.useCallback(() => {\n    app.toggleLocked();\n  }, [app]);\n  const handleToggleAspectRatio = React17.useCallback(() => {\n    app.toggleAspectRatioLocked();\n  }, [app]);\n  const handleGroup = React17.useCallback(() => {\n    app.group();\n  }, [app]);\n  const handleMoveToBack = React17.useCallback(() => {\n    app.moveToBack();\n  }, [app]);\n  const handleMoveBackward = React17.useCallback(() => {\n    app.moveBackward();\n  }, [app]);\n  const handleMoveForward = React17.useCallback(() => {\n    app.moveForward();\n  }, [app]);\n  const handleMoveToFront = React17.useCallback(() => {\n    app.moveToFront();\n  }, [app]);\n  const handleResetAngle = React17.useCallback(() => {\n    app.setShapeProps({ rotation: 0 });\n  }, [app]);\n  const alignTop = React17.useCallback(() => {\n    app.align(\"top\" /* Top */);\n  }, [app]);\n  const alignCenterVertical = React17.useCallback(() => {\n    app.align(\"centerVertical\" /* CenterVertical */);\n  }, [app]);\n  const alignBottom = React17.useCallback(() => {\n    app.align(\"bottom\" /* Bottom */);\n  }, [app]);\n  const stretchVertically = React17.useCallback(() => {\n    app.stretch(\"vertical\" /* Vertical */);\n  }, [app]);\n  const distributeVertically = React17.useCallback(() => {\n    app.distribute(\"vertical\" /* Vertical */);\n  }, [app]);\n  const alignLeft = React17.useCallback(() => {\n    app.align(\"left\" /* Left */);\n  }, [app]);\n  const alignCenterHorizontal = React17.useCallback(() => {\n    app.align(\"centerHorizontal\" /* CenterHorizontal */);\n  }, [app]);\n  const alignRight = React17.useCallback(() => {\n    app.align(\"right\" /* Right */);\n  }, [app]);\n  const stretchHorizontally = React17.useCallback(() => {\n    app.stretch(\"horizontal\" /* Horizontal */);\n  }, [app]);\n  const distributeHorizontally = React17.useCallback(() => {\n    app.distribute(\"horizontal\" /* Horizontal */);\n  }, [app]);\n  const handleMenuOpenChange = React17.useCallback(\n    (open) => {\n      app.setMenuOpen(open);\n    },\n    [app]\n  );\n  const contentSide = dockPosition === \"bottom\" || dockPosition === \"top\" ? \"top\" : dockPosition;\n  return /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)($d08ef79370b62062$export$be92b6f5f03c0fe9, { dir: \"ltr\", onOpenChange: handleMenuOpenChange, children: [\n    /* @__PURE__ */ (0, import_jsx_runtime15.jsx)($d08ef79370b62062$export$41fb9f06171c75f4, { dir: \"ltr\", asChild: true, id: \"TD-Tools-Dots\", children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(ToolButton, { variant: \"circle\", children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(DotsHorizontalIcon, {}) }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(DMContent, { sideOffset: 16, side: contentSide, children: /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)(import_jsx_runtime15.Fragment, { children: [\n      /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)(ButtonsRow, { children: [\n        /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(Tooltip, { label: intl.formatMessage({ id: \"duplicate\" }), kbd: `#D`, id: \"TD-Tools-Copy\", children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(ToolButton, { disabled: !hasSelection, onClick: handleDuplicate, children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(CopyIcon, {}) }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(Tooltip, { label: intl.formatMessage({ id: \"rotate\" }), id: \"TD-Tools-Rotate\", children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(ToolButton, { disabled: !hasSelection, onClick: handleRotate, children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(RotateCounterClockwiseIcon, {}) }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(Tooltip, { label: intl.formatMessage({ id: isAllLocked ? \"unlock\" : \"lock\" }), kbd: `#L`, id: \"TD-Tools-Lock\", children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(ToolButton, { disabled: !hasSelection, onClick: handleToggleLocked, children: isAllLocked ? /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(LockClosedIcon, {}) : /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(LockOpen1Icon, {}) }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(\n          Tooltip,\n          {\n            label: intl.formatMessage({\n              id: isAllAspectLocked ? \"unlock.aspect.ratio\" : \"lock.aspect.ratio\"\n            }),\n            id: \"TD-Tools-AspectRatio\",\n            children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(ToolButton, { disabled: !hasSelection, onClick: handleToggleAspectRatio, children: isAllAspectLocked ? /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(AspectRatioIcon, {}) : /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(BoxIcon, {}) })\n          }\n        ),\n        /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(Tooltip, { label: intl.formatMessage({ id: \"group\" }), kbd: `#G`, id: \"TD-Tools-Group\", children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(ToolButton, { disabled: !hasSelection || !isAllGrouped && !hasMultipleSelection, onClick: handleGroup, children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(GroupIcon, {}) }) })\n      ] }),\n      /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)(ButtonsRow, { children: [\n        /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(Tooltip, { label: intl.formatMessage({ id: \"move.to.back\" }), kbd: `#\\u21E7[`, id: \"TD-Tools-PinBottom\", children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(ToolButton, { disabled: !hasSelection, onClick: handleMoveToBack, children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(PinBottomIcon, {}) }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(Tooltip, { label: intl.formatMessage({ id: \"move.backward\" }), kbd: `#[`, id: \"TD-Tools-ArrowDown\", children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(ToolButton, { disabled: !hasSelection, onClick: handleMoveBackward, children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(ArrowDownIcon, {}) }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(Tooltip, { label: intl.formatMessage({ id: \"move.forward\" }), kbd: `#]`, id: \"TD-Tools-ArrowUp\", children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(ToolButton, { disabled: !hasSelection, onClick: handleMoveForward, children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(ArrowUpIcon, {}) }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(Tooltip, { label: intl.formatMessage({ id: \"move.to.front\" }), kbd: `#\\u21E7]`, id: \"TD-Tools-PinTop\", children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(ToolButton, { disabled: !hasSelection, onClick: handleMoveToFront, children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(PinTopIcon, {}) }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(Tooltip, { label: intl.formatMessage({ id: \"reset.angle\" }), id: \"TD-Tools-ResetAngle\", children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(ToolButton, { disabled: !hasSelection, onClick: handleResetAngle, children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(AngleIcon, {}) }) })\n      ] }),\n      /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(Divider, {}),\n      /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)(ButtonsRow, { children: [\n        /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(Tooltip, { label: intl.formatMessage({ id: \"align.left\" }), id: \"TD-Tools-AlignLeft\", children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(ToolButton, { disabled: !hasTwoOrMore, onClick: alignLeft, children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(AlignLeftIcon, {}) }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(Tooltip, { label: intl.formatMessage({ id: \"align.center.x\" }), id: \"TD-Tools-AlignCenterHorizontal\", children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(ToolButton, { disabled: !hasTwoOrMore, onClick: alignCenterHorizontal, children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(AlignCenterHorizontallyIcon, {}) }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(Tooltip, { label: intl.formatMessage({ id: \"align.right\" }), id: \"TD-Tools-AlignRight\", children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(ToolButton, { disabled: !hasTwoOrMore, onClick: alignRight, children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(AlignRightIcon, {}) }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(Tooltip, { label: intl.formatMessage({ id: \"stretch.x\" }), id: \"TD-Tools-StretchHorizontal\", children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(ToolButton, { disabled: !hasTwoOrMore, onClick: stretchHorizontally, children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(StretchHorizontallyIcon, {}) }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(Tooltip, { label: intl.formatMessage({ id: \"distribute.x\" }), id: \"TD-Tools-SpaceEvenlyHorizontal\", children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(ToolButton, { disabled: !hasThreeOrMore, onClick: distributeHorizontally, children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(SpaceEvenlyHorizontallyIcon, {}) }) })\n      ] }),\n      /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)(ButtonsRow, { children: [\n        /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(Tooltip, { label: intl.formatMessage({ id: \"align.top\" }), id: \"TD-Tools-AlignTop\", children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(ToolButton, { disabled: !hasTwoOrMore, onClick: alignTop, children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(AlignTopIcon, {}) }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(Tooltip, { label: intl.formatMessage({ id: \"align.center.y\" }), id: \"TD-Tools-AlignCenterVertical\", children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(ToolButton, { disabled: !hasTwoOrMore, onClick: alignCenterVertical, children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(AlignCenterVerticallyIcon, {}) }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(Tooltip, { label: intl.formatMessage({ id: \"align.bottom\" }), id: \"TD-Tools-AlignBottom\", children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(ToolButton, { disabled: !hasTwoOrMore, onClick: alignBottom, children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(AlignBottomIcon, {}) }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(Tooltip, { label: intl.formatMessage({ id: \"stretch.y\" }), id: \"TD-Tools-StretchVertical\", children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(ToolButton, { disabled: !hasTwoOrMore, onClick: stretchVertically, children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(StretchVerticallyIcon, {}) }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(Tooltip, { label: intl.formatMessage({ id: \"distribute.y\" }), id: \"TD-Tools-SpaceEvenlyVertical\", children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(ToolButton, { disabled: !hasThreeOrMore, onClick: distributeVertically, children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(SpaceEvenlyVerticallyIcon, {}) }) })\n      ] })\n    ] }) })\n  ] });\n}\nvar ButtonsRow = styled(\"div\", {\n  position: \"relative\",\n  display: \"flex\",\n  width: \"100%\",\n  background: \"none\",\n  border: \"none\",\n  cursor: \"pointer\",\n  outline: \"none\",\n  alignItems: \"center\",\n  justifyContent: \"flex-start\",\n  padding: 0\n});\n\n// src/components/Tldraw/components/ToolsPanel/BackToContent.tsx\nvar React18 = __toESM(require(\"react\"));\nvar import_jsx_runtime16 = require(\"react/jsx-runtime\");\nvar isEmptyCanvasSelector = (s5) => {\n  return s5.appState.isEmptyCanvas && Object.keys(s5.document.pages[s5.appState.currentPageId].shapes).length > 0;\n};\nvar isDebugModeSelector2 = (s5) => s5.settings.isDebugMode;\nvar dockPositionState2 = (s5) => s5.settings.dockPosition;\nvar BackToContent = React18.memo(function BackToContent2() {\n  const app = useTldrawApp();\n  const isEmptyCanvas = app.useStore(isEmptyCanvasSelector);\n  const dockPosition = app.useStore(dockPositionState2);\n  const isDebugMode = app.useStore(isDebugModeSelector2);\n  const style = {\n    bottom: dockPosition === \"bottom\" && isDebugMode ? 120 : dockPosition === \"bottom\" ? 80 : isDebugMode ? 60 : 20,\n    left: \"50%\",\n    transform: \"translate(-50%,0)\"\n  };\n  if (!isEmptyCanvas)\n    return null;\n  return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(BackToContentContainer, { id: \"TD-Tools-Back_to_content\", style: { ...style }, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(RowButton, { onClick: app.zoomToContent, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(FormattedMessage, { id: \"zoom.to.content\" }) }) });\n});\nvar BackToContentContainer = styled(MenuContent, {\n  pointerEvents: \"all\",\n  width: \"fit-content\",\n  minWidth: 0,\n  position: \"fixed\",\n  bottom: 0\n});\n\n// src/components/Tldraw/components/ToolsPanel/DeleteButton.tsx\nvar React19 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/components/Primitives/icons/BoxIcon.tsx\nvar import_jsx_runtime17 = require(\"react/jsx-runtime\");\n\n// src/components/Tldraw/components/Primitives/icons/CircleIcon.tsx\nvar import_jsx_runtime18 = require(\"react/jsx-runtime\");\nfunction CircleIcon2(props) {\n  const { size = 16, ...rest } = props;\n  return /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(\"svg\", { width: 24, height: 24, ...rest, children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(\"circle\", { cx: 12, cy: 12, r: size / 2 }) });\n}\n\n// src/components/Tldraw/components/Primitives/icons/DashDashedIcon.tsx\nvar import_jsx_runtime19 = require(\"react/jsx-runtime\");\nfunction DashDashedIcon() {\n  return /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(\"svg\", { width: \"24\", height: \"24\", stroke: \"currentColor\", xmlns: \"http://www.w3.org/2000/svg\", children: /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(\"circle\", { cx: 12, cy: 12, r: 8, fill: \"none\", strokeWidth: 2.5, strokeLinecap: \"round\", strokeDasharray: 50.26548 * 0.1 }) });\n}\n\n// src/components/Tldraw/components/Primitives/icons/DashDottedIcon.tsx\nvar import_jsx_runtime20 = require(\"react/jsx-runtime\");\nvar dottedDasharray = `${50.26548 * 0.025} ${50.26548 * 0.1}`;\nfunction DashDottedIcon() {\n  return /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(\"svg\", { width: \"24\", height: \"24\", stroke: \"currentColor\", xmlns: \"http://www.w3.org/2000/svg\", children: /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(\"circle\", { cx: 12, cy: 12, r: 8, fill: \"none\", strokeWidth: 2.5, strokeLinecap: \"round\", strokeDasharray: dottedDasharray }) });\n}\n\n// src/components/Tldraw/components/Primitives/icons/DashDrawIcon.tsx\nvar import_jsx_runtime21 = require(\"react/jsx-runtime\");\nfunction DashDrawIcon() {\n  return /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(\"svg\", { width: \"24\", height: \"24\", viewBox: \"1 1.5 21 22\", fill: \"currentColor\", stroke: \"currentColor\", xmlns: \"http://www.w3.org/2000/svg\", children: /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(\n    \"path\",\n    {\n      d: \"M10.0162 19.2768C10.0162 19.2768 9.90679 19.2517 9.6879 19.2017C9.46275 19.1454 9.12816 19.0422 8.68413 18.8921C8.23384 18.7358 7.81482 18.545 7.42707 18.3199C7.03307 18.101 6.62343 17.7883 6.19816 17.3818C5.77289 16.9753 5.33511 16.3718 4.88482 15.5713C4.43453 14.7645 4.1531 13.8545 4.04053 12.8414C3.92795 11.822 4.04991 10.8464 4.40639 9.91451C4.76286 8.98266 5.39452 8.10084 6.30135 7.26906C7.21444 6.44353 8.29325 5.83377 9.5378 5.43976C10.7823 5.05202 11.833 4.92068 12.6898 5.04576C13.5466 5.16459 14.3878 5.43664 15.2133 5.86191C16.0388 6.28718 16.7768 6.8688 17.4272 7.60678C18.0714 8.34475 18.5404 9.21406 18.8344 10.2147C19.1283 11.2153 19.1721 12.2598 18.9657 13.348C18.7593 14.4299 18.2872 15.4337 17.5492 16.3593C16.8112 17.2849 15.9263 18.0072 14.8944 18.5263C13.8624 19.0391 12.9056 19.3174 12.0238 19.3612C11.142 19.405 10.2101 19.2705 9.22823 18.9578C8.24635 18.6451 7.35828 18.151 6.56402 17.4756C5.77601 16.8002 6.08871 16.8658 7.50212 17.6726C8.90927 18.4731 10.1444 18.8484 11.2076 18.7983C12.2645 18.7545 13.2965 18.4825 14.3034 17.9822C15.3102 17.4819 16.1264 16.8221 16.7518 16.0028C17.3772 15.1835 17.7681 14.3111 17.9244 13.3855C18.0808 12.4599 18.0401 11.5781 17.8025 10.74C17.5586 9.902 17.1739 9.15464 16.6486 8.49797C16.1233 7.8413 15.2289 7.27844 13.9656 6.80939C12.7086 6.34034 11.4203 6.20901 10.1007 6.41539C8.78732 6.61552 7.69599 7.06893 6.82669 7.77564C5.96363 8.48859 5.34761 9.26409 4.97863 10.1021C4.60964 10.9402 4.45329 11.8376 4.50958 12.7945C4.56586 13.7513 4.79101 14.6238 5.18501 15.4118C5.57276 16.1998 5.96363 16.8002 6.35764 17.2129C6.75164 17.6257 7.13313 17.9509 7.50212 18.1886C7.87736 18.4325 8.28074 18.642 8.71227 18.8171C9.15005 18.9922 9.47839 19.111 9.69728 19.1736C9.91617 19.2361 10.0256 19.2705 10.0256 19.2768H10.0162Z\",\n      strokeWidth: \"2\"\n    }\n  ) });\n}\n\n// src/components/Tldraw/components/Primitives/icons/DashSolidIcon.tsx\nvar import_jsx_runtime22 = require(\"react/jsx-runtime\");\nfunction DashSolidIcon() {\n  return /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(\"svg\", { width: \"24\", height: \"24\", stroke: \"currentColor\", xmlns: \"http://www.w3.org/2000/svg\", children: /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(\"circle\", { cx: 12, cy: 12, r: 8, fill: \"none\", strokeWidth: 2, strokeLinecap: \"round\" }) });\n}\n\n// src/components/Tldraw/components/Primitives/icons/TrashIcon.tsx\nvar import_jsx_runtime23 = require(\"react/jsx-runtime\");\nfunction TrashIcon(props) {\n  return /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)(\"svg\", { width: 18, height: 18, viewBox: \"0 0 15 15\", fill: \"currentColor\", xmlns: \"http://www.w3.org/2000/svg\", ...props, children: [\n    /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(\"path\", { fillRule: \"evenodd\", clipRule: \"evenodd\", d: \"M2 4.656a.5.5 0 01.5-.5h9.7a.5.5 0 010 1H2.5a.5.5 0 01-.5-.5z\" }),\n    /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M6.272 3a.578.578 0 00-.578.578v.578h3.311v-.578A.578.578 0 008.428 3H6.272zm3.733 1.156v-.578A1.578 1.578 0 008.428 2H6.272a1.578 1.578 0 00-1.578 1.578v.578H3.578a.5.5 0 00-.5.5V12.2a1.578 1.578 0 001.577 1.578h5.39a1.578 1.578 0 001.577-1.578V4.656a.5.5 0 00-.5-.5h-1.117zm-5.927 1V12.2a.578.578 0 00.577.578h5.39a.578.578 0 00.577-.578V5.156H4.078z\"\n      }\n    ),\n    /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M6.272 6.85a.5.5 0 01.5.5v3.233a.5.5 0 11-1 0V7.35a.5.5 0 01.5-.5zM8.428 6.85a.5.5 0 01.5.5v3.233a.5.5 0 11-1 0V7.35a.5.5 0 01.5-.5z\"\n      }\n    )\n  ] });\n}\n\n// src/components/Tldraw/components/Primitives/icons/UndoIcon.tsx\nvar import_jsx_runtime24 = require(\"react/jsx-runtime\");\nfunction UndoIcon({ flipHorizontal, ...props }) {\n  return /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(\n    \"svg\",\n    {\n      width: 24,\n      height: 24,\n      viewBox: \"0 0 15 15\",\n      fill: \"currentColor\",\n      xmlns: \"http://www.w3.org/2000/svg\",\n      style: {\n        transform: flipHorizontal ? \"scale(-1, 1)\" : \"scale(1, 1)\"\n      },\n      ...props,\n      children: /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(\"path\", { d: \"M10.6707 8.5081C10.6707 10.1923 9.3004 11.5625 7.61631 11.5625H6.5351C6.35593 11.5625 6.21074 11.4173 6.21074 11.2382V11.13C6.21074 10.9508 6.35591 10.8057 6.5351 10.8057H7.61631C8.88313 10.8057 9.91387 9.77492 9.91387 8.5081C9.91387 7.24128 8.88313 6.21054 7.61631 6.21054H5.62155L6.99534 7.58433C7.14289 7.73183 7.14289 7.97195 6.99534 8.11944C6.85216 8.26251 6.60298 8.2623 6.46013 8.11944L4.44045 6.09971C4.36898 6.02824 4.32959 5.93321 4.32959 5.8321C4.32959 5.73106 4.36898 5.63598 4.44045 5.56454L6.46024 3.54472C6.60309 3.40176 6.85248 3.40176 6.99535 3.54472C7.14291 3.69218 7.14291 3.93234 6.99535 4.07979L5.62156 5.45368H7.61631C9.3004 5.45368 10.6707 6.82393 10.6707 8.5081Z\" })\n    }\n  );\n}\n\n// src/components/Tldraw/components/Primitives/icons/SizeSmallIcon.tsx\nvar import_jsx_runtime25 = require(\"react/jsx-runtime\");\nfunction SizeSmallIcon(props) {\n  return /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(\"svg\", { width: 24, height: 24, viewBox: \"-2 -2 28 28\", fill: \"currentColor\", xmlns: \"http://www.w3.org/2000/svg\", ...props, children: /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(\"path\", { d: \"M12.4239 4.62C13.3572 4.62 14.1572 4.73333 14.8239 4.96C15.4906 5.17333 15.9772 5.43333 16.2839 5.74C16.3639 5.82 16.4039 5.94 16.4039 6.1V8.86H14.0639C13.9172 8.86 13.8439 8.78666 13.8439 8.64V7.26C13.4306 7.12666 12.9572 7.06 12.4239 7.06C11.6506 7.06 11.0639 7.18 10.6639 7.42C10.2639 7.66 10.0639 8.04666 10.0639 8.58V9C10.0639 9.38666 10.1639 9.69333 10.3639 9.92C10.5772 10.1333 11.0306 10.3467 11.7239 10.56L13.6439 11.14C14.4706 11.38 15.1172 11.66 15.5839 11.98C16.0506 12.3 16.3772 12.68 16.5639 13.12C16.7639 13.5467 16.8639 14.0733 16.8639 14.7V15.62C16.8639 16.7933 16.4039 17.7133 15.4839 18.38C14.5639 19.0467 13.2839 19.38 11.6439 19.38C10.6706 19.38 9.79723 19.2867 9.0239 19.1C8.2639 18.9133 7.71056 18.6533 7.3639 18.32C7.3239 18.28 7.29056 18.24 7.2639 18.2C7.25056 18.1467 7.2439 18.06 7.2439 17.94V15.74H7.6239C8.2239 16.1533 8.85056 16.4533 9.5039 16.64C10.1572 16.8267 10.9306 16.92 11.8239 16.92C12.6506 16.92 13.2506 16.7867 13.6239 16.52C14.0106 16.2533 14.2039 15.9333 14.2039 15.56V14.88C14.2039 14.6667 14.1639 14.48 14.0839 14.32C14.0172 14.16 13.8706 14.0133 13.6439 13.88C13.4172 13.7467 13.0572 13.6067 12.5639 13.46L10.6639 12.88C9.7839 12.6133 9.11056 12.3 8.6439 11.94C8.17723 11.58 7.85056 11.18 7.6639 10.74C7.49056 10.3 7.4039 9.83333 7.4039 9.34V8.38C7.4039 7.64666 7.61056 7 8.0239 6.44C8.43723 5.88 9.01723 5.44 9.7639 5.12C10.5239 4.78666 11.4106 4.62 12.4239 4.62Z\" }) });\n}\n\n// src/components/Tldraw/components/Primitives/icons/SizeMediumIcon.tsx\nvar import_jsx_runtime26 = require(\"react/jsx-runtime\");\nfunction SizeMediumIcon(props) {\n  return /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(\"svg\", { width: 24, height: 24, viewBox: \"-2 -2 28 28\", fill: \"currentColor\", xmlns: \"http://www.w3.org/2000/svg\", ...props, children: /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(\"path\", { d: \"M8.16191 19H5.68191C5.53525 19 5.46191 18.9267 5.46191 18.78V5H8.76191C8.88191 5 8.97525 5.03333 9.04191 5.1C9.10858 5.15333 9.17525 5.27333 9.24191 5.46C9.72191 6.59333 10.1686 7.7 10.5819 8.78C11.0086 9.84667 11.4352 10.98 11.8619 12.18H12.1619C12.6019 10.9667 13.0352 9.79333 13.4619 8.66C13.8886 7.52667 14.3552 6.30667 14.8619 5H18.3219C18.4686 5 18.5419 5.07333 18.5419 5.22V19H16.0619C15.9152 19 15.8419 18.9267 15.8419 18.78V16.26C15.8419 15.5267 15.8486 14.8133 15.8619 14.12C15.8886 13.4267 15.9286 12.6867 15.9819 11.9C16.0486 11.1 16.1419 10.1933 16.2619 9.18H15.9019C15.4352 10.3533 14.9486 11.5667 14.4419 12.82C13.9486 14.06 13.4819 15.2333 13.0419 16.34H11.1019C11.0619 16.34 11.0152 16.3333 10.9619 16.32C10.9219 16.2933 10.8886 16.2467 10.8619 16.18C10.4619 15.18 10.0086 14.06 9.50191 12.82C9.00858 11.58 8.53525 10.3667 8.08191 9.18H7.70191C7.83525 10.18 7.93525 11.0733 8.00191 11.86C8.06858 12.6467 8.10858 13.3933 8.12191 14.1C8.14858 14.8067 8.16191 15.5267 8.16191 16.26V19Z\" }) });\n}\n\n// src/components/Tldraw/components/Primitives/icons/SizeLargeIcon.tsx\nvar import_jsx_runtime27 = require(\"react/jsx-runtime\");\nfunction SizeLargeIcon(props) {\n  return /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(\"svg\", { width: 24, height: 24, viewBox: \"-2 -2 28 28\", fill: \"currentColor\", xmlns: \"http://www.w3.org/2000/svg\", ...props, children: /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(\"path\", { d: \"M7.68191 19C7.53525 19 7.46191 18.9267 7.46191 18.78V5H10.1219C10.2686 5 10.3419 5.07333 10.3419 5.22V16.56H13.4419V15.02H15.7619C15.9086 15.02 15.9819 15.0933 15.9819 15.24V19H7.68191Z\" }) });\n}\n\n// src/components/Tldraw/components/Primitives/icons/EraserIcon.tsx\nvar import_jsx_runtime28 = require(\"react/jsx-runtime\");\nfunction EraserIcon() {\n  return /* @__PURE__ */ (0, import_jsx_runtime28.jsxs)(\"svg\", { width: \"15\", height: \"15\", viewBox: \"0 0 15 15\", fill: \"none\", xmlns: \"http://www.w3.org/2000/svg\", children: [\n    /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(\n      \"path\",\n      {\n        d: \"M1.72838 9.33987L8.84935 2.34732C9.23874 1.96494 9.86279 1.96539 10.2516 2.34831L13.5636 5.60975C13.9655 6.00555 13.9607 6.65526 13.553 7.04507L8.13212 12.2278C7.94604 12.4057 7.69851 12.505 7.44107 12.505L6.06722 12.505L3.83772 12.505C3.5673 12.505 3.30842 12.3954 3.12009 12.2014L1.7114 10.7498C1.32837 10.3551 1.33596 9.72521 1.72838 9.33987Z\",\n        stroke: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(\"line\", { x1: \"6.01807\", y1: \"12.5\", x2: \"10.7959\", y2: \"12.5\", stroke: \"currentColor\", strokeLinecap: \"round\" }),\n    /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(\"line\", { x1: \"5.50834\", y1: \"5.74606\", x2: \"10.1984\", y2: \"10.4361\", stroke: \"currentColor\" })\n  ] });\n}\n\n// src/components/Tldraw/components/Primitives/icons/DiscordIcon.tsx\nvar import_jsx_runtime29 = require(\"react/jsx-runtime\");\n\n// src/components/Tldraw/components/Primitives/icons/LineIcon.tsx\nvar import_jsx_runtime30 = require(\"react/jsx-runtime\");\nfunction LineIcon() {\n  return /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(\"svg\", { width: \"15\", height: \"15\", viewBox: \"0 0 15 15\", fill: \"currentColor\", xmlns: \"http://www.w3.org/2000/svg\", children: /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(\"path\", { d: \"M3.64645 11.3536C3.45118 11.1583 3.45118 10.8417 3.64645 10.6465L11.1464 3.14645C11.3417 2.95118 11.6583 2.95118 11.8536 3.14645C12.0488 3.34171 12.0488 3.65829 11.8536 3.85355L4.35355 11.3536C4.15829 11.5488 3.84171 11.5488 3.64645 11.3536Z\" }) });\n}\n\n// src/components/Tldraw/components/ToolsPanel/DeleteButton.tsx\nvar import_jsx_runtime31 = require(\"react/jsx-runtime\");\nfunction DeleteButton() {\n  const app = useTldrawApp();\n  const intl = useIntl();\n  const handleDelete = React19.useCallback(() => {\n    app.delete();\n  }, [app]);\n  const hasSelection = app.useStore((s5) => s5.appState.status === \"idle\" && s5.document.pageStates[s5.appState.currentPageId].selectedIds.length > 0);\n  return /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(Tooltip, { label: intl.formatMessage({ id: \"delete\" }), kbd: \"\\u232B\", id: \"TD-Delete\", children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(ToolButton, { variant: \"circle\", disabled: !hasSelection, onSelect: handleDelete, children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(TrashIcon, {}) }) });\n}\n\n// src/components/Tldraw/components/ToolsPanel/PrimaryTools.tsx\nvar React21 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/components/Primitives/Panel/Panel.tsx\nvar Panel = styled(\"div\", {\n  backgroundColor: \"$panel\",\n  display: \"flex\",\n  flexDirection: \"row\",\n  boxShadow: \"$panel\",\n  padding: \"$2\",\n  border: \"1px solid $panelContrast\",\n  gap: 0,\n  overflow: \"hidden\",\n  variants: {\n    side: {\n      center: {\n        borderRadius: 9\n      },\n      left: {\n        padding: 0,\n        borderTop: 0,\n        borderLeft: 0,\n        borderTopRightRadius: 0,\n        borderBottomRightRadius: 9,\n        borderBottomLeftRadius: 0\n      },\n      right: {\n        padding: 0,\n        borderTop: 0,\n        borderRight: 0,\n        borderTopLeftRadius: 0,\n        borderBottomLeftRadius: 9,\n        borderBottomRightRadius: 0\n      }\n    }\n  },\n  \"& hr\": {\n    height: 10,\n    width: \"100%\",\n    backgroundColor: \"red\",\n    border: \"none\"\n  }\n});\n\n// src/components/Tldraw/components/ToolsPanel/ShapesMenu.tsx\nvar React20 = __toESM(require(\"react\"));\nvar import_jsx_runtime32 = require(\"react/jsx-runtime\");\nvar shapeShapes = [\"rectangle\" /* Rectangle */, \"ellipse\" /* Ellipse */, \"triangle\" /* Triangle */, \"line\" /* Line */];\nvar shapeShapeIcons = {\n  [\"rectangle\" /* Rectangle */]: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(SquareIcon, {}),\n  [\"ellipse\" /* Ellipse */]: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(CircleIcon, {}),\n  [\"triangle\" /* Triangle */]: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(VercelLogoIcon, {}),\n  [\"line\" /* Line */]: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(LineIcon, {})\n};\nvar dockPositionState3 = (s5) => s5.settings.dockPosition;\nvar ShapesMenu = React20.memo(function ShapesMenu2({ activeTool, isToolLocked }) {\n  const app = useTldrawApp();\n  const intl = useIntl();\n  const dockPosition = app.useStore(dockPositionState3);\n  const [lastActiveTool, setLastActiveTool] = React20.useState(\"rectangle\" /* Rectangle */);\n  React20.useEffect(() => {\n    if (shapeShapes.includes(activeTool) && lastActiveTool !== activeTool) {\n      setLastActiveTool(activeTool);\n    }\n  }, [activeTool]);\n  const selectShapeTool = React20.useCallback(() => {\n    app.selectTool(lastActiveTool);\n  }, [activeTool, app]);\n  const handleDoubleClick = React20.useCallback(() => {\n    app.toggleToolLock();\n  }, [app]);\n  const handleKeyDown = React20.useCallback((e5) => {\n    if (e5.key === \" \" && app.shiftKey) {\n      e5.preventDefault();\n    }\n  }, []);\n  const isActive = shapeShapes.includes(activeTool);\n  const contentSide = dockPosition === \"bottom\" || dockPosition === \"top\" ? \"top\" : dockPosition;\n  const panelStyle = dockPosition === \"bottom\" || dockPosition === \"top\" ? \"row\" : \"column\";\n  return /* @__PURE__ */ (0, import_jsx_runtime32.jsxs)($d08ef79370b62062$export$be92b6f5f03c0fe9, { dir: \"ltr\", onOpenChange: selectShapeTool, children: [\n    /* @__PURE__ */ (0, import_jsx_runtime32.jsx)($d08ef79370b62062$export$41fb9f06171c75f4, { dir: \"ltr\", asChild: true, id: \"TD-PrimaryTools-Shapes\", children: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(\n      ToolButton,\n      {\n        disabled: isActive && app.shiftKey,\n        variant: \"primary\",\n        onDoubleClick: handleDoubleClick,\n        isToolLocked: isActive && isToolLocked,\n        isActive,\n        onKeyDown: handleKeyDown,\n        children: shapeShapeIcons[lastActiveTool]\n      }\n    ) }),\n    /* @__PURE__ */ (0, import_jsx_runtime32.jsx)($d08ef79370b62062$export$7c6e2c02157bb7d2, { asChild: true, side: contentSide, sideOffset: 12, children: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(Panel, { side: \"center\", style: { flexDirection: panelStyle }, children: shapeShapes.map((shape, index2) => /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(Tooltip, { label: intl.formatMessage({ id: shape }), kbd: (4 + index2).toString(), id: `TD-PrimaryTools-Shapes-${shape}`, children: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)($d08ef79370b62062$export$6d08773d2e66f8f2, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(\n      ToolButton,\n      {\n        variant: \"primary\",\n        onClick: () => {\n          app.selectTool(shape);\n          setLastActiveTool(shape);\n        },\n        children: shapeShapeIcons[shape]\n      }\n    ) }) }, shape)) }) })\n  ] });\n});\n\n// src/components/Tldraw/components/ToolsPanel/PrimaryTools.tsx\nvar import_jsx_runtime33 = require(\"react/jsx-runtime\");\nvar activeToolSelector = (s5) => s5.appState.activeTool;\nvar toolLockedSelector = (s5) => s5.appState.isToolLocked;\nvar dockPositionState4 = (s5) => s5.settings.dockPosition;\nvar PrimaryTools = React21.memo(function PrimaryTools2() {\n  const app = useTldrawApp();\n  const intl = useIntl();\n  const activeTool = app.useStore(activeToolSelector);\n  const isToolLocked = app.useStore(toolLockedSelector);\n  const dockPosition = app.useStore(dockPositionState4);\n  const selectSelectTool = React21.useCallback(() => {\n    app.selectTool(\"select\");\n  }, [app]);\n  const selectEraseTool = React21.useCallback(() => {\n    app.selectTool(\"erase\");\n  }, [app]);\n  const selectDrawTool = React21.useCallback(() => {\n    app.selectTool(\"draw\" /* Draw */);\n  }, [app]);\n  const selectArrowTool = React21.useCallback(() => {\n    app.selectTool(\"arrow\" /* Arrow */);\n  }, [app]);\n  const selectTextTool = React21.useCallback(() => {\n    app.selectTool(\"text\" /* Text */);\n  }, [app]);\n  const selectStickyTool = React21.useCallback(() => {\n    app.selectTool(\"sticky\" /* Sticky */);\n  }, [app]);\n  const uploadMedias = React21.useCallback(async () => {\n    app.openAsset();\n  }, [app]);\n  const panelStyle = dockPosition === \"bottom\" || dockPosition === \"top\" ? \"row\" : \"column\";\n  return /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)(StyledPanel, { side: \"center\", id: \"TD-PrimaryTools\", style: { flexDirection: panelStyle }, bp: breakpoints, children: [\n    /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(\n      ToolButtonWithTooltip,\n      {\n        kbd: \"1\",\n        label: intl.formatMessage({ id: \"select\" }),\n        onClick: selectSelectTool,\n        isActive: activeTool === \"select\",\n        id: \"TD-PrimaryTools-CursorArrow\",\n        children: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(CursorArrowIcon, {})\n      }\n    ),\n    /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(\n      ToolButtonWithTooltip,\n      {\n        kbd: \"2\",\n        label: intl.formatMessage({ id: \"draw\" }),\n        onClick: selectDrawTool,\n        isActive: activeTool === \"draw\" /* Draw */,\n        id: \"TD-PrimaryTools-Pencil\",\n        children: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(Pencil1Icon, {})\n      }\n    ),\n    /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(\n      ToolButtonWithTooltip,\n      {\n        kbd: \"3\",\n        label: intl.formatMessage({ id: \"eraser\" }),\n        onClick: selectEraseTool,\n        isActive: activeTool === \"erase\",\n        id: \"TD-PrimaryTools-Eraser\",\n        children: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(EraserIcon, {})\n      }\n    ),\n    /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(ShapesMenu, { activeTool, isToolLocked }),\n    /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(\n      ToolButtonWithTooltip,\n      {\n        kbd: \"8\",\n        label: intl.formatMessage({ id: \"arrow\" }),\n        onClick: selectArrowTool,\n        isLocked: isToolLocked,\n        isActive: activeTool === \"arrow\" /* Arrow */,\n        id: \"TD-PrimaryTools-ArrowTopRight\",\n        children: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(ArrowTopRightIcon, {})\n      }\n    ),\n    /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(\n      ToolButtonWithTooltip,\n      {\n        kbd: \"9\",\n        label: intl.formatMessage({ id: \"text\" }),\n        onClick: selectTextTool,\n        isLocked: isToolLocked,\n        isActive: activeTool === \"text\" /* Text */,\n        id: \"TD-PrimaryTools-Text\",\n        children: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(TextIcon, {})\n      }\n    ),\n    /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(\n      ToolButtonWithTooltip,\n      {\n        kbd: \"0\",\n        label: intl.formatMessage({ id: \"sticky\" }),\n        onClick: selectStickyTool,\n        isActive: activeTool === \"sticky\" /* Sticky */,\n        id: \"TD-PrimaryTools-Pencil2\",\n        children: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(Pencil2Icon, {})\n      }\n    ),\n    /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(ToolButtonWithTooltip, { label: intl.formatMessage({ id: \"image\" }), onClick: uploadMedias, id: \"TD-PrimaryTools-Image\", children: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(ImageIcon, {}) })\n  ] });\n});\nvar StyledPanel = styled(Panel, {\n  variants: {\n    bp: {\n      mobile: {\n        padding: \"$0\",\n        borderRadius: \"10px\"\n      },\n      small: {\n        padding: \"$2\"\n      }\n    }\n  }\n});\n\n// src/components/Tldraw/components/ToolsPanel/StatusBar.tsx\nvar import_jsx_runtime34 = require(\"react/jsx-runtime\");\nvar statusSelector = (s5) => s5.appState.status;\nvar activeToolSelector2 = (s5) => s5.appState.activeTool;\nfunction StatusBar() {\n  const app = useTldrawApp();\n  const status = app.useStore(statusSelector);\n  const activeTool = app.useStore(activeToolSelector2);\n  return /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(StyledStatusBar, { bp: breakpoints, id: \"TD-StatusBar\", children: /* @__PURE__ */ (0, import_jsx_runtime34.jsxs)(StyledSection, { children: [\n    activeTool,\n    \" | \",\n    status\n  ] }) });\n}\nvar StyledStatusBar = styled(\"div\", {\n  height: 40,\n  userSelect: \"none\",\n  borderTop: \"1px solid $panelContrast\",\n  gridArea: \"status\",\n  display: \"flex\",\n  color: \"$text\",\n  justifyContent: \"space-between\",\n  alignItems: \"center\",\n  backgroundColor: \"$panel\",\n  gap: 8,\n  fontFamily: \"$ui\",\n  fontSize: \"$0\",\n  padding: \"0 16px\",\n  variants: {\n    bp: {\n      small: {\n        fontSize: \"$1\"\n      }\n    }\n  }\n});\nvar StyledSection = styled(\"div\", {\n  whiteSpace: \"nowrap\",\n  overflow: \"hidden\"\n});\n\n// src/components/Tldraw/components/ToolsPanel/ToolsPanel.tsx\nvar import_jsx_runtime35 = require(\"react/jsx-runtime\");\nvar isDebugModeSelector3 = (s5) => s5.settings.isDebugMode;\nvar dockPositionState5 = (s5) => s5.settings.dockPosition;\nvar ToolsPanel = React22.memo(function ToolsPanel2({ onBlur }) {\n  const app = useTldrawApp();\n  const side = app.useStore(dockPositionState5);\n  const isDebugMode = app.useStore(isDebugModeSelector3);\n  return /* @__PURE__ */ (0, import_jsx_runtime35.jsxs)(import_jsx_runtime35.Fragment, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(StyledToolsPanelContainer, { side, onBlur, bp: breakpoints, debug: isDebugMode, children: /* @__PURE__ */ (0, import_jsx_runtime35.jsxs)(StyledCenterWrap, { id: \"TD-Tools\", children: [\n      /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(BackToContent, {}),\n      /* @__PURE__ */ (0, import_jsx_runtime35.jsxs)(StyledPrimaryTools, { orientation: side === \"bottom\" || side === \"top\" ? \"horizontal\" : \"vertical\", children: [\n        /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(ActionButton, {}),\n        /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(PrimaryTools, {}),\n        /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(DeleteButton, {})\n      ] })\n    ] }) }),\n    isDebugMode && /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(StyledStatusWrap, { children: /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(StatusBar, {}) })\n  ] });\n});\nvar StyledToolsPanelContainer = styled(\"div\", {\n  position: \"absolute\",\n  width: \"100%\",\n  minWidth: 0,\n  maxWidth: \"100%\",\n  height: 64,\n  gap: \"$4\",\n  display: \"flex\",\n  justifyContent: \"center\",\n  alignItems: \"center\",\n  zIndex: 200,\n  overflow: \"hidden\",\n  pointerEvents: \"none\",\n  \"& > div > *\": {\n    pointerEvents: \"all\"\n  },\n  variants: {\n    debug: {\n      true: {},\n      false: {}\n    },\n    bp: {\n      mobile: {},\n      small: {},\n      medium: {},\n      large: {}\n    },\n    side: {\n      top: {\n        width: \"100%\",\n        height: 64,\n        left: 0,\n        right: 0,\n        top: 45\n      },\n      right: { width: 64, height: \"100%\", top: 0, right: 0 },\n      bottom: {\n        width: \"100%\",\n        left: 0,\n        right: 0,\n        bottom: 4\n      },\n      left: { width: 64, height: \"100%\", left: 0 }\n    }\n  },\n  compoundVariants: [\n    {\n      side: \"top\",\n      bp: \"large\",\n      css: {\n        top: 0\n      }\n    },\n    {\n      side: \"bottom\",\n      debug: true,\n      css: {\n        bottom: 44\n      }\n    }\n  ]\n});\nvar StyledCenterWrap = styled(\"div\", {\n  display: \"flex\",\n  width: \"fit-content\",\n  height: \"fit-content\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  flexDirection: \"column\",\n  gap: \"$4\"\n});\nvar StyledStatusWrap = styled(\"div\", {\n  position: \"absolute\",\n  bottom: \"0px\",\n  left: \"0px\",\n  right: \"0px\",\n  height: \"40px\",\n  width: \"100%\",\n  maxWidth: \"100%\"\n});\nvar StyledPrimaryTools = styled(\"div\", {\n  position: \"relative\",\n  display: \"flex\",\n  alignItems: \"center\",\n  height: \"fit-content\",\n  gap: \"$3\",\n  variants: {\n    orientation: {\n      horizontal: {\n        flexDirection: \"row\"\n      },\n      vertical: {\n        flexDirection: \"column\"\n      }\n    }\n  }\n});\n\n// src/components/Tldraw/components/TopPanel/TopPanel.tsx\nvar React47 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/components/TopPanel/Menu/Menu.tsx\nvar React24 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/components/TopPanel/PreferencesMenu/PreferencesMenu.tsx\nvar React23 = __toESM(require(\"react\"));\nvar import_jsx_runtime36 = require(\"react/jsx-runtime\");\nvar settingsSelector = (s5) => s5.settings;\nvar DockPosition = [\"bottom\", \"left\", \"right\", \"top\"];\nfunction PreferencesMenu() {\n  const app = useTldrawApp();\n  const intl = useIntl();\n  const settings = app.useStore(settingsSelector);\n  const toggleDebugMode = React23.useCallback(() => {\n    app.setSetting(\"isDebugMode\", (v6) => !v6);\n  }, [app]);\n  const toggleFocusMode = React23.useCallback(() => {\n    app.setSetting(\"isFocusMode\", (v6) => !v6);\n  }, [app]);\n  const toggleGrid = React23.useCallback(() => {\n    app.setSetting(\"showGrid\", (v6) => !v6);\n  }, [app]);\n  const toggleKeepStyleMenuOpen = React23.useCallback(() => {\n    app.setSetting(\"keepStyleMenuOpen\", (v6) => !v6);\n  }, [app]);\n  const toggleCadSelectMode = React23.useCallback(() => {\n    app.setSetting(\"isCadSelectMode\", (v6) => !v6);\n  }, [app]);\n  const handleChangeDockPosition = React23.useCallback(\n    (position) => {\n      app.setSetting(\"dockPosition\", position);\n    },\n    [app]\n  );\n  const selectExportBackground = React23.useCallback(\n    (background) => {\n      app.setSetting(\"exportBackground\", background);\n    },\n    [app]\n  );\n  return /* @__PURE__ */ (0, import_jsx_runtime36.jsxs)(DMSubMenu, { label: intl.formatMessage({ id: \"menu.preferences\" }), id: \"TD-MenuItem-Preferences\", children: [\n    /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(DMCheckboxItem, { checked: settings.isFocusMode, onCheckedChange: toggleFocusMode, kbd: \"#.\", id: \"TD-MenuItem-Preferences-Focus_Mode\", children: /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(FormattedMessage, { id: \"preferences.focus.mode\" }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(DMCheckboxItem, { checked: settings.isDebugMode, onCheckedChange: toggleDebugMode, id: \"TD-MenuItem-Preferences-Debug_Mode\", children: /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(FormattedMessage, { id: \"preferences.debug.mode\" }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(Divider, {}),\n    /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(DMCheckboxItem, { checked: settings.showGrid, onCheckedChange: toggleGrid, kbd: \"#\\u21E7G\", id: \"TD-MenuItem-Preferences-Grid\", children: /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(FormattedMessage, { id: \"preferences.show.grid\" }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(DMCheckboxItem, { checked: settings.isCadSelectMode, onCheckedChange: toggleCadSelectMode, id: \"TD-MenuItem-Preferences-Cad_Selection\", children: /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(FormattedMessage, { id: \"preferences.use.cad.selection\" }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(DMCheckboxItem, { checked: settings.keepStyleMenuOpen, onCheckedChange: toggleKeepStyleMenuOpen, id: \"TD-MenuItem-Preferences-Style_menu\", children: /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(FormattedMessage, { id: \"preferences.keep.stylemenu.open\" }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(DMSubMenu, { label: intl.formatMessage({ id: \"dock.position\" }), children: DockPosition.map((position) => /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(\n      DMCheckboxItem,\n      {\n        checked: settings.dockPosition === position,\n        onCheckedChange: () => handleChangeDockPosition(position),\n        id: `TD-MenuItem-DockPosition-${position}`,\n        children: /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(StyledText, { children: /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(FormattedMessage, { id: position }) })\n      },\n      position\n    )) }),\n    /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(DMSubMenu, { label: intl.formatMessage({ id: \"export.background\" }), children: Object.values(TDExportBackground).map((exportBackground) => /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(\n      DMCheckboxItem,\n      {\n        checked: settings.exportBackground === exportBackground,\n        onCheckedChange: () => selectExportBackground(exportBackground),\n        id: `TD-MenuItem-ExportBackground-${exportBackground}`,\n        children: /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(StyledText, { children: /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(FormattedMessage, { id: exportBackground }) })\n      },\n      exportBackground\n    )) })\n  ] });\n}\nvar StyledText = styled(\"span\", {\n  textTransform: \"capitalize\"\n});\n\n// src/components/Tldraw/components/TopPanel/Menu/Menu.tsx\nvar import_jsx_runtime37 = require(\"react/jsx-runtime\");\nvar numberOfSelectedIdsSelector2 = (s5) => {\n  return s5.document.pageStates[s5.appState.currentPageId].selectedIds.length;\n};\nvar disableAssetsSelector = (s5) => {\n  return s5.appState.disableAssets;\n};\nvar Menu = React24.memo(function Menu2({ readOnly }) {\n  const app = useTldrawApp();\n  const intl = useIntl();\n  const [openDialog, setOpenDialog] = React24.useState(false);\n  const numberOfSelectedIds = app.useStore(numberOfSelectedIdsSelector2);\n  const disableAssets = app.useStore(disableAssetsSelector);\n  const [_3, setForce] = React24.useState(0);\n  React24.useEffect(() => setForce(1), []);\n  const handleDelete = React24.useCallback(() => {\n    app.delete();\n  }, [app]);\n  const handleCopySVG = React24.useCallback(() => {\n    app.copyImage(\"svg\" /* SVG */, { scale: 1, quality: 1, transparentBackground: false });\n  }, [app]);\n  const handleCopyPNG = React24.useCallback(() => {\n    app.copyImage(\"png\" /* PNG */, { scale: 2, quality: 1, transparentBackground: true });\n  }, [app]);\n  const handleExportPNG = React24.useCallback(async () => {\n    app.exportImage(\"png\" /* PNG */, { scale: 2, quality: 1 });\n  }, [app]);\n  const handleExportJPG = React24.useCallback(async () => {\n    app.exportImage(\"jpeg\" /* JPG */, { scale: 2, quality: 1 });\n  }, [app]);\n  const handleExportWEBP = React24.useCallback(async () => {\n    app.exportImage(\"webp\" /* WEBP */, { scale: 2, quality: 1 });\n  }, [app]);\n  const handleExportSVG = React24.useCallback(async () => {\n    app.exportImage(\"svg\" /* SVG */, { scale: 2, quality: 1 });\n  }, [app]);\n  const handleCopyJSON = React24.useCallback(async () => {\n    app.copyJson();\n  }, [app]);\n  const handleExportJSON = React24.useCallback(async () => {\n    app.exportJson();\n  }, [app]);\n  const handleCut = React24.useCallback(() => {\n    app.cut();\n  }, [app]);\n  const handleCopy = React24.useCallback(() => {\n    app.copy();\n  }, [app]);\n  const handlePaste = React24.useCallback(() => {\n    app.paste();\n  }, [app]);\n  const handleSelectAll = React24.useCallback(() => {\n    app.selectAll();\n  }, [app]);\n  const handleSelectNone = React24.useCallback(() => {\n    app.selectNone();\n  }, [app]);\n  const handleUploadMedia = React24.useCallback(() => {\n    app.openAsset();\n  }, [app]);\n  const handleZoomTo100 = React24.useCallback(() => {\n    app.zoomTo(1);\n  }, [app]);\n  const showFileMenu = app.callbacks.onExport;\n  const hasSelection = numberOfSelectedIds > 0;\n  return /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(import_jsx_runtime37.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)($d08ef79370b62062$export$be92b6f5f03c0fe9, { dir: \"ltr\", children: [\n    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMTriggerIcon, { id: \"TD-MenuIcon\", children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(HamburgerMenuIcon, {}) }),\n    /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(DMContent, { variant: \"menu\", id: \"TD-Menu\", side: \"bottom\", align: \"start\", sideOffset: 4, alignOffset: 4, children: [\n      showFileMenu != void 0 && /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMSubMenu, { label: `${intl.formatMessage({ id: \"menu.file\" })}...`, id: \"TD-MenuItem-File\", children: !disableAssets && /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(import_jsx_runtime37.Fragment, { children: [\n        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Divider, {}),\n        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMItem, { onClick: handleUploadMedia, kbd: \"#U\", id: \"TD-MenuItem-File-Upload_Media\", children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(FormattedMessage, { id: \"upload.media\" }) })\n      ] }) }),\n      /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(DMSubMenu, { label: `${intl.formatMessage({ id: \"menu.edit\" })}...`, id: \"TD-MenuItem-Edit\", children: [\n        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMItem, { onSelect: preventEvent, onClick: app.undo, disabled: readOnly, kbd: \"#Z\", id: \"TD-MenuItem-Edit-Undo\", children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(FormattedMessage, { id: \"undo\" }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMItem, { onSelect: preventEvent, onClick: app.redo, disabled: readOnly, kbd: \"#\\u21E7Z\", id: \"TD-MenuItem-Edit-Redo\", children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(FormattedMessage, { id: \"redo\" }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Divider, {}),\n        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMItem, { onSelect: preventEvent, disabled: !hasSelection || readOnly, onClick: handleCut, kbd: \"#X\", id: \"TD-MenuItem-Edit-Cut\", children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(FormattedMessage, { id: \"cut\" }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMItem, { onSelect: preventEvent, disabled: !hasSelection, onClick: handleCopy, kbd: \"#C\", id: \"TD-MenuItem-Edit-Copy\", children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(FormattedMessage, { id: \"copy\" }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMItem, { onSelect: preventEvent, onClick: handlePaste, kbd: \"#V\", id: \"TD-MenuItem-Edit-Paste\", children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(FormattedMessage, { id: \"paste\" }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Divider, {}),\n        /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(DMSubMenu, { label: `${intl.formatMessage({ id: \"copy.as\" })}...`, size: \"small\", id: \"TD-MenuItem-Copy-As\", children: [\n          /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMItem, { onClick: handleCopySVG, id: \"TD-MenuItem-Copy-as-SVG\", children: \"SVG\" }),\n          /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMItem, { onClick: handleCopyPNG, id: \"TD-MenuItem-Copy-As-PNG\", children: \"PNG\" }),\n          /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMItem, { onClick: handleCopyJSON, id: \"TD-MenuItem-Copy_as_JSON\", children: \"JSON\" })\n        ] }),\n        /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(DMSubMenu, { label: `${intl.formatMessage({ id: \"export.as\" })}...`, size: \"small\", id: \"TD-MenuItem-Export\", children: [\n          /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMItem, { onClick: handleExportSVG, id: \"TD-MenuItem-Export-SVG\", children: \"SVG\" }),\n          /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMItem, { onClick: handleExportPNG, id: \"TD-MenuItem-Export-PNG\", children: \"PNG\" }),\n          /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMItem, { onClick: handleExportJPG, id: \"TD-MenuItem-Export-JPG\", children: \"JPG\" }),\n          /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMItem, { onClick: handleExportWEBP, id: \"TD-MenuItem-Export-WEBP\", children: \"WEBP\" }),\n          /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMItem, { onClick: handleExportJSON, id: \"TD-MenuItem-Export-JSON\", children: \"JSON\" })\n        ] }),\n        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Divider, {}),\n        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMItem, { onSelect: preventEvent, onClick: handleSelectAll, kbd: \"#A\", id: \"TD-MenuItem-Select_All\", children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(FormattedMessage, { id: \"select.all\" }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMItem, { onSelect: preventEvent, disabled: !hasSelection, onClick: handleSelectNone, id: \"TD-MenuItem-Select_None\", children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(FormattedMessage, { id: \"select.none\" }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Divider, {}),\n        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMItem, { onSelect: handleDelete, disabled: !hasSelection, kbd: \"\\u232B\", id: \"TD-MenuItem-Delete\", children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(FormattedMessage, { id: \"delete\" }) })\n      ] }),\n      /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(DMSubMenu, { label: intl.formatMessage({ id: \"menu.view\" }), id: \"TD-MenuItem-Edit\", children: [\n        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMItem, { onSelect: preventEvent, onClick: app.zoomIn, kbd: \"#+\", id: \"TD-MenuItem-View-ZoomIn\", children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(FormattedMessage, { id: \"zoom.in\" }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMItem, { onSelect: preventEvent, onClick: app.zoomOut, kbd: \"#-\", id: \"TD-MenuItem-View-ZoomOut\", children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(FormattedMessage, { id: \"zoom.out\" }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(DMItem, { onSelect: preventEvent, onClick: handleZoomTo100, kbd: \"\\u21E7+0\", id: \"TD-MenuItem-View-ZoomTo100\", children: [\n          /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(FormattedMessage, { id: \"zoom.to\" }),\n          \" 100%\"\n        ] }),\n        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMItem, { onSelect: preventEvent, onClick: app.zoomToFit, kbd: \"\\u21E7+1\", id: \"TD-MenuItem-View-ZoomToFit\", children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(FormattedMessage, { id: \"zoom.to.fit\" }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMItem, { onSelect: preventEvent, onClick: app.zoomToSelection, kbd: \"\\u21E7+2\", id: \"TD-MenuItem-View-ZoomToSelection\", children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(FormattedMessage, { id: \"zoom.to.selection\" }) })\n      ] }),\n      /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Divider, {}),\n      /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(PreferencesMenu, {})\n    ] })\n  ] }) });\n});\n\n// src/components/Tldraw/components/TopPanel/PageMenu/PageMenu.tsx\nvar React27 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/components/TopPanel/PageOptionsDialog/PageOptionsDialog.tsx\nvar React26 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/components/Primitives/TextField/TextField.tsx\nvar React25 = __toESM(require(\"react\"));\nvar import_jsx_runtime38 = require(\"react/jsx-runtime\");\nvar TextField = React25.forwardRef(({ icon, ...rest }, reference) => {\n  return /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(StyledInputWrapper, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(StyledInput, { ...rest, ref: reference }),\n    icon == void 0 ? null : /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(StyledInputIcon, { children: icon })\n  ] });\n});\nvar StyledInputWrapper = styled(\"div\", {\n  position: \"relative\",\n  width: \"100%\",\n  height: \"min-content\"\n});\nvar StyledInput = styled(\"input\", {\n  color: \"$text\",\n  border: \"none\",\n  textAlign: \"left\",\n  width: \"100%\",\n  paddingLeft: \"$3\",\n  paddingRight: \"$6\",\n  backgroundColor: \"$background\",\n  height: \"32px\",\n  outline: \"none\",\n  fontFamily: \"$ui\",\n  fontSize: \"$1\",\n  \"&:focus\": {\n    backgroundColor: \"$hover\"\n  },\n  borderRadius: \"$2\"\n});\nvar StyledInputIcon = styled(SmallIcon, {\n  top: 0,\n  right: 0,\n  position: \"absolute\",\n  paddingLeft: \"$3\",\n  paddingRight: \"$3\",\n  pointerEvents: \"none\",\n  color: \"$text\"\n});\n\n// src/components/Tldraw/components/TopPanel/PageOptionsDialog/PageOptionsDialog.tsx\nvar import_jsx_runtime39 = require(\"react/jsx-runtime\");\nvar canDeleteSelector = (s5) => {\n  return Object.keys(s5.document.pages).length > 1;\n};\nfunction PageOptionsDialog({ page, onOpen, onClose }) {\n  const app = useTldrawApp();\n  const intl = useIntl();\n  const [isOpen, setIsOpen] = React26.useState(false);\n  const [pageName, setPageName] = React26.useState(page.name || \"Page\");\n  const canDelete = app.useStore(canDeleteSelector);\n  const rInput = React26.useRef(null);\n  const handleClose = React26.useCallback(() => {\n    setIsOpen(false);\n  }, []);\n  const handleDuplicate = React26.useCallback(() => {\n    app.duplicatePage(page.id);\n  }, [app]);\n  const handleDelete = React26.useCallback(() => {\n    if (window.confirm(`Are you sure you want to delete this page?`)) {\n      app.deletePage(page.id);\n    }\n  }, [app]);\n  const handleOpenChange = React26.useCallback(\n    (isOpen2) => {\n      setIsOpen(isOpen2);\n      if (isOpen2) {\n        onOpen?.();\n      }\n    },\n    [app]\n  );\n  function stopPropagation2(e5) {\n    e5.stopPropagation();\n  }\n  const rInitialName = React26.useRef(page.name || \"Page\");\n  const rCurrentName = React26.useRef(rInitialName.current);\n  const handleTextFieldChange = React26.useCallback((event) => {\n    const value = event.target.value.trimStart();\n    rCurrentName.current = value;\n    setPageName(value);\n  }, []);\n  const handleTextFieldKeyDown = React26.useCallback((e5) => {\n    switch (e5.key) {\n      case \"Enter\": {\n        if (rCurrentName.current === rInitialName.current) {\n          setIsOpen(false);\n        } else {\n          rInitialName.current = rCurrentName.current;\n          app.renamePage(page.id, rCurrentName.current.trim());\n          setIsOpen(false);\n        }\n        break;\n      }\n      case \"Escape\": {\n        if (rCurrentName.current === rInitialName.current) {\n          setIsOpen(false);\n          return;\n        }\n        rCurrentName.current = rInitialName.current;\n        setPageName(rInitialName.current);\n        requestAnimationFrame(() => {\n          const elm = rInput.current;\n          if (elm != void 0) {\n            elm.focus();\n            elm.setSelectionRange(0, elm.value.length);\n          }\n        });\n        break;\n      }\n    }\n  }, []);\n  const rWasOpen = React26.useRef(false);\n  React26.useEffect(() => {\n    if (isOpen) {\n      rWasOpen.current = true;\n      rInitialName.current = page.name || \"Page\";\n      rCurrentName.current = rInitialName.current;\n      requestAnimationFrame(() => {\n        const elm = rInput.current;\n        if (elm != void 0) {\n          elm.focus();\n          elm.setSelectionRange(0, elm.value.length);\n        }\n      });\n    } else if (rWasOpen.current) {\n      onClose?.();\n    }\n    return () => {\n      if (rCurrentName.current !== rInitialName.current) {\n        rInitialName.current = rCurrentName.current;\n        app.renamePage(page.id, rCurrentName.current);\n      }\n    };\n  }, [isOpen]);\n  const container = useContainer();\n  return /* @__PURE__ */ (0, import_jsx_runtime39.jsxs)($905f4ae918aab1aa$export$be92b6f5f03c0fe9, { open: isOpen, onOpenChange: handleOpenChange, children: [\n    /* @__PURE__ */ (0, import_jsx_runtime39.jsx)($905f4ae918aab1aa$export$41fb9f06171c75f4, { asChild: true, \"data-shy\": \"true\", children: /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(IconButton, { bp: breakpoints, children: /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(SmallIcon, { children: /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(MixerVerticalIcon, {}) }) }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime39.jsxs)($905f4ae918aab1aa$export$602eac185826482c, { container: container.current, children: [\n      /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(StyledDialogOverlay2, { onPointerDown: handleClose }),\n      /* @__PURE__ */ (0, import_jsx_runtime39.jsxs)(StyledDialogContent, { dir: \"ltr\", onKeyDown: stopPropagation2, onKeyUp: stopPropagation2, children: [\n        /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(\n          TextField,\n          {\n            ref: rInput,\n            placeholder: intl.formatMessage({ id: \"page.name\" }),\n            value: pageName,\n            onChange: handleTextFieldChange,\n            onKeyDown: handleTextFieldKeyDown,\n            icon: /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(Pencil1Icon, {})\n          }\n        ),\n        /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(Divider, {}),\n        /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(DialogAction, { onSelect: handleDuplicate, children: /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(FormattedMessage, { id: \"duplicate\" }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(DialogAction, { disabled: !canDelete, onSelect: handleDelete, children: /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(FormattedMessage, { id: \"delete\" }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(Divider, {}),\n        /* @__PURE__ */ (0, import_jsx_runtime39.jsx)($905f4ae918aab1aa$export$848c9b7ead0df967, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(RowButton, { children: /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(FormattedMessage, { id: \"cancel\" }) }) })\n      ] })\n    ] })\n  ] });\n}\nvar StyledDialogContent = styled($905f4ae918aab1aa$export$7c6e2c02157bb7d2, {\n  position: \"absolute\",\n  top: \"50%\",\n  left: \"50%\",\n  transform: \"translate(-50%, -50%)\",\n  minWidth: 240,\n  maxWidth: \"fit-content\",\n  maxHeight: \"85vh\",\n  marginTop: \"-5vh\",\n  pointerEvents: \"all\",\n  backgroundColor: \"$panel\",\n  padding: \"$1\",\n  borderRadius: \"$2\",\n  font: \"$ui\",\n  zIndex: 999999,\n  \"&:focus\": {\n    outline: \"none\"\n  }\n});\nvar StyledDialogOverlay2 = styled($905f4ae918aab1aa$export$c6fdb837b070b4ff, {\n  backgroundColor: \"rgba(0, 0, 0, .15)\",\n  position: \"absolute\",\n  pointerEvents: \"all\",\n  inset: 0,\n  zIndex: 999998\n});\nfunction DialogAction({ onSelect, ...rest }) {\n  return /* @__PURE__ */ (0, import_jsx_runtime39.jsx)($905f4ae918aab1aa$export$e19cd5f9376f8cee, { asChild: true, onClick: onSelect, onSelect, children: /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(RowButton, { ...rest }) });\n}\n\n// src/components/Tldraw/components/TopPanel/PageMenu/PageMenu.tsx\nvar import_jsx_runtime40 = require(\"react/jsx-runtime\");\nvar sortedSelector = (s5) => Object.values(s5.document.pages).sort((a7, b6) => (a7.childIndex || 0) - (b6.childIndex || 0));\nvar currentPageNameSelector = (s5) => s5.document.pages[s5.appState.currentPageId].name;\nvar currentPageIdSelector2 = (s5) => s5.document.pages[s5.appState.currentPageId].id;\nfunction PageMenu() {\n  const app = useTldrawApp();\n  const intl = useIntl();\n  const rIsOpen = React27.useRef(false);\n  const [isOpen, setIsOpen] = React27.useState(false);\n  React27.useEffect(() => {\n    if (rIsOpen.current !== isOpen) {\n      rIsOpen.current = isOpen;\n    }\n  }, [isOpen]);\n  const handleClose = React27.useCallback(() => {\n    setIsOpen(false);\n  }, [setIsOpen]);\n  const handleOpenChange = React27.useCallback(\n    (isOpen2) => {\n      if (rIsOpen.current !== isOpen2) {\n        setIsOpen(isOpen2);\n      }\n    },\n    [setIsOpen]\n  );\n  const currentPageName = app.useStore(currentPageNameSelector);\n  return /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)($d08ef79370b62062$export$be92b6f5f03c0fe9, { dir: \"ltr\", open: isOpen, onOpenChange: handleOpenChange, children: [\n    /* @__PURE__ */ (0, import_jsx_runtime40.jsx)($d08ef79370b62062$export$41fb9f06171c75f4, { dir: \"ltr\", asChild: true, id: \"TD-Page\", children: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(ToolButton, { variant: \"text\", children: currentPageName || intl.formatMessage({ id: \"page\" }) }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(DMContent, { variant: \"menu\", align: \"start\", sideOffset: 4, children: isOpen && /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(PageMenuContent, { onClose: handleClose }) })\n  ] });\n}\nfunction PageMenuContent({ onClose }) {\n  const app = useTldrawApp();\n  const intl = useIntl();\n  const sortedPages = app.useStore(sortedSelector);\n  const currentPageId = app.useStore(currentPageIdSelector2);\n  const defaultPageName = intl.formatMessage({ id: \"page\" });\n  const handleCreatePage = React27.useCallback(() => {\n    const pageName = defaultPageName + \" \" + (Object.keys(app.document.pages).length + 1);\n    app.createPage(void 0, pageName);\n  }, [app]);\n  const handleChangePage = React27.useCallback(\n    (id) => {\n      onClose();\n      app.changePage(id);\n    },\n    [app]\n  );\n  const [dragId, setDragId] = React27.useState(null);\n  const [dropIndex, setDropIndex] = React27.useState(null);\n  const handleDragStart = React27.useCallback((event_) => {\n    setDragId(event_.currentTarget.id);\n    setDropIndex(sortedPages.findIndex((p6) => p6.id === event_.currentTarget.id));\n    event_.dataTransfer.effectAllowed = \"move\";\n  }, []);\n  const handleDrag = React27.useCallback(\n    (event_) => {\n      event_.preventDefault();\n      let dropIndex2 = sortedPages.findIndex((p6) => p6.id === event_.currentTarget.id);\n      const rect = event_.currentTarget.getBoundingClientRect();\n      const ny = (event_.clientY - rect.top) / rect.height;\n      dropIndex2 = ny < 0.5 ? dropIndex2 : dropIndex2 + 1;\n      setDropIndex(dropIndex2);\n    },\n    [dragId, sortedPages]\n  );\n  const handleDrop = React27.useCallback(() => {\n    if (dragId !== null && dropIndex !== null) {\n      app.movePage(dragId, dropIndex);\n    }\n    setDragId(null);\n    setDropIndex(null);\n  }, [dragId, dropIndex]);\n  return /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)(import_jsx_runtime40.Fragment, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime40.jsx)($d08ef79370b62062$export$a98f0dcb43a68a25, { dir: \"ltr\", value: currentPageId, onValueChange: handleChangePage, children: sortedPages.map((page, index2) => /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)(ButtonWithOptions, { isDropAbove: index2 === dropIndex && index2 === 0, isDropBelow: dropIndex !== null && index2 === dropIndex - 1, children: [\n      /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(\n        $d08ef79370b62062$export$371ab307eab489c0,\n        {\n          title: page.name || defaultPageName,\n          value: page.id,\n          id: page.id,\n          asChild: true,\n          onDragOver: handleDrag,\n          onDragStart: handleDragStart,\n          onDrop: handleDrop,\n          draggable: true,\n          children: /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)(PageButton, { children: [\n            /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(\"span\", { id: page.id, children: page.name || defaultPageName }),\n            /* @__PURE__ */ (0, import_jsx_runtime40.jsx)($d08ef79370b62062$export$c3468e2714d175fa, { children: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(SmallIcon, { children: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(CheckIcon, {}) }) })\n          ] })\n        },\n        page.id\n      ),\n      /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(PageOptionsDialog, { page, onClose })\n    ] }, page.id)) }),\n    /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(Divider, {}),\n    /* @__PURE__ */ (0, import_jsx_runtime40.jsx)($d08ef79370b62062$export$6d08773d2e66f8f2, { onSelect: handleCreatePage, asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)(RowButton, { children: [\n      /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(\"span\", { children: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(FormattedMessage, { id: \"create.page\" }) }),\n      /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(SmallIcon, { children: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(PlusIcon, {}) })\n    ] }) })\n  ] });\n}\nvar ButtonWithOptions = styled(\"div\", {\n  position: \"relative\",\n  display: \"grid\",\n  gridTemplateColumns: \"1fr auto\",\n  gridAutoFlow: \"column\",\n  margin: 0,\n  '& > *[data-shy=\"true\"]': {\n    opacity: 0\n  },\n  '&:hover > *[data-shy=\"true\"]': {\n    opacity: 1\n  },\n  variants: {\n    isDropAbove: {\n      true: {\n        \"&::after\": {\n          content: \"\",\n          display: \"block\",\n          position: \"absolute\",\n          top: 0,\n          width: \"100%\",\n          height: \"1px\",\n          backgroundColor: \"$selected\",\n          zIndex: 999,\n          pointerEvents: \"none\"\n        }\n      }\n    },\n    isDropBelow: {\n      true: {\n        \"&::after\": {\n          content: \"\",\n          display: \"block\",\n          position: \"absolute\",\n          width: \"100%\",\n          height: \"1px\",\n          top: \"100%\",\n          backgroundColor: \"$selected\",\n          zIndex: 999,\n          pointerEvents: \"none\"\n        }\n      }\n    }\n  }\n});\nvar PageButton = styled(RowButton, {\n  minWidth: 128\n});\n\n// src/components/Tldraw/components/TopPanel/StyleMenu/StyleMenu.tsx\nvar React46 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/state/shapes/shared/getBoundsRectangle.ts\nfunction getBoundsRectangle(shape, boundsCache) {\n  const bounds = C3.getFromCache(boundsCache, shape, () => {\n    const [width, height] = shape.size;\n    return {\n      minX: 0,\n      maxX: width,\n      minY: 0,\n      maxY: height,\n      width,\n      height\n    };\n  });\n  return C3.translateBounds(bounds, shape.point);\n}\n\n// src/components/Tldraw/state/shapes/shared/getTextAlign.ts\nvar ALIGN_VALUES = {\n  [\"start\" /* Start */]: \"left\",\n  [\"middle\" /* Middle */]: \"center\",\n  [\"end\" /* End */]: \"right\",\n  [\"justify\" /* Justify */]: \"justify\"\n};\nfunction getTextAlign(alignStyle = \"start\" /* Start */) {\n  return ALIGN_VALUES[alignStyle];\n}\n\n// src/components/Tldraw/constants.ts\nvar LETTER_SPACING = \"0\";\nvar GRID_SIZE = 8;\nvar SVG_EXPORT_PADDING = 16;\nvar BINDING_DISTANCE = 16;\nvar CLONING_DISTANCE = 32;\nvar FIT_TO_SCREEN_PADDING = 128;\nvar SNAP_DISTANCE = 5;\nvar SLOW_SPEED = 10;\nvar GHOSTED_OPACITY = 0.3;\nvar DEAD_ZONE = 3;\nvar LABEL_POINT = [0.5, 0.5];\nvar PI2 = Math.PI * 2;\nvar EASINGS = {\n  linear: (t5) => t5,\n  easeInQuad: (t5) => t5 * t5,\n  easeOutQuad: (t5) => t5 * (2 - t5),\n  easeInOutQuad: (t5) => t5 < 0.5 ? 2 * t5 * t5 : -1 + (4 - 2 * t5) * t5,\n  easeInCubic: (t5) => t5 * t5 * t5,\n  easeOutCubic: (t5) => --t5 * t5 * t5 + 1,\n  easeInOutCubic: (t5) => t5 < 0.5 ? 4 * t5 * t5 * t5 : (t5 - 1) * (2 * t5 - 2) * (2 * t5 - 2) + 1,\n  easeInQuart: (t5) => t5 * t5 * t5 * t5,\n  easeOutQuart: (t5) => 1 - --t5 * t5 * t5 * t5,\n  easeInOutQuart: (t5) => t5 < 0.5 ? 8 * t5 * t5 * t5 * t5 : 1 - 8 * --t5 * t5 * t5 * t5,\n  easeInQuint: (t5) => t5 * t5 * t5 * t5 * t5,\n  easeOutQuint: (t5) => 1 + --t5 * t5 * t5 * t5 * t5,\n  easeInOutQuint: (t5) => t5 < 0.5 ? 16 * t5 * t5 * t5 * t5 * t5 : 1 + 16 * --t5 * t5 * t5 * t5 * t5,\n  easeInSine: (t5) => 1 - Math.cos(t5 * Math.PI / 2),\n  easeOutSine: (t5) => Math.sin(t5 * Math.PI / 2),\n  easeInOutSine: (t5) => -(Math.cos(Math.PI * t5) - 1) / 2,\n  easeInExpo: (t5) => t5 <= 0 ? 0 : Math.pow(2, 10 * t5 - 10),\n  easeOutExpo: (t5) => t5 >= 1 ? 1 : 1 - Math.pow(2, -10 * t5),\n  easeInOutExpo: (t5) => t5 <= 0 ? 0 : t5 >= 1 ? 1 : t5 < 0.5 ? Math.pow(2, 20 * t5 - 10) / 2 : (2 - Math.pow(2, -20 * t5 + 10)) / 2\n};\nvar isSafari = typeof Window === \"undefined\" ? false : /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\nvar isLinux = typeof Window === \"undefined\" ? false : /linux/i.test(navigator.userAgent);\nvar IMAGE_EXTENSIONS = [\".png\", \".svg\", \".jpg\", \".jpeg\", \".gif\"];\n\n// src/components/Tldraw/state/shapes/shared/getTextSize.ts\nvar melm;\nfunction getMeasurementDiv() {\n  document.querySelector(\"#__textLabelMeasure\")?.remove();\n  const pre = document.createElement(\"pre\");\n  pre.id = \"__textLabelMeasure\";\n  Object.assign(pre.style, {\n    whiteSpace: \"pre\",\n    width: \"auto\",\n    border: \"1px solid transparent\",\n    padding: \"4px\",\n    margin: \"0px\",\n    letterSpacing: LETTER_SPACING,\n    opacity: \"0\",\n    position: \"absolute\",\n    top: \"-500px\",\n    left: \"0px\",\n    zIndex: \"9999\",\n    pointerEvents: \"none\",\n    userSelect: \"none\",\n    alignmentBaseline: \"mathematical\",\n    dominantBaseline: \"mathematical\"\n  });\n  pre.tabIndex = -1;\n  document.body.appendChild(pre);\n  return pre;\n}\nif (typeof window !== \"undefined\") {\n  melm = getMeasurementDiv();\n}\nvar prevText = \"\";\nvar prevFont = \"\";\nvar prevSize = [0, 0];\nfunction clearPrevSize() {\n  prevText = \"\";\n}\nfunction getTextLabelSize(text, font) {\n  if (!text) {\n    return [16, 32];\n  }\n  if (!melm) {\n    return [10, 10];\n  }\n  if (!melm.parent)\n    document.body.appendChild(melm);\n  if (text === prevText && font === prevFont) {\n    return prevSize;\n  }\n  prevText = text;\n  prevFont = font;\n  melm.textContent = text;\n  melm.style.font = font;\n  const width = melm.offsetWidth || 1;\n  const height = melm.offsetHeight || 1;\n  prevSize = [width, height];\n  return prevSize;\n}\n\n// src/components/Tldraw/state/shapes/shared/getTextSvgElement.ts\nvar wordSeparator = new RegExp(`${[32, 160, 4961, 65792, 65793, 4153, 4241].map((c5) => String.fromCodePoint(c5)).join(\"|\")}`);\nfunction getTextSvgElement(text, fontSize, fontFamily, textAlign, width, wrap = false) {\n  const fontWeight = \"normal\";\n  const lineHeight = 1;\n  const letterSpacingPct = LETTER_SPACING;\n  const lines = breakText({\n    text,\n    wrap,\n    width,\n    fontSize,\n    fontWeight,\n    fontFamily,\n    fontStyle: \"normal\",\n    textAlign: \"left\",\n    letterSpacing: LETTER_SPACING,\n    lineHeight: 1\n  });\n  const textElm = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n  textElm.setAttribute(\"font-size\", fontSize + \"px\");\n  textElm.setAttribute(\"font-family\", fontFamily);\n  textElm.setAttribute(\"font-weight\", fontWeight);\n  textElm.setAttribute(\"line-height\", lineHeight * fontSize + \"px\");\n  textElm.setAttribute(\"letter-spacing\", letterSpacingPct);\n  textElm.setAttribute(\"text-align\", textAlign ?? \"left\");\n  textElm.setAttribute(\"dominant-baseline\", \"mathematical\");\n  textElm.setAttribute(\"alignment-baseline\", \"mathematical\");\n  const textLines = lines.map((line, i4) => {\n    const tspan = document.createElementNS(\"http://www.w3.org/2000/svg\", \"tspan\");\n    tspan.textContent = line + \"\\n\";\n    tspan.setAttribute(\"y\", lineHeight * fontSize * (i4 + 0.5) + \"px\");\n    textElm.appendChild(tspan);\n    return tspan;\n  });\n  switch (textAlign) {\n    case \"middle\" /* Middle */: {\n      textElm.setAttribute(\"text-align\", \"center\");\n      textElm.setAttribute(\"text-anchor\", \"middle\");\n      textLines.forEach((textElm2) => textElm2.setAttribute(\"x\", 4 + width / 2 + \"\"));\n      break;\n    }\n    case \"end\" /* End */: {\n      textElm.setAttribute(\"text-align\", \"right\");\n      textElm.setAttribute(\"text-anchor\", \"end\");\n      textLines.forEach((textElm2) => textElm2.setAttribute(\"x\", 4 + width + \"\"));\n      break;\n    }\n    default: {\n      textElm.setAttribute(\"text-align\", \"left\");\n      textElm.setAttribute(\"text-anchor\", \"start\");\n      textLines.forEach((textElm2) => textElm2.setAttribute(\"x\", \"4\"));\n    }\n  }\n  return textElm;\n}\nfunction breakText(opts) {\n  const textElm = document.createElement(\"div\");\n  textElm.style.setProperty(\"position\", \"absolute\");\n  textElm.style.setProperty(\"top\", \"-9999px\");\n  textElm.style.setProperty(\"left\", \"-9999px\");\n  textElm.style.setProperty(\"width\", opts.width + \"px\");\n  textElm.style.setProperty(\"height\", \"min-content\");\n  textElm.style.setProperty(\"font-size\", opts.fontSize + \"px\");\n  textElm.style.setProperty(\"font-family\", opts.fontFamily);\n  textElm.style.setProperty(\"font-weight\", opts.fontWeight);\n  textElm.style.setProperty(\"line-height\", opts.lineHeight * opts.fontSize + \"px\");\n  textElm.style.setProperty(\"letter-spacing\", opts.letterSpacing);\n  textElm.style.setProperty(\"text-align\", opts.textAlign);\n  document.body.appendChild(textElm);\n  const words = opts.text.split(wordSeparator).flatMap((word) => word.replace(\"\\n\", \" \\n\")).join(\" \").split(\" \");\n  textElm.innerText = words[0];\n  let prevHeight = textElm.offsetHeight;\n  let currentLine = [words[0]];\n  const lines = [currentLine];\n  for (let i4 = 1; i4 < words.length; i4++) {\n    const word = words[i4];\n    textElm.innerText += \" \" + word;\n    const newHeight = textElm.offsetHeight;\n    if (newHeight > prevHeight) {\n      prevHeight = newHeight;\n      currentLine = [];\n      lines.push(currentLine);\n    }\n    currentLine.push(word);\n  }\n  textElm.remove();\n  return lines.map((line) => line.join(\" \"));\n}\n\n// src/components/Tldraw/state/shapes/shared/LabelMask.tsx\nvar import_jsx_runtime41 = require(\"react/jsx-runtime\");\nfunction LabelMask({ id, bounds, labelSize, offset, scale = 1 }) {\n  return /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(\"defs\", { children: /* @__PURE__ */ (0, import_jsx_runtime41.jsxs)(\"mask\", { id: id + \"_clip\", children: [\n    /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(\"rect\", { x: -100, y: -100, width: bounds.width + 200, height: bounds.height + 200, fill: \"white\" }),\n    /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(\n      \"rect\",\n      {\n        x: bounds.width / 2 - labelSize[0] / 2 * scale + (offset?.[0] || 0),\n        y: bounds.height / 2 - labelSize[1] / 2 * scale + (offset?.[1] || 0),\n        width: labelSize[0] * scale,\n        height: labelSize[1] * scale,\n        rx: 4 * scale,\n        ry: 4 * scale,\n        fill: \"black\",\n        opacity: Math.max(scale, 0.8)\n      }\n    )\n  ] }) });\n}\n\n// src/components/Tldraw/state/shapes/shared/PolygonUtils.ts\nvar PI22 = Math.PI * 2;\nvar _PolygonUtils = class {\n  static inwardEdgeNormal(edge) {\n    const delta = p.sub(edge[1], edge[0]);\n    const len = p.len2(delta);\n    return [-delta[0] / len, delta[1] / len];\n  }\n  static outwardEdgeNormal(edge) {\n    return p.neg(_PolygonUtils.inwardEdgeNormal(edge));\n  }\n  static isReflexVertex(polygon, index2) {\n    const len = polygon.length;\n    const v0 = polygon[(index2 + len - 1) % len];\n    const v1 = polygon[index2];\n    const v22 = polygon[(index2 + 1) % len];\n    if (_PolygonUtils.leftSide(v0, v22, v1) < 0)\n      return true;\n    return false;\n  }\n  static getEdges(vertices) {\n    return vertices.map((vert, i4) => [vert, vertices[(i4 + 1) % vertices.length]]);\n  }\n  static edgesIntersection([A1, A22], [B1, B22]) {\n    const den = (B22[1] - B1[1]) * (A22[0] - A1[0]) - (B22[0] - B1[0]) * (A22[1] - A1[1]);\n    if (den == 0)\n      return null;\n    const ua = ((B22[0] - B1[0]) * (A1[1] - B1[1]) - (B22[1] - B1[1]) * (A1[0] - B1[0])) / den;\n    const ub = ((A22[0] - A1[0]) * (A1[1] - B1[1]) - (A22[1] - A1[1]) * (A1[0] - B1[0])) / den;\n    if (ua < 0 || ub < 0 || ua > 1 || ub > 1)\n      return null;\n    return [A1[0] + ua * (A22[0] - A1[0]), A1[1] + ua * (A22[1] - A1[1])];\n  }\n  static appendArc(polygon, center, radius, startVertex, endVertex, isPaddingBoundary = false) {\n    const vertices = [...polygon];\n    let startAngle = Math.atan2(startVertex[1] - center[1], startVertex[0] - center[0]);\n    let endAngle = Math.atan2(endVertex[1] - center[1], endVertex[0] - center[0]);\n    if (startAngle < 0)\n      startAngle += PI22;\n    if (endAngle < 0)\n      endAngle += PI22;\n    const arcSegmentCount = 5;\n    const angle = startAngle > endAngle ? startAngle - endAngle : startAngle + PI22 - endAngle;\n    const angle5 = (isPaddingBoundary ? -angle : PI22 - angle) / arcSegmentCount;\n    vertices.push(startVertex);\n    for (let i4 = 1; i4 < arcSegmentCount; ++i4) {\n      const angle2 = startAngle + angle5 * i4;\n      vertices.push([center[0] + Math.cos(angle2) * radius, center[1] + Math.sin(angle2) * radius]);\n    }\n    vertices.push(endVertex);\n    return vertices;\n  }\n  static createOffsetEdge(edge, offset) {\n    return edge.map((vert) => p.add(vert, offset));\n  }\n  static getOffsetPolygon(polygon, offset = 0) {\n    const edges = _PolygonUtils.getEdges(polygon);\n    const offsetEdges = edges.map((edge) => _PolygonUtils.createOffsetEdge(edge, p.mul(_PolygonUtils.outwardEdgeNormal(edge), offset)));\n    const vertices = [];\n    for (let i4 = 0; i4 < offsetEdges.length; i4++) {\n      const thisEdge = offsetEdges[i4];\n      const prevEdge = offsetEdges[(i4 + offsetEdges.length - 1) % offsetEdges.length];\n      const vertex = _PolygonUtils.edgesIntersection(prevEdge, thisEdge);\n      if (vertex)\n        vertices.push(vertex);\n      else {\n        _PolygonUtils.appendArc(vertices, edges[i4][0], offset, prevEdge[1], thisEdge[0], false);\n      }\n    }\n    return vertices;\n  }\n  static createPaddingPolygon(polygon, shapePadding = 0) {\n    const offsetEdges = polygon.map((edge) => _PolygonUtils.createOffsetEdge(edge, _PolygonUtils.inwardEdgeNormal(edge)));\n    const vertices = [];\n    for (let i4 = 0; i4 < offsetEdges.length; i4++) {\n      const thisEdge = offsetEdges[i4];\n      const prevEdge = offsetEdges[(i4 + offsetEdges.length - 1) % offsetEdges.length];\n      const vertex = _PolygonUtils.edgesIntersection(prevEdge, thisEdge);\n      if (vertex)\n        vertices.push(vertex);\n      else {\n        _PolygonUtils.appendArc(vertices, polygon[i4][0], shapePadding, prevEdge[1], thisEdge[0], true);\n      }\n    }\n    return vertices;\n  }\n};\nvar PolygonUtils = _PolygonUtils;\n__publicField(PolygonUtils, \"leftSide\", p.isLeft);\nfunction getOffsetPolygon(points, offset) {\n  if (points.length < 3)\n    throw new Error(\"Polygon must have at least 3 points\");\n  const len = points.length;\n  return points.map((point, i4) => [point, points[(i4 + 1) % len]]).map(([A5, B4]) => {\n    const offsetVector = p.mul(p.per(p.uni(p.sub(B4, A5))), offset);\n    return [p.add(A5, offsetVector), p.add(B4, offsetVector)];\n  }).map((edge, i4, edges) => {\n    const intersection = ie2(edge, edges[(i4 + 1) % edges.length]);\n    if (intersection === void 0)\n      throw new Error(\"Expected an intersection\");\n    return intersection;\n  });\n}\n\n// src/components/Tldraw/state/shapes/shared/shape-styles.ts\nvar canvasLight = \"#fafafa\";\nvar canvasDark = \"#343d45\";\nvar colors = {\n  [\"white\" /* White */]: \"#f0f1f3\",\n  [\"lightGray\" /* LightGray */]: \"#c6cbd1\",\n  [\"gray\" /* Gray */]: \"#788492\",\n  [\"black\" /* Black */]: \"#1d1d1d\",\n  [\"green\" /* Green */]: \"#36b24d\",\n  [\"cyan\" /* Cyan */]: \"#0e98ad\",\n  [\"blue\" /* Blue */]: \"#1c7ed6\",\n  [\"indigo\" /* Indigo */]: \"#4263eb\",\n  [\"violet\" /* Violet */]: \"#7746f1\",\n  [\"red\" /* Red */]: \"#ff2133\",\n  [\"orange\" /* Orange */]: \"#ff9433\",\n  [\"yellow\" /* Yellow */]: \"#ffc936\"\n};\nvar stickyFills = {\n  light: {\n    ...Object.fromEntries(Object.entries(colors).map(([k6, v6]) => [k6, C3.lerpColor(v6, canvasLight, 0.45)])),\n    [\"white\" /* White */]: \"#ffffff\",\n    [\"black\" /* Black */]: \"#3d3d3d\"\n  },\n  dark: {\n    ...Object.fromEntries(Object.entries(colors).map(([k6, v6]) => [k6, C3.lerpColor(C3.lerpColor(v6, \"#999999\", 0.3), canvasDark, 0.4)])),\n    [\"white\" /* White */]: \"#1d1d1d\",\n    [\"black\" /* Black */]: \"#bbbbbb\"\n  }\n};\nvar strokes = {\n  light: {\n    ...colors,\n    [\"white\" /* White */]: \"#1d1d1d\"\n  },\n  dark: {\n    ...Object.fromEntries(Object.entries(colors).map(([k6, v6]) => [k6, C3.lerpColor(v6, canvasDark, 0.1)])),\n    [\"white\" /* White */]: \"#cecece\",\n    [\"black\" /* Black */]: \"#cecece\"\n  }\n};\nvar fills = {\n  light: {\n    ...Object.fromEntries(Object.entries(colors).map(([k6, v6]) => [k6, C3.lerpColor(v6, canvasLight, 0.82)])),\n    [\"white\" /* White */]: \"#fefefe\"\n  },\n  dark: {\n    ...Object.fromEntries(Object.entries(colors).map(([k6, v6]) => [k6, C3.lerpColor(v6, canvasDark, 0.82)])),\n    [\"white\" /* White */]: \"rgb(30,33,37)\",\n    [\"black\" /* Black */]: \"#1e1e1f\"\n  }\n};\nvar strokeWidths = {\n  [\"small\" /* Small */]: 2,\n  [\"medium\" /* Medium */]: 3.5,\n  [\"large\" /* Large */]: 5\n};\nvar fontSizes = {\n  [\"small\" /* Small */]: 28,\n  [\"medium\" /* Medium */]: 48,\n  [\"large\" /* Large */]: 96,\n  auto: \"auto\"\n};\nvar fontFaces = {\n  [\"script\" /* Script */]: '\"Caveat Brush\"',\n  [\"sans\" /* Sans */]: '\"Source Sans Pro\"',\n  [\"serif\" /* Serif */]: '\"Crimson Pro\"',\n  [\"mono\" /* Mono */]: '\"Source Code Pro\"'\n};\nvar fontSizeModifiers = {\n  [\"script\" /* Script */]: 1,\n  [\"sans\" /* Sans */]: 1,\n  [\"serif\" /* Serif */]: 1,\n  [\"mono\" /* Mono */]: 1\n};\nvar stickyFontSizes = {\n  [\"small\" /* Small */]: 24,\n  [\"medium\" /* Medium */]: 36,\n  [\"large\" /* Large */]: 48,\n  auto: \"auto\"\n};\nfunction getStrokeWidth(size) {\n  return strokeWidths[size];\n}\nfunction getFontSize(size, fontStyle = \"script\" /* Script */) {\n  return fontSizes[size] * fontSizeModifiers[fontStyle];\n}\nfunction getFontFace(font = \"script\" /* Script */) {\n  return fontFaces[font];\n}\nfunction getStickyFontSize(size) {\n  return stickyFontSizes[size];\n}\nfunction getFontStyle(style) {\n  const fontSize = getFontSize(style.size, style.font);\n  const tiddlywikiFontSetting = typeof $tw === \"undefined\" ? void 0 : $tw.wiki.getTiddlerText(\"$:/themes/tiddlywiki/vanilla/settings/fontfamily\");\n  const fontFace = tiddlywikiFontSetting ?? getFontFace(style.font);\n  const { scale = 1 } = style;\n  return `${fontSize * scale}px/1 ${fontFace}`;\n}\nfunction getStickyFontStyle(style) {\n  const fontSize = getStickyFontSize(style.size);\n  const fontFace = getFontFace(style.font);\n  const { scale = 1 } = style;\n  return `${fontSize * scale}px/1 ${fontFace}`;\n}\nfunction getStickyShapeStyle(style) {\n  const { color } = style;\n  const theme = \"light\";\n  const adjustedColor = color === \"white\" /* White */ || color === \"black\" /* Black */ ? \"yellow\" /* Yellow */ : color;\n  return {\n    fill: stickyFills[theme][adjustedColor],\n    stroke: strokes[theme][adjustedColor],\n    color: \"#0d0d0d\"\n  };\n}\nfunction getShapeStyle(style) {\n  const { color, size, isFilled } = style;\n  const strokeWidth = getStrokeWidth(size);\n  const theme = \"light\";\n  return {\n    stroke: strokes[theme][color],\n    fill: isFilled ? fills[theme][color] : \"none\",\n    strokeWidth\n  };\n}\nvar defaultStyle = {\n  color: \"black\" /* Black */,\n  size: \"small\" /* Small */,\n  isFilled: false,\n  dash: \"draw\" /* Draw */,\n  scale: 1\n};\nvar defaultTextStyle = {\n  ...defaultStyle,\n  font: \"script\" /* Script */,\n  textAlign: \"middle\" /* Middle */\n};\n\n// src/components/Tldraw/state/shapes/shared/TextAreaUtils.ts\nvar INDENT = \"  \";\nvar TextAreaUtils = class {\n  static insertTextFirefox(field, text) {\n    field.setRangeText(\n      text,\n      field.selectionStart || 0,\n      field.selectionEnd || 0,\n      \"end\"\n    );\n    field.dispatchEvent(\n      new InputEvent(\"input\", {\n        data: text,\n        inputType: \"insertText\",\n        isComposing: false\n      })\n    );\n  }\n  static insert(field, text) {\n    const document2 = field.ownerDocument;\n    const initialFocus = document2.activeElement;\n    if (initialFocus !== field) {\n      field.focus();\n    }\n    if (!document2.execCommand(\"insertText\", false, text)) {\n      TextAreaUtils.insertTextFirefox(field, text);\n    }\n    if (initialFocus === document2.body) {\n      field.blur();\n    } else if (initialFocus instanceof HTMLElement && initialFocus !== field) {\n      initialFocus.focus();\n    }\n  }\n  static set(field, text) {\n    field.select();\n    TextAreaUtils.insert(field, text);\n  }\n  static getSelection(field) {\n    const { selectionStart, selectionEnd } = field;\n    return field.value.slice(selectionStart || void 0, selectionEnd || void 0);\n  }\n  static wrapSelection(field, wrap, wrapEnd) {\n    const { selectionStart, selectionEnd } = field;\n    const selection = TextAreaUtils.getSelection(field);\n    TextAreaUtils.insert(field, wrap + selection + (wrapEnd ?? wrap));\n    field.selectionStart = (selectionStart || 0) + wrap.length;\n    field.selectionEnd = (selectionEnd || 0) + wrap.length;\n  }\n  static replace(field, searchValue, replacer) {\n    let drift = 0;\n    field.value.replace(searchValue, (...args) => {\n      const matchStart = drift + args[args.length - 2];\n      const matchLength = args[0].length;\n      field.selectionStart = matchStart;\n      field.selectionEnd = matchStart + matchLength;\n      const replacement = typeof replacer === \"string\" ? replacer : replacer(...args);\n      TextAreaUtils.insert(field, replacement);\n      field.selectionStart = matchStart;\n      drift += replacement.length - matchLength;\n      return replacement;\n    });\n  }\n  static findLineEnd(value, currentEnd) {\n    const lastLineStart = value.lastIndexOf(\"\\n\", currentEnd - 1) + 1;\n    if (value.charAt(lastLineStart) !== \"\t\") {\n      return currentEnd;\n    }\n    return lastLineStart + 1;\n  }\n  static indent(element) {\n    const { selectionStart, selectionEnd, value } = element;\n    const selectedContrast = value.slice(selectionStart, selectionEnd);\n    const lineBreakCount = /\\n/g.exec(selectedContrast)?.length;\n    if (lineBreakCount && lineBreakCount > 0) {\n      const firstLineStart = value.lastIndexOf(\"\\n\", selectionStart - 1) + 1;\n      const newSelection = element.value.slice(firstLineStart, selectionEnd - 1);\n      const indentedText = newSelection.replace(\n        /^|\\n/g,\n        `$&${INDENT}`\n      );\n      const replacementsCount = indentedText.length - newSelection.length;\n      element.setSelectionRange(firstLineStart, selectionEnd - 1);\n      TextAreaUtils.insert(element, indentedText);\n      element.setSelectionRange(selectionStart + 1, selectionEnd + replacementsCount);\n    } else {\n      TextAreaUtils.insert(element, INDENT);\n    }\n  }\n  static unindent(element) {\n    const { selectionStart, selectionEnd, value } = element;\n    const firstLineStart = value.lastIndexOf(\"\\n\", selectionStart - 1) + 1;\n    const minimumSelectionEnd = TextAreaUtils.findLineEnd(value, selectionEnd);\n    const newSelection = element.value.slice(firstLineStart, minimumSelectionEnd);\n    const indentedText = newSelection.replace(/(^|\\n)(\\t| {1,2})/g, \"$1\");\n    const replacementsCount = newSelection.length - indentedText.length;\n    element.setSelectionRange(firstLineStart, minimumSelectionEnd);\n    TextAreaUtils.insert(element, indentedText);\n    const firstLineIndentation = /\\t| {1,2}/.exec(value.slice(firstLineStart, selectionStart));\n    const difference = firstLineIndentation ? firstLineIndentation[0].length : 0;\n    const newSelectionStart = selectionStart - difference;\n    element.setSelectionRange(selectionStart - difference, Math.max(newSelectionStart, selectionEnd - replacementsCount));\n  }\n};\n\n// src/components/Tldraw/state/shapes/shared/TextLabel.tsx\nvar React45 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/state/StateManager/copy.ts\nfunction deepCopy(target) {\n  if (target === null) {\n    return target;\n  }\n  if (target instanceof Date) {\n    return new Date(target.getTime());\n  }\n  if (typeof target === \"object\") {\n    if (typeof target[Symbol.iterator] === \"function\") {\n      const cp = [];\n      if (target.length > 0) {\n        for (const arrayMember of target) {\n          cp.push(deepCopy(arrayMember));\n        }\n      }\n      return cp;\n    } else {\n      const targetKeys = Object.keys(target);\n      const cp = {};\n      if (targetKeys.length > 0) {\n        for (const key of targetKeys) {\n          cp[key] = deepCopy(target[key]);\n        }\n      }\n      return cp;\n    }\n  }\n  return target;\n}\n\n// src/components/Tldraw/state/shapes/ArrowUtil/ArrowUtil.tsx\nvar React31 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/state/shapes/TDShapeUtil.tsx\nvar React28 = __toESM(require(\"react\"));\nvar TDShapeUtil = class extends _e2 {\n  canBind = false;\n  canEdit = false;\n  canClone = false;\n  isAspectRatioLocked = false;\n  hideResizeHandles = false;\n  bindingDistance = BINDING_DISTANCE;\n  hitTestPoint = (shape, point) => {\n    return C3.pointInBounds(point, this.getRotatedBounds(shape));\n  };\n  hitTestLineSegment = (shape, A5, B4) => {\n    const box = C3.getBoundsFromPoints([A5, B4]);\n    const bounds = this.getBounds(shape);\n    return C3.boundsContain(bounds, box) || shape.rotation ? S(A5, B4, C3.getRotatedCorners(this.getBounds(shape))).didIntersect : ce2(A5, B4, this.getBounds(shape)).length > 0;\n  };\n  create = (props) => {\n    this.refMap.set(props.id, React28.createRef());\n    return this.getShape(props);\n  };\n  getCenter = (shape) => {\n    return C3.getBoundsCenter(this.getBounds(shape));\n  };\n  getExpandedBounds = (shape) => {\n    return C3.expandBounds(this.getBounds(shape), this.bindingDistance);\n  };\n  getBindingPoint = (shape, fromShape, point, origin, direction, bindAnywhere) => {\n    const bounds = this.getBounds(shape);\n    const expandedBounds = this.getExpandedBounds(shape);\n    if (!C3.pointInBounds(point, expandedBounds))\n      return;\n    const intersections = se2(origin, direction, expandedBounds).filter((int) => int.didIntersect).map((int) => int.points[0]);\n    if (intersections.length === 0)\n      return;\n    const center = this.getCenter(shape);\n    const intersection = intersections.sort((a7, b6) => e.dist(b6, origin) - e.dist(a7, origin))[0];\n    const middlePoint = e.med(point, intersection);\n    let anchor;\n    let distance;\n    if (bindAnywhere) {\n      anchor = e.dist(point, center) < BINDING_DISTANCE / 2 ? center : point;\n      distance = 0;\n    } else {\n      if (e.distanceToLineSegment(point, middlePoint, center) < BINDING_DISTANCE / 2) {\n        anchor = center;\n      } else {\n        anchor = middlePoint;\n      }\n      if (C3.pointInBounds(point, bounds)) {\n        distance = this.bindingDistance;\n      } else {\n        distance = Math.max(\n          this.bindingDistance,\n          C3.getBoundsSides(bounds).map((side) => e.distanceToLineSegment(side[1][0], side[1][1], point)).sort((a7, b6) => a7 - b6)[0]\n        );\n      }\n    }\n    const bindingPoint = e.divV(e.sub(anchor, [expandedBounds.minX, expandedBounds.minY]), [expandedBounds.width, expandedBounds.height]);\n    return {\n      point: e.clampV(bindingPoint, 0, 1),\n      distance\n    };\n  };\n  mutate = (shape, props) => {\n    return props;\n  };\n  transform = (shape, bounds, info) => {\n    return { ...shape, point: [bounds.minX, bounds.minY] };\n  };\n  transformSingle = (shape, bounds, info) => {\n    return this.transform(shape, bounds, info);\n  };\n  updateChildren;\n  onChildrenChange;\n  onHandleChange;\n  onRightPointHandle;\n  onDoubleClickHandle;\n  onDoubleClickBoundsHandle;\n  onSessionComplete;\n  getSvgElement = (shape) => {\n    const elm = document.getElementById(shape.id + \"_svg\")?.cloneNode(true);\n    if (!elm)\n      return;\n    const hasLabel = shape.label?.trim()?.length ?? 0 > 0;\n    if (hasLabel) {\n      const s5 = shape;\n      const g6 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n      const font = getFontStyle(shape.style);\n      const labelSize = getTextLabelSize(shape.label, font);\n      const fontSize = getFontSize(shape.style.size, shape.style.font) * (shape.style.scale ?? 1);\n      const fontFamily = getFontFace(shape.style.font).slice(1, -1);\n      const labelElm = getTextSvgElement(s5.label, fontSize, fontFamily, \"middle\" /* Middle */, labelSize[0], false);\n      const bounds = this.getBounds(shape);\n      labelElm.setAttribute(\"transform\", `translate(${bounds.width / 2 - labelSize[0] / 2}, ${bounds.height / 2 - labelSize[1] / 2})`);\n      labelElm.setAttribute(\"fill\", getShapeStyle(shape.style).stroke);\n      labelElm.setAttribute(\"transform-origin\", \"center center\");\n      g6.setAttribute(\"text-align\", \"center\");\n      g6.setAttribute(\"text-anchor\", \"middle\");\n      g6.appendChild(elm);\n      g6.appendChild(labelElm);\n      return g6;\n    }\n    return elm;\n  };\n};\n\n// src/components/Tldraw/state/shapes/ArrowUtil/arrowHelpers.ts\nfunction getArrowArcPath(start, end, circle, bend) {\n  return [\"M\", start[0], start[1], \"A\", circle[2], circle[2], 0, 0, bend < 0 ? 0 : 1, end[0], end[1]].join(\" \");\n}\nfunction getBendPoint(handles, bend) {\n  const { start, end } = handles;\n  const dist = p.dist(start.point, end.point);\n  const midPoint = p.med(start.point, end.point);\n  const bendDist = dist / 2 * bend;\n  const u5 = p.uni(p.vec(start.point, end.point));\n  const point = p.toFixed(Math.abs(bendDist) < 10 ? midPoint : p.add(midPoint, p.mul(p.per(u5), bendDist)));\n  return point;\n}\nfunction renderFreehandArrowShaft(id, style, start, end, decorationStart, decorationEnd) {\n  const getRandom = C3.rng(id);\n  const strokeWidth = getShapeStyle(style).strokeWidth;\n  const startPoint = decorationStart ? p.nudge(start, end, strokeWidth) : start;\n  const endPoint = decorationEnd ? p.nudge(end, start, strokeWidth) : end;\n  const stroke = _e([startPoint, endPoint], {\n    size: strokeWidth,\n    thinning: 0.618 + getRandom() * 0.2,\n    easing: EASINGS.easeOutQuad,\n    simulatePressure: true,\n    streamline: 0,\n    last: true\n  });\n  return C3.getSvgPathFromStroke(stroke);\n}\nfunction renderCurvedFreehandArrowShaft(id, style, start, end, decorationStart, decorationEnd, center, radius, length, easing) {\n  const getRandom = C3.rng(id);\n  const strokeWidth = getShapeStyle(style).strokeWidth;\n  const startPoint = decorationStart ? p.rotWith(start, center, strokeWidth / length) : start;\n  const endPoint = decorationEnd ? p.rotWith(end, center, -(strokeWidth / length)) : end;\n  const startAngle = p.angle(center, startPoint);\n  const endAngle = p.angle(center, endPoint);\n  const points = [];\n  const count = 8 + Math.floor(Math.abs(length) / 20 * 1 + getRandom() / 2);\n  for (let i4 = 0; i4 < count; i4++) {\n    const t5 = easing(i4 / count);\n    const angle = C3.lerpAngles(startAngle, endAngle, t5);\n    points.push(p.toFixed(p.nudgeAtAngle(center, angle, radius)));\n  }\n  const stroke = _e([startPoint, ...points, endPoint], {\n    size: 1 + strokeWidth,\n    thinning: 0.618 + getRandom() * 0.2,\n    easing: EASINGS.easeOutQuad,\n    simulatePressure: false,\n    streamline: 0,\n    last: true\n  });\n  return C3.getSvgPathFromStroke(stroke);\n}\nfunction getCtp(start, bend, end) {\n  return C3.circleFromThreePoints(start, end, bend);\n}\nfunction getCurvedArrowHeadPoints(A5, r1, C6, r22, sweep) {\n  const ints = le(A5, r1 * 0.618, C6, r22).points;\n  if (!ints) {\n    TLDR.warn(\"Could not find an intersection for the arrow head.\");\n    return { left: A5, right: A5 };\n  }\n  const int = sweep ? ints[0] : ints[1];\n  const left = int ? p.nudge(p.rotWith(int, A5, Math.PI / 6), A5, r1 * -0.382) : A5;\n  const right = int ? p.nudge(p.rotWith(int, A5, -Math.PI / 6), A5, r1 * -0.382) : A5;\n  return { left, right };\n}\nfunction getStraightArrowHeadPoints(A5, B4, r5) {\n  const ints = de2(A5, r5, A5, B4).points;\n  if (!ints) {\n    TLDR.warn(\"Could not find an intersection for the arrow head.\");\n    return { left: A5, right: A5 };\n  }\n  const int = ints[0];\n  const left = int ? p.rotWith(int, A5, Math.PI / 6) : A5;\n  const right = int ? p.rotWith(int, A5, -Math.PI / 6) : A5;\n  return { left, right };\n}\nfunction getCurvedArrowHeadPath(A5, r1, C6, r22, sweep) {\n  const { left, right } = getCurvedArrowHeadPoints(A5, r1, C6, r22, sweep);\n  return `M ${left} L ${A5} ${right}`;\n}\nfunction getStraightArrowHeadPath(A5, B4, r5) {\n  const { left, right } = getStraightArrowHeadPoints(A5, B4, r5);\n  return `M ${left} L ${A5} ${right}`;\n}\nfunction getArrowPath(style, start, bend, end, decorationStart, decorationEnd) {\n  const { strokeWidth } = getShapeStyle(style, false);\n  const arrowDist = p.dist(start, end);\n  const arrowHeadLength = Math.min(arrowDist / 3, strokeWidth * 8);\n  const path = [];\n  const isStraightLine = p.dist(bend, p.toFixed(p.med(start, end))) < 1;\n  if (isStraightLine) {\n    path.push(`M ${start} L ${end}`);\n    if (decorationStart) {\n      path.push(getStraightArrowHeadPath(start, end, arrowHeadLength));\n    }\n    if (decorationEnd) {\n      path.push(getStraightArrowHeadPath(end, start, arrowHeadLength));\n    }\n  } else {\n    const circle = getCtp(start, bend, end);\n    const center = [circle[0], circle[1]];\n    const radius = circle[2];\n    const length = getArcLength(center, radius, start, end);\n    path.push(`M ${start} A ${radius} ${radius} 0 0 ${length > 0 ? \"1\" : \"0\"} ${end}`);\n    if (decorationStart)\n      path.push(getCurvedArrowHeadPath(start, arrowHeadLength, center, radius, length < 0));\n    if (decorationEnd) {\n      path.push(getCurvedArrowHeadPath(end, arrowHeadLength, center, radius, length >= 0));\n    }\n  }\n  return path.join(\" \");\n}\nfunction getArcPoints(start, bend, end) {\n  if (p.dist2(bend, p.med(start, end)) <= 4)\n    return [start, end];\n  const points = [];\n  const circle = getCtp(start, bend, end);\n  const center = [circle[0], circle[1]];\n  const radius = circle[2];\n  const startAngle = p.angle(center, start);\n  const endAngle = p.angle(center, end);\n  for (let i4 = 0; i4 < 20; i4++) {\n    const t5 = i4 / 19;\n    const angle = C3.lerpAngles(startAngle, endAngle, t5);\n    points.push(p.nudgeAtAngle(center, angle, radius));\n  }\n  return points;\n}\nfunction isAngleBetween(a7, b6, c5) {\n  if (c5 === a7 || c5 === b6)\n    return true;\n  const PI24 = Math.PI * 2;\n  const AB = (b6 - a7 + PI24) % PI24;\n  const AC = (c5 - a7 + PI24) % PI24;\n  return AB <= Math.PI !== AC > AB;\n}\nfunction getArcLength(C6, r5, A5, B4) {\n  const sweep = C3.getSweep(C6, A5, B4);\n  return r5 * (2 * Math.PI) * (sweep / (2 * Math.PI));\n}\n\n// src/components/Tldraw/state/shapes/ArrowUtil/components/CurvedArrow.tsx.tsx\nvar React29 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/state/shapes/ArrowUtil/components/ArrowHead.tsx\nvar import_jsx_runtime42 = require(\"react/jsx-runtime\");\nfunction Arrowhead({ left, middle, right, stroke, strokeWidth }) {\n  return /* @__PURE__ */ (0, import_jsx_runtime42.jsxs)(\"g\", { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(\"path\", { className: \"tl-stroke-hitarea\", d: `M ${left} L ${middle} ${right}` }),\n    /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(\n      \"path\",\n      {\n        d: `M ${left} L ${middle} ${right}`,\n        fill: \"none\",\n        stroke,\n        strokeWidth,\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        pointerEvents: \"none\"\n      }\n    )\n  ] });\n}\n\n// src/components/Tldraw/state/shapes/ArrowUtil/components/CurvedArrow.tsx.tsx\nvar import_jsx_runtime43 = require(\"react/jsx-runtime\");\nvar CurvedArrow = React29.memo(function CurvedArrow2({\n  id,\n  style,\n  start,\n  bend,\n  end,\n  arrowBend,\n  decorationStart,\n  decorationEnd,\n  isDraw\n}) {\n  const arrowDist = p.dist(start, end);\n  if (arrowDist < 2)\n    return null;\n  const styles = getShapeStyle(style);\n  const { strokeWidth } = styles;\n  const sw = 1 + strokeWidth * 1.618;\n  const circle = getCtp(start, bend, end);\n  const center = [circle[0], circle[1]];\n  const radius = circle[2];\n  const length = getArcLength(center, radius, start, end);\n  const getRandom = C3.rng(id);\n  const easing = EASINGS[getRandom() > 0 ? \"easeInOutSine\" : \"easeInOutCubic\"];\n  const path = isDraw ? renderCurvedFreehandArrowShaft(id, style, start, end, decorationStart, decorationEnd, center, radius, length, easing) : getArrowArcPath(start, end, circle, arrowBend);\n  const { strokeDasharray, strokeDashoffset } = C3.getPerfectDashProps(Math.abs(length), sw, style.dash, 2, false);\n  const arrowHeadLength = Math.min(arrowDist / 3, strokeWidth * 8);\n  const startArrowHead = decorationStart ? getCurvedArrowHeadPoints(start, arrowHeadLength, center, radius, length < 0) : null;\n  const endArrowHead = decorationEnd ? getCurvedArrowHeadPoints(end, arrowHeadLength, center, radius, length >= 0) : null;\n  return /* @__PURE__ */ (0, import_jsx_runtime43.jsxs)(import_jsx_runtime43.Fragment, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(\"path\", { className: \"tl-stroke-hitarea\", d: path }),\n    /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(\n      \"path\",\n      {\n        d: path,\n        fill: isDraw ? styles.stroke : \"none\",\n        stroke: styles.stroke,\n        strokeWidth: isDraw ? 0 : sw,\n        strokeDasharray,\n        strokeDashoffset,\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        pointerEvents: \"none\"\n      }\n    ),\n    startArrowHead && /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(Arrowhead, { left: startArrowHead.left, middle: start, right: startArrowHead.right, stroke: styles.stroke, strokeWidth: sw }),\n    endArrowHead && /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(Arrowhead, { left: endArrowHead.left, middle: end, right: endArrowHead.right, stroke: styles.stroke, strokeWidth: sw })\n  ] });\n});\n\n// src/components/Tldraw/state/shapes/ArrowUtil/components/StraightArrow.tsx\nvar React30 = __toESM(require(\"react\"));\nvar import_jsx_runtime44 = require(\"react/jsx-runtime\");\nvar StraightArrow = React30.memo(function StraightArrow2({ id, style, start, end, decorationStart, decorationEnd, isDraw }) {\n  const arrowDist = p.dist(start, end);\n  if (arrowDist < 2)\n    return null;\n  const styles = getShapeStyle(style);\n  const { strokeWidth } = styles;\n  const sw = 1 + strokeWidth * 1.618;\n  const path = isDraw ? renderFreehandArrowShaft(id, style, start, end, decorationStart, decorationEnd) : \"M\" + p.toFixed(start) + \"L\" + p.toFixed(end);\n  const { strokeDasharray, strokeDashoffset } = C3.getPerfectDashProps(arrowDist, strokeWidth * 1.618, style.dash, 2, false);\n  const arrowHeadLength = Math.min(arrowDist / 3, strokeWidth * 8);\n  const startArrowHead = decorationStart ? getStraightArrowHeadPoints(start, end, arrowHeadLength) : null;\n  const endArrowHead = decorationEnd ? getStraightArrowHeadPoints(end, start, arrowHeadLength) : null;\n  return /* @__PURE__ */ (0, import_jsx_runtime44.jsxs)(import_jsx_runtime44.Fragment, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(\"path\", { className: \"tl-stroke-hitarea\", d: path }),\n    /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(\n      \"path\",\n      {\n        d: path,\n        fill: styles.stroke,\n        stroke: styles.stroke,\n        strokeWidth: isDraw ? sw / 2 : sw,\n        strokeDasharray,\n        strokeDashoffset,\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        pointerEvents: \"stroke\"\n      }\n    ),\n    startArrowHead && /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(Arrowhead, { left: startArrowHead.left, middle: start, right: startArrowHead.right, stroke: styles.stroke, strokeWidth: sw }),\n    endArrowHead && /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(Arrowhead, { left: endArrowHead.left, middle: end, right: endArrowHead.right, stroke: styles.stroke, strokeWidth: sw })\n  ] });\n});\n\n// src/components/Tldraw/state/shapes/ArrowUtil/ArrowUtil.tsx\nvar import_jsx_runtime45 = require(\"react/jsx-runtime\");\nvar ArrowUtil = class extends TDShapeUtil {\n  type = \"arrow\" /* Arrow */;\n  hideBounds = true;\n  canEdit = true;\n  pathCache = /* @__PURE__ */ new WeakMap();\n  getShape = (props) => {\n    return {\n      id: \"id\",\n      type: \"arrow\" /* Arrow */,\n      name: \"Arrow\",\n      parentId: \"page\",\n      childIndex: 1,\n      point: [0, 0],\n      rotation: 0,\n      bend: 0,\n      handles: {\n        start: {\n          id: \"start\",\n          index: 0,\n          point: [0, 0],\n          canBind: true,\n          ...props.handles?.start\n        },\n        end: {\n          id: \"end\",\n          index: 1,\n          point: [1, 1],\n          canBind: true,\n          ...props.handles?.end\n        },\n        bend: {\n          id: \"bend\",\n          index: 2,\n          point: [0.5, 0.5],\n          ...props.handles?.bend\n        }\n      },\n      decorations: props.decorations ?? {\n        end: \"arrow\" /* Arrow */\n      },\n      style: {\n        ...defaultStyle,\n        isFilled: false,\n        ...props.style\n      },\n      label: \"\",\n      labelPoint: [0.5, 0.5],\n      ...props\n    };\n  };\n  Component = TDShapeUtil.Component(({ shape, isEditing, isGhost, meta, events, onShapeChange, onShapeBlur }, ref) => {\n    const {\n      id,\n      label = \"\",\n      handles: { start, bend, end },\n      decorations = {},\n      style\n    } = shape;\n    const hasLabel = label?.trim()?.length ?? 0 > 0;\n    const isStraightLine = e.dist(bend.point, e.toFixed(e.med(start.point, end.point))) < 1;\n    const font = getFontStyle(style);\n    const styles = getShapeStyle(style);\n    const labelSize = hasLabel || isEditing ? getTextLabelSize(label, font) : [0, 0];\n    const bounds = this.getBounds(shape);\n    const dist = React31.useMemo(() => {\n      const { start: start2, bend: bend2, end: end2 } = shape.handles;\n      if (isStraightLine)\n        return e.dist(start2.point, end2.point);\n      const circle = getCtp(start2.point, bend2.point, end2.point);\n      const center = circle.slice(0, 2);\n      const radius = circle[2];\n      const length = getArcLength(center, radius, start2.point, end2.point);\n      return Math.abs(length);\n    }, [shape.handles]);\n    const scale = Math.max(0.5, Math.min(1, Math.max(dist / (labelSize[1] + 128), dist / (labelSize[0] + 128))));\n    const offset = React31.useMemo(() => {\n      const bounds2 = this.getBounds(shape);\n      const offset2 = e.sub(shape.handles.bend.point, e.toFixed([bounds2.width / 2, bounds2.height / 2]));\n      return offset2;\n    }, [shape, scale]);\n    const handleLabelChange = React31.useCallback(\n      (label2) => {\n        onShapeChange?.({ id, label: label2 });\n      },\n      [onShapeChange]\n    );\n    const Component = isStraightLine ? StraightArrow : CurvedArrow;\n    return /* @__PURE__ */ (0, import_jsx_runtime45.jsxs)(FullWrapper, { ref, ...events, children: [\n      /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(\n        TextLabel,\n        {\n          font,\n          text: label,\n          color: styles.stroke,\n          offsetX: offset[0],\n          offsetY: offset[1],\n          scale,\n          isEditing,\n          onChange: handleLabelChange,\n          onBlur: onShapeBlur\n        }\n      ),\n      /* @__PURE__ */ (0, import_jsx_runtime45.jsxs)(te, { id: shape.id + \"_svg\", children: [\n        /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(\"defs\", { children: /* @__PURE__ */ (0, import_jsx_runtime45.jsxs)(\"mask\", { id: shape.id + \"_clip\", children: [\n          /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(\"rect\", { x: -100, y: -100, width: bounds.width + 200, height: bounds.height + 200, fill: \"white\" }),\n          /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(\n            \"rect\",\n            {\n              x: bounds.width / 2 - labelSize[0] / 2 * scale + offset[0],\n              y: bounds.height / 2 - labelSize[1] / 2 * scale + offset[1],\n              width: labelSize[0] * scale,\n              height: labelSize[1] * scale,\n              rx: 4 * scale,\n              ry: 4 * scale,\n              fill: \"black\",\n              opacity: 1\n            }\n          )\n        ] }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(\"g\", { pointerEvents: \"none\", opacity: isGhost ? GHOSTED_OPACITY : 1, mask: hasLabel || isEditing ? `url(#${shape.id}_clip)` : ``, children: /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(\n          Component,\n          {\n            id,\n            style,\n            start: start.point,\n            end: end.point,\n            bend: bend.point,\n            arrowBend: shape.bend,\n            decorationStart: decorations?.start,\n            decorationEnd: decorations?.end,\n            isDraw: style.dash === \"draw\" /* Draw */\n          }\n        ) })\n      ] })\n    ] });\n  });\n  Indicator = TDShapeUtil.Indicator(({ shape, bounds }) => {\n    const {\n      style,\n      decorations,\n      label,\n      handles: { start, bend, end }\n    } = shape;\n    const hasLabel = label?.trim()?.length ?? 0 > 0;\n    const font = getFontStyle(style);\n    const labelSize = hasLabel ? getTextLabelSize(label, font) : [0, 0];\n    const isStraightLine = e.dist(bend.point, e.toFixed(e.med(start.point, end.point))) < 1;\n    const dist = React31.useMemo(() => {\n      const { start: start2, bend: bend2, end: end2 } = shape.handles;\n      if (isStraightLine)\n        return e.dist(start2.point, end2.point);\n      const circle = getCtp(start2.point, bend2.point, end2.point);\n      const center = circle.slice(0, 2);\n      const radius = circle[2];\n      const length = getArcLength(center, radius, start2.point, end2.point);\n      return Math.abs(length);\n    }, [shape.handles]);\n    const scale = Math.max(0.5, Math.min(1, Math.max(dist / (labelSize[1] + 128), dist / (labelSize[0] + 128))));\n    const offset = React31.useMemo(() => {\n      const bounds2 = this.getBounds(shape);\n      const offset2 = e.sub(shape.handles.bend.point, [bounds2.width / 2, bounds2.height / 2]);\n      return offset2;\n    }, [shape, scale]);\n    return /* @__PURE__ */ (0, import_jsx_runtime45.jsxs)(import_jsx_runtime45.Fragment, { children: [\n      hasLabel && /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(LabelMask, { id: shape.id, scale, offset, bounds, labelSize }),\n      /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(\n        \"path\",\n        {\n          d: getArrowPath(style, start.point, bend.point, end.point, decorations?.start, decorations?.end),\n          mask: hasLabel ? `url(#${shape.id}_clip)` : ``\n        }\n      ),\n      hasLabel && /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(\n        \"rect\",\n        {\n          x: bounds.width / 2 - labelSize[0] / 2 * scale + offset[0],\n          y: bounds.height / 2 - labelSize[1] / 2 * scale + offset[1],\n          width: labelSize[0] * scale,\n          height: labelSize[1] * scale,\n          rx: 4 * scale,\n          ry: 4 * scale,\n          fill: \"transparent\"\n        }\n      )\n    ] });\n  });\n  getBounds = (shape) => {\n    const bounds = C3.getFromCache(this.boundsCache, shape, () => {\n      const {\n        handles: { start, bend, end }\n      } = shape;\n      return C3.getBoundsFromPoints(getArcPoints(start.point, bend.point, end.point));\n    });\n    return C3.translateBounds(bounds, shape.point);\n  };\n  getRotatedBounds = (shape) => {\n    const {\n      handles: { start, bend, end }\n    } = shape;\n    let points = getArcPoints(start.point, bend.point, end.point);\n    const { minX, minY, maxX, maxY } = C3.getBoundsFromPoints(points);\n    if (shape.rotation !== 0) {\n      points = points.map((pt2) => e.rotWith(pt2, [(minX + maxX) / 2, (minY + maxY) / 2], shape.rotation || 0));\n    }\n    return C3.translateBounds(C3.getBoundsFromPoints(points), shape.point);\n  };\n  getCenter = (shape) => {\n    const { start, end } = shape.handles;\n    return e.add(shape.point, e.med(start.point, end.point));\n  };\n  shouldRender = (prev, next) => {\n    return next.decorations !== prev.decorations || next.handles !== prev.handles || next.style !== prev.style || next.label !== prev.label;\n  };\n  hitTestPoint = (shape, point) => {\n    const {\n      handles: { start, bend, end }\n    } = shape;\n    const pt2 = e.sub(point, shape.point);\n    const points = getArcPoints(start.point, bend.point, end.point);\n    for (let i4 = 1; i4 < points.length; i4++) {\n      if (e.distanceToLineSegment(points[i4 - 1], points[i4], pt2) < 1) {\n        return true;\n      }\n    }\n    return false;\n  };\n  hitTestLineSegment = (shape, A5, B4) => {\n    const {\n      handles: { start, bend, end }\n    } = shape;\n    const ptA = e.sub(A5, shape.point);\n    const ptB = e.sub(B4, shape.point);\n    const points = getArcPoints(start.point, bend.point, end.point);\n    for (let i4 = 1; i4 < points.length; i4++) {\n      if (B2(points[i4 - 1], points[i4], ptA, ptB).didIntersect) {\n        return true;\n      }\n    }\n    return false;\n  };\n  hitTestBounds = (shape, bounds) => {\n    const { start, end, bend } = shape.handles;\n    const sp = e.add(shape.point, start.point);\n    const ep = e.add(shape.point, end.point);\n    if (C3.pointInBounds(sp, bounds) || C3.pointInBounds(ep, bounds)) {\n      return true;\n    }\n    if (e.isEqual(e.med(start.point, end.point), bend.point)) {\n      return ce2(sp, ep, bounds).length > 0;\n    } else {\n      const [cx, cy, r5] = getCtp(start.point, bend.point, end.point);\n      const cp = e.add(shape.point, [cx, cy]);\n      return be(cp, r5, sp, ep, bounds).length > 0;\n    }\n  };\n  transform = (shape, bounds, { initialShape, scaleX, scaleY }) => {\n    const initialShapeBounds = this.getBounds(initialShape);\n    const handles = [\"start\", \"end\"];\n    const nextHandles = { ...initialShape.handles };\n    handles.forEach((handle) => {\n      if (handle === \"bend\")\n        return;\n      const [x5, y6] = nextHandles[handle].point;\n      const nw = x5 / initialShapeBounds.width;\n      const nh = y6 / initialShapeBounds.height;\n      nextHandles[handle] = {\n        ...nextHandles[handle],\n        point: [bounds.width * (scaleX < 0 ? 1 - nw : nw), bounds.height * (scaleY < 0 ? 1 - nh : nh)]\n      };\n    });\n    const nextBend = scaleX > 0 && scaleY < 0 || scaleX < 0 && scaleY > 0 ? -initialShape.bend : initialShape.bend;\n    const bendPoint = getBendPoint(nextHandles, nextBend);\n    nextHandles.bend.point = bendPoint;\n    return {\n      point: e.toFixed([bounds.minX, bounds.minY]),\n      handles: nextHandles,\n      bend: nextBend\n    };\n  };\n  onDoubleClickHandle = (shape, handle) => {\n    switch (handle) {\n      case \"bend\": {\n        return {\n          bend: 0,\n          handles: {\n            ...shape.handles,\n            bend: {\n              ...shape.handles.bend,\n              point: getBendPoint(shape.handles, shape.bend)\n            }\n          }\n        };\n      }\n      case \"start\": {\n        return {\n          decorations: {\n            ...shape.decorations,\n            start: shape.decorations?.start ? void 0 : \"arrow\" /* Arrow */\n          }\n        };\n      }\n      case \"end\": {\n        return {\n          decorations: {\n            ...shape.decorations,\n            end: shape.decorations?.end ? void 0 : \"arrow\" /* Arrow */\n          }\n        };\n      }\n    }\n    return this;\n  };\n  onHandleChange = (shape, handles) => {\n    let nextHandles = C3.deepMerge(shape.handles, handles);\n    let nextBend = shape.bend;\n    nextHandles = C3.deepMerge(nextHandles, {\n      start: {\n        point: e.toFixed(nextHandles.start.point)\n      },\n      end: {\n        point: e.toFixed(nextHandles.end.point)\n      }\n    });\n    if (e.isEqual(nextHandles.start.point, nextHandles.end.point))\n      return;\n    if (\"bend\" in handles) {\n      const { start, end, bend } = nextHandles;\n      const distance = e.dist(start.point, end.point);\n      const midPoint = e.med(start.point, end.point);\n      const angle = e.angle(start.point, end.point);\n      const u5 = e.uni(e.vec(start.point, end.point));\n      const ap = e.add(midPoint, e.mul(e.per(u5), distance));\n      const bp = e.sub(midPoint, e.mul(e.per(u5), distance));\n      const bendPoint = e.nearestPointOnLineSegment(ap, bp, bend.point, true);\n      const bendDist = e.dist(midPoint, bendPoint);\n      const realBend = bendDist / (distance / 2);\n      nextBend = C3.clamp(realBend, -0.99, 0.99);\n      const angleToBend = e.angle(start.point, bendPoint);\n      if (e.isEqual(midPoint, getBendPoint(nextHandles, nextBend))) {\n        nextBend = 0;\n      } else if (isAngleBetween(angle, angle + Math.PI, angleToBend)) {\n        nextBend *= -1;\n      }\n    }\n    const nextShape = {\n      point: shape.point,\n      bend: nextBend,\n      handles: {\n        ...nextHandles,\n        bend: {\n          ...nextHandles.bend,\n          point: getBendPoint(nextHandles, nextBend)\n        }\n      }\n    };\n    const topLeft = shape.point;\n    const nextBounds = this.getBounds({ ...nextShape });\n    const offset = e.sub([nextBounds.minX, nextBounds.minY], topLeft);\n    if (!e.isEqual(offset, [0, 0])) {\n      Object.values(nextShape.handles).forEach((handle) => {\n        handle.point = e.toFixed(e.sub(handle.point, offset));\n      });\n      nextShape.point = e.toFixed(e.add(nextShape.point, offset));\n    }\n    return nextShape;\n  };\n  getSvgElement = (shape) => {\n    const elm = document.getElementById(shape.id + \"_svg\")?.cloneNode(true);\n    if (!elm)\n      return;\n    const hasLabel = shape.label?.trim()?.length ?? 0 > 0;\n    if (hasLabel) {\n      const s5 = shape;\n      const g6 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n      const font = getFontStyle(shape.style);\n      const labelSize = getTextLabelSize(shape.label, font);\n      const fontSize = getFontSize(shape.style.size, shape.style.font) * (shape.style.scale ?? 1);\n      const fontFamily = getFontFace(shape.style.font).slice(1, -1);\n      const labelElm = getTextSvgElement(s5.label, fontSize, fontFamily, \"start\" /* Start */, labelSize[0], false);\n      let dist;\n      const { start, bend, end } = shape.handles;\n      const isStraightLine = e.dist(bend.point, e.toFixed(e.med(start.point, end.point))) < 1;\n      if (isStraightLine) {\n        dist = e.dist(start.point, end.point);\n      } else {\n        const circle = getCtp(start.point, bend.point, end.point);\n        const center = circle.slice(0, 2);\n        const radius = circle[2];\n        const length = getArcLength(center, radius, start.point, end.point);\n        dist = Math.abs(length);\n      }\n      const scale = Math.max(0.5, Math.min(1, Math.max(dist / (labelSize[1] + 128), dist / (labelSize[0] + 128))));\n      const bounds = this.getBounds(shape);\n      const offset = e.sub(shape.handles.bend.point, [bounds.width / 2, bounds.height / 2]);\n      const x5 = bounds.width / 2 - labelSize[0] / 2 * scale + offset[0];\n      const y6 = bounds.height / 2 - labelSize[1] / 2 * scale + offset[1];\n      labelElm.setAttribute(\"transform\", `translate(${x5}, ${y6})`);\n      labelElm.setAttribute(\"fill\", getShapeStyle(shape.style).stroke);\n      labelElm.setAttribute(\"transform-origin\", \"center center\");\n      g6.setAttribute(\"text-align\", \"center\");\n      g6.setAttribute(\"text-anchor\", \"middle\");\n      g6.appendChild(elm);\n      g6.appendChild(labelElm);\n      return g6;\n    }\n    return elm;\n  };\n};\nvar FullWrapper = styled(\"div\", { width: \"100%\", height: \"100%\" });\n\n// src/components/Tldraw/state/shapes/DrawUtil/DrawUtil.tsx\nvar React32 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/state/shapes/DrawUtil/drawHelpers.ts\nvar simulatePressureSettings = {\n  easing: (t5) => Math.sin(t5 * Math.PI / 2),\n  simulatePressure: true\n};\nvar realPressureSettings = {\n  easing: (t5) => t5 * t5,\n  simulatePressure: false\n};\nfunction getFreehandOptions(shape) {\n  const styles = getShapeStyle(shape.style);\n  const options = {\n    size: 1 + styles.strokeWidth * 1.5,\n    thinning: 0.65,\n    streamline: 0.65,\n    smoothing: 0.65,\n    ...shape.points[1][2] === 0.5 ? simulatePressureSettings : realPressureSettings,\n    last: shape.isComplete\n  };\n  return options;\n}\nfunction getFillPath(shape) {\n  if (shape.points.length < 2)\n    return \"\";\n  return C3.getSvgPathFromStroke(me(shape.points, getFreehandOptions(shape)).map((pt2) => pt2.point));\n}\nfunction getDrawStrokePoints(shape, options) {\n  return me(shape.points, options);\n}\nfunction getDrawStrokePathTDSnapshot(shape) {\n  if (shape.points.length < 2)\n    return \"\";\n  const options = getFreehandOptions(shape);\n  const strokePoints = getDrawStrokePoints(shape, options);\n  const path = C3.getSvgPathFromStroke(ce(strokePoints, options));\n  return path;\n}\nfunction getSolidStrokePathTDSnapshot(shape) {\n  const { points } = shape;\n  if (points.length < 2)\n    return \"M 0 0 L 0 0\";\n  const options = getFreehandOptions(shape);\n  const strokePoints = getDrawStrokePoints(shape, options);\n  const last = points[points.length - 1];\n  if (!p.isEqual(strokePoints[0].point, last))\n    strokePoints.push({ point: last });\n  const path = C3.getSvgPathFromStrokePoints(strokePoints);\n  return path;\n}\n\n// src/components/Tldraw/state/shapes/DrawUtil/DrawUtil.tsx\nvar import_jsx_runtime46 = require(\"react/jsx-runtime\");\nvar DrawUtil = class extends TDShapeUtil {\n  type = \"draw\" /* Draw */;\n  pointsBoundsCache = /* @__PURE__ */ new WeakMap([]);\n  shapeBoundsCache = /* @__PURE__ */ new Map();\n  rotatedCache = /* @__PURE__ */ new WeakMap([]);\n  pointCache = {};\n  canClone = true;\n  getShape = (props) => {\n    return C3.deepMerge(\n      {\n        id: \"id\",\n        type: \"draw\" /* Draw */,\n        name: \"Draw\",\n        parentId: \"page\",\n        childIndex: 1,\n        point: [0, 0],\n        rotation: 0,\n        style: defaultStyle,\n        points: [],\n        isComplete: false\n      },\n      props\n    );\n  };\n  Component = TDShapeUtil.Component(({ shape, meta, isSelected, isGhost, events }, ref) => {\n    const { points, style, isComplete } = shape;\n    const polygonPathTDSnapshot = React32.useMemo(() => {\n      return getFillPath(shape);\n    }, [points, style.size]);\n    const pathTDSnapshot = React32.useMemo(() => {\n      return style.dash === \"draw\" /* Draw */ ? getDrawStrokePathTDSnapshot(shape) : getSolidStrokePathTDSnapshot(shape);\n    }, [points, style.size, style.dash, isComplete]);\n    const styles = getShapeStyle(style);\n    const { stroke, fill, strokeWidth } = styles;\n    const bounds = this.getBounds(shape);\n    const verySmall = bounds.width <= strokeWidth / 2 && bounds.height <= strokeWidth / 2;\n    if (verySmall) {\n      const sw2 = 1 + strokeWidth;\n      return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(te, { ref, id: shape.id + \"_svg\", ...events, children: /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(\"circle\", { r: sw2, fill: stroke, stroke, pointerEvents: \"all\", opacity: isGhost ? GHOSTED_OPACITY : 1 }) });\n    }\n    const shouldFill = style.isFilled && points.length > 3 && e.dist(points[0], points[points.length - 1]) < strokeWidth * 2;\n    if (shape.style.dash === \"draw\" /* Draw */) {\n      return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(te, { ref, id: shape.id + \"_svg\", ...events, children: /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)(\"g\", { opacity: isGhost ? GHOSTED_OPACITY : 1, children: [\n        /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(\"path\", { className: shouldFill || isSelected ? \"tl-fill-hitarea\" : \"tl-stroke-hitarea\", d: pathTDSnapshot }),\n        shouldFill && /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(\"path\", { d: polygonPathTDSnapshot, stroke: \"none\", fill, strokeLinejoin: \"round\", strokeLinecap: \"round\", pointerEvents: \"none\" }),\n        /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(\n          \"path\",\n          {\n            d: pathTDSnapshot,\n            fill: stroke,\n            stroke,\n            strokeWidth: strokeWidth / 2,\n            strokeLinejoin: \"round\",\n            strokeLinecap: \"round\",\n            pointerEvents: \"none\"\n          }\n        )\n      ] }) });\n    }\n    const strokeDasharray = {\n      [\"draw\" /* Draw */]: \"none\",\n      [\"solid\" /* Solid */]: `none`,\n      [\"dotted\" /* Dotted */]: `0.1 ${strokeWidth * 4}`,\n      [\"dashed\" /* Dashed */]: `${strokeWidth * 4} ${strokeWidth * 4}`\n    }[style.dash];\n    const strokeDashoffset = {\n      [\"draw\" /* Draw */]: \"none\",\n      [\"solid\" /* Solid */]: `none`,\n      [\"dotted\" /* Dotted */]: `0`,\n      [\"dashed\" /* Dashed */]: `0`\n    }[style.dash];\n    const sw = 1 + strokeWidth * 1.5;\n    return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(te, { ref, id: shape.id + \"_svg\", ...events, children: /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)(\"g\", { opacity: isGhost ? GHOSTED_OPACITY : 1, children: [\n      /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(\"path\", { className: shouldFill && isSelected ? \"tl-fill-hitarea\" : \"tl-stroke-hitarea\", d: pathTDSnapshot }),\n      /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(\n        \"path\",\n        {\n          d: pathTDSnapshot,\n          fill: shouldFill ? fill : \"none\",\n          stroke: \"none\",\n          strokeWidth: Math.min(4, strokeWidth * 2),\n          strokeLinejoin: \"round\",\n          strokeLinecap: \"round\",\n          pointerEvents: \"none\"\n        }\n      ),\n      /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(\n        \"path\",\n        {\n          d: pathTDSnapshot,\n          fill: \"none\",\n          stroke,\n          strokeWidth: sw,\n          strokeDasharray,\n          strokeDashoffset,\n          strokeLinejoin: \"round\",\n          strokeLinecap: \"round\",\n          pointerEvents: \"none\"\n        }\n      )\n    ] }) });\n  });\n  Indicator = TDShapeUtil.Indicator(({ shape }) => {\n    const { points } = shape;\n    const pathTDSnapshot = React32.useMemo(() => {\n      return getSolidStrokePathTDSnapshot(shape);\n    }, [points]);\n    const bounds = this.getBounds(shape);\n    const verySmall = bounds.width < 4 && bounds.height < 4;\n    if (verySmall) {\n      return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(\"circle\", { x: bounds.width / 2, y: bounds.height / 2, r: 1 });\n    }\n    return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(\"path\", { d: pathTDSnapshot });\n  });\n  transform = (shape, bounds, { initialShape, scaleX, scaleY }) => {\n    const initialShapeBounds = C3.getFromCache(this.boundsCache, initialShape, () => C3.getBoundsFromPoints(initialShape.points));\n    const points = initialShape.points.map(([x5, y6, r5]) => {\n      return [\n        bounds.width * (scaleX < 0 ? 1 - x5 / initialShapeBounds.width : x5 / initialShapeBounds.width),\n        bounds.height * (scaleY < 0 ? 1 - y6 / initialShapeBounds.height : y6 / initialShapeBounds.height),\n        r5\n      ];\n    });\n    const newBounds = C3.getBoundsFromPoints(shape.points);\n    const point = e.sub([bounds.minX, bounds.minY], [newBounds.minX, newBounds.minY]);\n    return {\n      points,\n      point\n    };\n  };\n  getBounds = (shape) => {\n    const pointsHaveChanged = !this.pointsBoundsCache.has(shape.points);\n    const pointHasChanged = !(this.pointCache[shape.id] === shape.point);\n    if (pointsHaveChanged) {\n      const bounds = C3.getBoundsFromPoints(shape.points);\n      this.pointsBoundsCache.set(shape.points, bounds);\n      this.shapeBoundsCache.set(shape.id, C3.translateBounds(bounds, shape.point));\n      this.pointCache[shape.id] = shape.point;\n    } else if (pointHasChanged && !pointsHaveChanged) {\n      this.pointCache[shape.id] = shape.point;\n      this.shapeBoundsCache.set(shape.id, C3.translateBounds(this.pointsBoundsCache.get(shape.points), shape.point));\n    }\n    return this.shapeBoundsCache.get(shape.id);\n  };\n  shouldRender = (prev, next) => {\n    return next.points !== prev.points || next.style !== prev.style || next.isComplete !== prev.isComplete;\n  };\n  hitTestPoint = (shape, point) => {\n    const ptA = e.sub(point, shape.point);\n    return C3.pointInPolyline(ptA, shape.points);\n  };\n  hitTestLineSegment = (shape, A5, B4) => {\n    const { points, point } = shape;\n    const ptA = e.sub(A5, point);\n    const ptB = e.sub(B4, point);\n    const bounds = this.getBounds(shape);\n    if (bounds.width < 8 && bounds.height < 8) {\n      return e.distanceToLineSegment(A5, B4, C3.getBoundsCenter(bounds)) < 5;\n    }\n    if (ce2(ptA, ptB, bounds)) {\n      for (let i4 = 1; i4 < points.length; i4++) {\n        if (B2(points[i4 - 1], points[i4], ptA, ptB).didIntersect) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n  hitTestBounds = (shape, bounds) => {\n    if (!shape.rotation) {\n      const shapeBounds = this.getBounds(shape);\n      return C3.boundsContain(bounds, shapeBounds) || (C3.boundsContain(shapeBounds, bounds) || Te(shapeBounds, bounds).length > 0) && ye(C3.translateBounds(bounds, e.neg(shape.point)), shape.points).length > 0;\n    }\n    const rBounds = this.getRotatedBounds(shape);\n    const rotatedBounds = C3.getFromCache(this.rotatedCache, shape, () => {\n      const c5 = C3.getBoundsCenter(C3.getBoundsFromPoints(shape.points));\n      return shape.points.map((pt2) => e.rotWith(pt2, c5, shape.rotation || 0));\n    });\n    return C3.boundsContain(bounds, rBounds) || ye(C3.translateBounds(bounds, e.neg(shape.point)), rotatedBounds).length > 0;\n  };\n};\n\n// src/components/Tldraw/state/shapes/EllipseUtil/EllipseUtil.tsx\nvar React35 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/state/shapes/EllipseUtil/components/DashedEllipse.tsx\nvar React33 = __toESM(require(\"react\"));\nvar import_jsx_runtime47 = require(\"react/jsx-runtime\");\nvar DashedEllipse = React33.memo(function DashedEllipse2({ radius, style, isSelected }) {\n  const { stroke, strokeWidth, fill } = getShapeStyle(style);\n  const sw = 1 + strokeWidth * 1.618;\n  const rx = Math.max(0, radius[0] - sw / 2);\n  const ry = Math.max(0, radius[1] - sw / 2);\n  const perimeter = C3.perimeterOfEllipse(rx, ry);\n  const { strokeDasharray, strokeDashoffset } = C3.getPerfectDashProps(perimeter < 64 ? perimeter * 2 : perimeter, strokeWidth * 1.618, style.dash, 4);\n  return /* @__PURE__ */ (0, import_jsx_runtime47.jsxs)(import_jsx_runtime47.Fragment, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(\"ellipse\", { className: style.isFilled || isSelected ? \"tl-fill-hitarea\" : \"tl-stroke-hitarea\", cx: radius[0], cy: radius[1], rx: radius[0], ry: radius[1] }),\n    /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(\n      \"ellipse\",\n      {\n        cx: radius[0],\n        cy: radius[1],\n        rx,\n        ry,\n        fill,\n        stroke,\n        strokeWidth: sw,\n        strokeDasharray,\n        strokeDashoffset,\n        pointerEvents: \"none\",\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\"\n      }\n    )\n  ] });\n});\n\n// src/components/Tldraw/state/shapes/EllipseUtil/components/DrawEllipse.tsx\nvar React34 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/state/shapes/EllipseUtil/ellipseHelpers.ts\nfunction getEllipseStrokePoints(id, radius, style) {\n  const { strokeWidth } = getShapeStyle(style);\n  const getRandom = C3.rng(id);\n  const rx = radius[0] + getRandom() * strokeWidth * 2;\n  const ry = radius[1] + getRandom() * strokeWidth * 2;\n  const perimeter = C3.perimeterOfEllipse(rx, ry);\n  const points = [];\n  const start = Math.PI + Math.PI * getRandom();\n  const extra = Math.abs(getRandom());\n  const count = Math.max(16, perimeter / 10);\n  for (let i4 = 0; i4 < count; i4++) {\n    const t5 = EASINGS.easeInOutSine(i4 / (count + 1));\n    const rads = start * 2 + Math.PI * (2 + extra) * t5;\n    const c5 = Math.cos(rads);\n    const s5 = Math.sin(rads);\n    points.push([rx * c5 + radius[0], ry * s5 + radius[1], t5 + 0.5 + getRandom() / 2]);\n  }\n  return me(points, {\n    size: 1 + strokeWidth * 2,\n    thinning: 0.618,\n    end: { taper: perimeter / 8 },\n    start: { taper: perimeter / 12 },\n    streamline: 0,\n    simulatePressure: true\n  });\n}\nfunction getEllipsePath(id, radius, style) {\n  const { strokeWidth } = getShapeStyle(style);\n  const getRandom = C3.rng(id);\n  const rx = radius[0] + getRandom() * strokeWidth * 2;\n  const ry = radius[1] + getRandom() * strokeWidth * 2;\n  const perimeter = C3.perimeterOfEllipse(rx, ry);\n  return C3.getSvgPathFromStroke(\n    ce(getEllipseStrokePoints(id, radius, style), {\n      size: 2 + strokeWidth * 2,\n      thinning: 0.618,\n      end: { taper: perimeter / 8 },\n      start: { taper: perimeter / 12 },\n      streamline: 0,\n      simulatePressure: true\n    })\n  );\n}\nfunction getEllipseIndicatorPath(id, radius, style) {\n  return C3.getSvgPathFromStrokePoints(getEllipseStrokePoints(id, radius, style));\n}\n\n// src/components/Tldraw/state/shapes/EllipseUtil/components/DrawEllipse.tsx\nvar import_jsx_runtime48 = require(\"react/jsx-runtime\");\nvar DrawEllipse = React34.memo(function DrawEllipse2({ id, radius, style, isSelected }) {\n  const { stroke, strokeWidth, fill } = getShapeStyle(style);\n  const innerPath = getEllipsePath(id, radius, style);\n  return /* @__PURE__ */ (0, import_jsx_runtime48.jsxs)(import_jsx_runtime48.Fragment, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime48.jsx)(\"ellipse\", { className: style.isFilled || isSelected ? \"tl-fill-hitarea\" : \"tl-stroke-hitarea\", cx: radius[0], cy: radius[1], rx: radius[0], ry: radius[1] }),\n    style.isFilled && /* @__PURE__ */ (0, import_jsx_runtime48.jsx)(\"path\", { d: getEllipseIndicatorPath(id, radius, style), stroke: \"none\", fill, pointerEvents: \"none\" }),\n    /* @__PURE__ */ (0, import_jsx_runtime48.jsx)(\"path\", { d: innerPath, fill: stroke, stroke, strokeWidth, pointerEvents: \"none\", strokeLinecap: \"round\", strokeLinejoin: \"round\" })\n  ] });\n});\n\n// src/components/Tldraw/state/shapes/EllipseUtil/EllipseUtil.tsx\nvar import_jsx_runtime49 = require(\"react/jsx-runtime\");\nvar EllipseUtil = class extends TDShapeUtil {\n  type = \"ellipse\" /* Ellipse */;\n  canBind = true;\n  canClone = true;\n  canEdit = true;\n  getShape = (props) => {\n    return C3.deepMerge(\n      {\n        id: \"id\",\n        type: \"ellipse\" /* Ellipse */,\n        name: \"Ellipse\",\n        parentId: \"page\",\n        childIndex: 1,\n        point: [0, 0],\n        radius: [1, 1],\n        rotation: 0,\n        style: defaultStyle,\n        label: \"\",\n        labelPoint: [0.5, 0.5]\n      },\n      props\n    );\n  };\n  Component = TDShapeUtil.Component(\n    ({ shape, isGhost, isSelected, isBinding, isEditing, meta, bounds, events, onShapeChange, onShapeBlur }, ref) => {\n      const { id, radius, style, label = \"\", labelPoint = LABEL_POINT } = shape;\n      const font = getFontStyle(shape.style);\n      const styles = getShapeStyle(style);\n      const strokeWidth = styles.strokeWidth;\n      const sw = 1 + strokeWidth * 1.618;\n      const rx = Math.max(0, radius[0] - sw / 2);\n      const ry = Math.max(0, radius[1] - sw / 2);\n      const Component = style.dash === \"draw\" /* Draw */ ? DrawEllipse : DashedEllipse;\n      const handleLabelChange = React35.useCallback((label2) => onShapeChange?.({ id, label: label2 }), [onShapeChange]);\n      return /* @__PURE__ */ (0, import_jsx_runtime49.jsxs)(FullWrapper2, { ref, ...events, children: [\n        /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(\n          TextLabel,\n          {\n            isEditing,\n            onChange: handleLabelChange,\n            onBlur: onShapeBlur,\n            font,\n            text: label,\n            color: styles.stroke,\n            offsetX: (labelPoint[0] - 0.5) * bounds.width,\n            offsetY: (labelPoint[1] - 0.5) * bounds.height\n          }\n        ),\n        /* @__PURE__ */ (0, import_jsx_runtime49.jsxs)(te, { id: shape.id + \"_svg\", opacity: isGhost ? GHOSTED_OPACITY : 1, children: [\n          isBinding && /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(\"ellipse\", { className: \"tl-binding-indicator\", cx: radius[0], cy: radius[1], rx, ry, strokeWidth: this.bindingDistance }),\n          /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(Component, { id, radius, style, isSelected })\n        ] })\n      ] });\n    }\n  );\n  Indicator = TDShapeUtil.Indicator(({ shape }) => {\n    const { id, radius, style } = shape;\n    const styles = getShapeStyle(style);\n    const strokeWidth = styles.strokeWidth;\n    const sw = 1 + strokeWidth * 1.618;\n    const rx = Math.max(0, radius[0] - sw / 2);\n    const ry = Math.max(0, radius[1] - sw / 2);\n    return style.dash === \"draw\" /* Draw */ ? /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(\"path\", { d: getEllipseIndicatorPath(id, radius, style) }) : /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(\"ellipse\", { cx: radius[0], cy: radius[1], rx, ry });\n  });\n  hitTestPoint = (shape, point) => {\n    return C3.pointInBounds(point, this.getRotatedBounds(shape)) && C3.pointInEllipse(point, this.getCenter(shape), shape.radius[0], shape.radius[1], shape.rotation || 0);\n  };\n  hitTestLineSegment = (shape, A5, B4) => {\n    return y(A5, B4, this.getCenter(shape), shape.radius[0], shape.radius[1], shape.rotation || 0).didIntersect;\n  };\n  getBounds = (shape) => {\n    return C3.getFromCache(this.boundsCache, shape, () => {\n      return C3.getRotatedEllipseBounds(shape.point[0], shape.point[1], shape.radius[0], shape.radius[1], 0);\n    });\n  };\n  getRotatedBounds = (shape) => {\n    return C3.getRotatedEllipseBounds(shape.point[0], shape.point[1], shape.radius[0], shape.radius[1], shape.rotation);\n  };\n  hitTestBounds = (shape, bounds) => {\n    const shapeBounds = this.getBounds(shape);\n    return C3.boundsContained(shapeBounds, bounds) || pe2(this.getCenter(shape), shape.radius[0], shape.radius[1], shape.rotation || 0, bounds).length > 0;\n  };\n  shouldRender = (prev, next) => {\n    return next.radius !== prev.radius || next.style !== prev.style || next.label !== prev.label;\n  };\n  getCenter = (shape) => {\n    return e.add(shape.point, shape.radius);\n  };\n  getBindingPoint = (shape, fromShape, point, origin, direction, bindAnywhere) => {\n    {\n      const expandedBounds = this.getExpandedBounds(shape);\n      const center = this.getCenter(shape);\n      let bindingPoint;\n      let distance;\n      if (!C3.pointInEllipse(point, center, shape.radius[0] + this.bindingDistance, shape.radius[1] + this.bindingDistance)) {\n        return;\n      }\n      if (bindAnywhere) {\n        if (e.dist(point, this.getCenter(shape)) < 12) {\n          bindingPoint = [0.5, 0.5];\n        } else {\n          bindingPoint = e.divV(e.sub(point, [expandedBounds.minX, expandedBounds.minY]), [expandedBounds.width, expandedBounds.height]);\n        }\n        distance = 0;\n      } else {\n        let intersection = F(origin, direction, center, shape.radius[0], shape.radius[1], shape.rotation || 0).points.sort(\n          (a7, b6) => e.dist(a7, origin) - e.dist(b6, origin)\n        )[0];\n        if (!intersection) {\n          intersection = y(point, center, center, shape.radius[0], shape.radius[1], shape.rotation || 0).points.sort(\n            (a7, b6) => e.dist(a7, point) - e.dist(b6, point)\n          )[0];\n        }\n        if (!intersection) {\n          return;\n        }\n        const anchor = e.med(point, intersection);\n        if (e.distanceToLineSegment(point, anchor, this.getCenter(shape)) < 12) {\n          bindingPoint = [0.5, 0.5];\n        } else {\n          bindingPoint = e.divV(e.sub(anchor, [expandedBounds.minX, expandedBounds.minY]), [expandedBounds.width, expandedBounds.height]);\n        }\n        if (C3.pointInEllipse(point, center, shape.radius[0], shape.radius[1], shape.rotation || 0)) {\n          distance = this.bindingDistance / 2;\n        } else {\n          const innerIntersection = y(point, center, center, shape.radius[0], shape.radius[1], shape.rotation || 0).points[0];\n          if (!innerIntersection)\n            return;\n          distance = Math.max(this.bindingDistance / 2, e.dist(point, innerIntersection));\n        }\n      }\n      return {\n        point: bindingPoint,\n        distance\n      };\n    }\n  };\n  transform = (shape, bounds, { scaleX, scaleY, initialShape }) => {\n    const { rotation = 0 } = initialShape;\n    return {\n      point: [bounds.minX, bounds.minY],\n      radius: [bounds.width / 2, bounds.height / 2],\n      rotation: scaleX < 0 && scaleY >= 0 || scaleY < 0 && scaleX >= 0 ? -(rotation || 0) : rotation || 0\n    };\n  };\n  transformSingle = (shape, bounds) => {\n    return {\n      point: e.toFixed([bounds.minX, bounds.minY]),\n      radius: e.div([bounds.width, bounds.height], 2)\n    };\n  };\n};\nvar FullWrapper2 = styled(\"div\", { width: \"100%\", height: \"100%\" });\n\n// src/components/Tldraw/state/shapes/GroupUtil/GroupUtil.tsx\nvar import_jsx_runtime50 = require(\"react/jsx-runtime\");\nvar GroupUtil = class extends TDShapeUtil {\n  type = \"group\" /* Group */;\n  canBind = true;\n  getShape = (props) => {\n    return C3.deepMerge(\n      {\n        id: \"id\",\n        type: \"group\" /* Group */,\n        name: \"Group\",\n        parentId: \"page\",\n        childIndex: 1,\n        point: [0, 0],\n        size: [100, 100],\n        rotation: 0,\n        children: [],\n        style: defaultStyle\n      },\n      props\n    );\n  };\n  Component = TDShapeUtil.Component(({ shape, isBinding, isGhost, isHovered, isSelected, events }, ref) => {\n    const { id, size } = shape;\n    const sw = 2;\n    const w7 = Math.max(0, size[0] - sw / 2);\n    const h6 = Math.max(0, size[1] - sw / 2);\n    const strokes2 = [\n      [[sw / 2, sw / 2], [w7, sw / 2], w7 - sw / 2],\n      [[w7, sw / 2], [w7, h6], h6 - sw / 2],\n      [[w7, h6], [sw / 2, h6], w7 - sw / 2],\n      [[sw / 2, h6], [sw / 2, sw / 2], h6 - sw / 2]\n    ];\n    const paths = strokes2.map(([start, end], i4) => {\n      return /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(\"line\", { x1: start[0], y1: start[1], x2: end[0], y2: end[1] }, id + \"_\" + i4);\n    });\n    return /* @__PURE__ */ (0, import_jsx_runtime50.jsxs)(te, { ref, ...events, children: [\n      isBinding && /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(\"rect\", { className: \"tl-binding-indicator\", strokeWidth: this.bindingDistance }),\n      /* @__PURE__ */ (0, import_jsx_runtime50.jsxs)(\"g\", { opacity: isGhost ? GHOSTED_OPACITY : 1, children: [\n        /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(\"rect\", { x: 0, y: 0, width: size[0], height: size[1], fill: \"transparent\", pointerEvents: \"all\" }),\n        /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(ScaledLines, { stroke: \"black\" /* Black */, opacity: isHovered || isSelected ? 1 : 0, strokeLinecap: \"round\", pointerEvents: \"stroke\", children: paths })\n      ] })\n    ] });\n  });\n  Indicator = TDShapeUtil.Indicator(({ shape }) => {\n    const { id, size } = shape;\n    const sw = 2;\n    const w7 = Math.max(0, size[0] - sw / 2);\n    const h6 = Math.max(0, size[1] - sw / 2);\n    const strokes2 = [\n      [[sw / 2, sw / 2], [w7, sw / 2], w7 - sw / 2],\n      [[w7, sw / 2], [w7, h6], h6 - sw / 2],\n      [[w7, h6], [sw / 2, h6], w7 - sw / 2],\n      [[sw / 2, h6], [sw / 2, sw / 2], h6 - sw / 2]\n    ];\n    const paths = strokes2.map(([start, end], i4) => {\n      return /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(\"line\", { x1: start[0], y1: start[1], x2: end[0], y2: end[1] }, id + \"_\" + i4);\n    });\n    return /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(ScaledLines, { strokeLinecap: \"round\", pointerEvents: \"stroke\", children: paths });\n  });\n  getBounds = (shape) => {\n    return getBoundsRectangle(shape, this.boundsCache);\n  };\n  shouldRender = (prev, next) => {\n    return next.size !== prev.size || next.style !== prev.style;\n  };\n};\nvar ScaledLines = styled(\"g\", {\n  strokeWidth: \"calc(1.5px * var(--tl-scale))\",\n  strokeDasharray: `calc(1px * var(--tl-scale)), calc(3px * var(--tl-scale))`\n});\n\n// src/components/Tldraw/state/shapes/ImageUtil/ImageUtil.tsx\nvar React36 = __toESM(require(\"react\"));\nvar import_jsx_runtime51 = require(\"react/jsx-runtime\");\nvar ImageUtil = class extends TDShapeUtil {\n  type = \"image\" /* Image */;\n  canBind = true;\n  canClone = true;\n  isAspectRatioLocked = true;\n  showCloneHandles = false;\n  getShape = (props) => {\n    return C3.deepMerge(\n      {\n        id: \"image\",\n        type: \"image\" /* Image */,\n        name: \"Image\",\n        parentId: \"page\",\n        childIndex: 1,\n        point: [0, 0],\n        size: [1, 1],\n        rotation: 0,\n        style: { ...defaultStyle, isFilled: true },\n        assetId: \"assetId\"\n      },\n      props\n    );\n  };\n  Component = TDShapeUtil.Component(({ shape, asset = { src: \"\" }, isBinding, isGhost, meta, events, onShapeChange }, ref) => {\n    const { size, style } = shape;\n    const { bindingDistance } = this;\n    const rImage = React36.useRef(null);\n    const rWrapper = React36.useRef(null);\n    React36.useLayoutEffect(() => {\n      const wrapper = rWrapper.current;\n      if (!wrapper)\n        return;\n      const [width, height] = size;\n      wrapper.style.width = `${width}px`;\n      wrapper.style.height = `${height}px`;\n    }, [size]);\n    return /* @__PURE__ */ (0, import_jsx_runtime51.jsxs)(Xs, { ref, ...events, children: [\n      isBinding && /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(\n        \"div\",\n        {\n          className: \"tl-binding-indicator\",\n          style: {\n            position: \"absolute\",\n            top: `calc(${-bindingDistance}px * var(--tl-zoom))`,\n            left: `calc(${-bindingDistance}px * var(--tl-zoom))`,\n            width: `calc(100% + ${bindingDistance * 2}px * var(--tl-zoom))`,\n            height: `calc(100% + ${bindingDistance * 2}px * var(--tl-zoom))`,\n            backgroundColor: \"var(--tl-selectFill)\"\n          }\n        }\n      ),\n      /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(\n        Wrapper,\n        {\n          ref: rWrapper,\n          isFilled: style.isFilled,\n          isGhost,\n          children: /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(ImageElement, { id: shape.id + \"_image\", ref: rImage, src: asset.src, alt: \"tl_image_asset\", draggable: false })\n        }\n      )\n    ] });\n  });\n  Indicator = TDShapeUtil.Indicator(({ shape }) => {\n    const {\n      size: [width, height]\n    } = shape;\n    return /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(\"rect\", { x: 0, y: 0, rx: 2, ry: 2, width: Math.max(1, width), height: Math.max(1, height) });\n  });\n  getBounds = (shape) => {\n    return getBoundsRectangle(shape, this.boundsCache);\n  };\n  shouldRender = (prev, next) => {\n    return next.size !== prev.size || next.style !== prev.style;\n  };\n  transform = transformRectangle;\n  transformSingle = transformSingleRectangle;\n  getSvgElement = (shape) => {\n    const bounds = this.getBounds(shape);\n    const elm = document.createElementNS(\"http://www.w3.org/2000/svg\", \"image\");\n    elm.setAttribute(\"width\", `${bounds.width}`);\n    elm.setAttribute(\"height\", `${bounds.height}`);\n    elm.setAttribute(\"xmlns:xlink\", `http://www.w3.org/1999/xlink`);\n    return elm;\n  };\n};\nvar Wrapper = re2(\"div\", {\n  pointerEvents: \"all\",\n  position: \"relative\",\n  fontFamily: \"sans-serif\",\n  fontSize: \"2em\",\n  height: \"100%\",\n  width: \"100%\",\n  borderRadius: \"3px\",\n  perspective: \"800px\",\n  overflow: \"hidden\",\n  p: {\n    userSelect: \"none\"\n  },\n  img: {\n    userSelect: \"none\"\n  },\n  variants: {\n    isGhost: {\n      false: { opacity: 1 },\n      true: { transition: \"opacity .2s\", opacity: GHOSTED_OPACITY }\n    },\n    isFilled: {\n      true: {},\n      false: {}\n    }\n  },\n  compoundVariants: [\n    {\n      isFilled: true,\n      css: {\n        boxShadow: \"2px 3px 12px -2px rgba(0,0,0,.3), 1px 1px 4px rgba(0,0,0,.3), 1px 1px 2px rgba(0,0,0,.3)\"\n      }\n    },\n    {\n      isFilled: true,\n      css: {\n        boxShadow: \"2px 3px 12px -2px rgba(0,0,0,.2), 1px 1px 4px rgba(0,0,0,.16),  1px 1px 2px rgba(0,0,0,.16)\"\n      }\n    }\n  ]\n});\nvar ImageElement = re2(\"img\", {\n  position: \"absolute\",\n  top: 0,\n  left: 0,\n  width: \"100%\",\n  height: \"100%\",\n  maxWidth: \"100%\",\n  minWidth: \"100%\",\n  pointerEvents: \"none\",\n  objectFit: \"cover\",\n  userSelect: \"none\",\n  borderRadius: 2\n});\n\n// src/components/Tldraw/state/shapes/RectangleUtil/RectangleUtil.tsx\nvar React39 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/state/shapes/RectangleUtil/components/BindingIndicator.tsx\nvar import_jsx_runtime52 = require(\"react/jsx-runtime\");\nfunction BindingIndicator({ strokeWidth, size }) {\n  return /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(\n    \"rect\",\n    {\n      className: \"tl-binding-indicator\",\n      x: strokeWidth,\n      y: strokeWidth,\n      width: Math.max(0, size[0] - strokeWidth / 2),\n      height: Math.max(0, size[1] - strokeWidth / 2),\n      strokeWidth: BINDING_DISTANCE * 2\n    }\n  );\n}\n\n// src/components/Tldraw/state/shapes/RectangleUtil/components/DashedRectangle.tsx\nvar React37 = __toESM(require(\"react\"));\nvar import_jsx_runtime53 = require(\"react/jsx-runtime\");\nvar DashedRectangle = React37.memo(function DashedRectangle2({ id, style, size, isSelected }) {\n  const { stroke, strokeWidth, fill } = getShapeStyle(style);\n  const sw = 1 + strokeWidth * 1.618;\n  const w7 = Math.max(0, size[0] - sw / 2);\n  const h6 = Math.max(0, size[1] - sw / 2);\n  const strokes2 = [\n    [[sw / 2, sw / 2], [w7, sw / 2], w7 - sw / 2],\n    [[w7, sw / 2], [w7, h6], h6 - sw / 2],\n    [[w7, h6], [sw / 2, h6], w7 - sw / 2],\n    [[sw / 2, h6], [sw / 2, sw / 2], h6 - sw / 2]\n  ];\n  const paths = strokes2.map(([start, end, length], i4) => {\n    const { strokeDasharray, strokeDashoffset } = C3.getPerfectDashProps(length, strokeWidth * 1.618, style.dash);\n    return /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(\"line\", { x1: start[0], y1: start[1], x2: end[0], y2: end[1], strokeDasharray, strokeDashoffset }, id + \"_\" + i4);\n  });\n  return /* @__PURE__ */ (0, import_jsx_runtime53.jsxs)(import_jsx_runtime53.Fragment, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(\n      \"rect\",\n      {\n        className: isSelected || style.isFilled ? \"tl-fill-hitarea\" : \"tl-stroke-hitarea\",\n        x: sw / 2,\n        y: sw / 2,\n        width: w7,\n        height: h6,\n        strokeWidth: BINDING_DISTANCE\n      }\n    ),\n    style.isFilled && /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(\"rect\", { x: sw / 2, y: sw / 2, width: w7, height: h6, fill, pointerEvents: \"none\" }),\n    /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(\"g\", { pointerEvents: \"none\", stroke, strokeWidth: sw, strokeLinecap: \"round\", children: paths })\n  ] });\n});\n\n// src/components/Tldraw/state/shapes/RectangleUtil/components/DrawRectangle.tsx\nvar React38 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/state/shapes/RectangleUtil/rectangleHelpers.ts\nfunction getRectangleDrawPoints(id, style, size) {\n  const styles = getShapeStyle(style);\n  const getRandom = C3.rng(id);\n  const sw = styles.strokeWidth;\n  const w7 = Math.max(0, size[0]);\n  const h6 = Math.max(0, size[1]);\n  const offsets = Array.from({ length: 4 }).map(() => {\n    return [getRandom() * sw * 0.75, getRandom() * sw * 0.75];\n  });\n  const tl = p.add([sw / 2, sw / 2], offsets[0]);\n  const tr = p.add([w7 - sw / 2, sw / 2], offsets[1]);\n  const br = p.add([w7 - sw / 2, h6 - sw / 2], offsets[2]);\n  const bl = p.add([sw / 2, h6 - sw / 2], offsets[3]);\n  const rm = Math.round(Math.abs(getRandom() * 2 * 4));\n  const rx = Math.min(w7 / 4, sw * 2);\n  const ry = Math.min(h6 / 4, sw * 2);\n  const px = Math.max(8, Math.floor(w7 / 16));\n  const py = Math.max(8, Math.floor(h6 / 16));\n  const lines = C3.rotateArray(\n    [\n      p.pointsBetween(p.add(tl, [rx, 0]), p.sub(tr, [rx, 0]), px),\n      p.pointsBetween(p.add(tr, [0, ry]), p.sub(br, [0, ry]), py),\n      p.pointsBetween(p.sub(br, [rx, 0]), p.add(bl, [rx, 0]), px),\n      p.pointsBetween(p.sub(bl, [0, ry]), p.add(tl, [0, ry]), py)\n    ],\n    rm\n  );\n  const points = [...lines.flat(), ...lines[0]].slice(5, Math.floor((rm % 2 === 0 ? px : py) / -2) + 3);\n  return {\n    points\n  };\n}\nfunction getDrawStrokeInfo(id, style, size) {\n  const { points } = getRectangleDrawPoints(id, style, size);\n  const { strokeWidth } = getShapeStyle(style);\n  const options = {\n    size: strokeWidth,\n    thinning: 0.65,\n    streamline: 0.3,\n    smoothing: 1,\n    simulatePressure: false,\n    last: true\n  };\n  return { points, options };\n}\nfunction getRectanglePath(id, style, size) {\n  const { points, options } = getDrawStrokeInfo(id, style, size);\n  const stroke = _e(points, options);\n  return C3.getSvgPathFromStroke(stroke);\n}\nfunction getRectangleIndicatorPathTDSnapshot(id, style, size) {\n  const { points, options } = getDrawStrokeInfo(id, style, size);\n  return C3.getSvgPathFromStrokePoints(me(points, options));\n}\n\n// src/components/Tldraw/state/shapes/RectangleUtil/components/DrawRectangle.tsx\nvar import_jsx_runtime54 = require(\"react/jsx-runtime\");\nvar DrawRectangle = React38.memo(function DrawRectangle2({ id, style, size, isSelected }) {\n  const { isFilled } = style;\n  const { stroke, strokeWidth, fill } = getShapeStyle(style);\n  const pathTDSnapshot = getRectanglePath(id, style, size);\n  const innerPath = getRectangleIndicatorPathTDSnapshot(id, style, size);\n  return /* @__PURE__ */ (0, import_jsx_runtime54.jsxs)(import_jsx_runtime54.Fragment, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(\"path\", { className: style.isFilled || isSelected ? \"tl-fill-hitarea\" : \"tl-stroke-hitarea\", d: innerPath }),\n    isFilled && /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(\"path\", { d: innerPath, fill, pointerEvents: \"none\" }),\n    /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(\"path\", { d: pathTDSnapshot, fill: stroke, stroke, strokeWidth, pointerEvents: \"none\" })\n  ] });\n});\n\n// src/components/Tldraw/state/shapes/RectangleUtil/RectangleUtil.tsx\nvar import_jsx_runtime55 = require(\"react/jsx-runtime\");\nvar RectangleUtil = class extends TDShapeUtil {\n  type = \"rectangle\" /* Rectangle */;\n  canBind = true;\n  canClone = true;\n  canEdit = true;\n  getShape = (props) => {\n    return C3.deepMerge(\n      {\n        id: \"id\",\n        type: \"rectangle\" /* Rectangle */,\n        name: \"Rectangle\",\n        parentId: \"page\",\n        childIndex: 1,\n        point: [0, 0],\n        size: [1, 1],\n        rotation: 0,\n        style: defaultStyle,\n        label: \"\",\n        labelPoint: [0.5, 0.5]\n      },\n      props\n    );\n  };\n  Component = TDShapeUtil.Component(\n    ({ shape, isEditing, isBinding, isSelected, isGhost, meta, bounds, events, onShapeBlur, onShapeChange }, ref) => {\n      const { id, size, style, label = \"\", labelPoint = LABEL_POINT } = shape;\n      const font = getFontStyle(style);\n      const styles = getShapeStyle(style);\n      const Component = style.dash === \"draw\" /* Draw */ ? DrawRectangle : DashedRectangle;\n      const handleLabelChange = React39.useCallback((label2) => onShapeChange?.({ id, label: label2 }), [onShapeChange]);\n      return /* @__PURE__ */ (0, import_jsx_runtime55.jsxs)(FullWrapper3, { ref, ...events, children: [\n        /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(\n          TextLabel,\n          {\n            isEditing,\n            onChange: handleLabelChange,\n            onBlur: onShapeBlur,\n            font,\n            text: label,\n            color: styles.stroke,\n            offsetX: (labelPoint[0] - 0.5) * bounds.width,\n            offsetY: (labelPoint[1] - 0.5) * bounds.height\n          }\n        ),\n        /* @__PURE__ */ (0, import_jsx_runtime55.jsxs)(te, { id: shape.id + \"_svg\", opacity: isGhost ? GHOSTED_OPACITY : 1, children: [\n          isBinding && /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(BindingIndicator, { strokeWidth: styles.strokeWidth, size }),\n          /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(Component, { id, style, size, isSelected })\n        ] })\n      ] });\n    }\n  );\n  Indicator = TDShapeUtil.Indicator(({ shape }) => {\n    const { id, style, size } = shape;\n    const styles = getShapeStyle(style, false);\n    const sw = styles.strokeWidth;\n    if (style.dash === \"draw\" /* Draw */) {\n      return /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(\"path\", { d: getRectangleIndicatorPathTDSnapshot(id, style, size) });\n    }\n    return /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(\"rect\", { x: sw, y: sw, rx: 1, ry: 1, width: Math.max(1, size[0] - sw * 2), height: Math.max(1, size[1] - sw * 2) });\n  });\n  getBounds = (shape) => {\n    return getBoundsRectangle(shape, this.boundsCache);\n  };\n  shouldRender = (prev, next) => {\n    return next.size !== prev.size || next.style !== prev.style || next.label !== prev.label;\n  };\n  transform = transformRectangle;\n  transformSingle = transformSingleRectangle;\n};\nvar FullWrapper3 = styled(\"div\", { width: \"100%\", height: \"100%\" });\n\n// src/components/Tldraw/state/shapes/StickyUtil/StickyUtil.tsx\nvar React40 = __toESM(require(\"react\"));\nvar import_tw_react = __toESM(require_tw_react());\nvar import_jsx_runtime56 = require(\"react/jsx-runtime\");\nvar StickyUtil = class extends TDShapeUtil {\n  type = \"sticky\" /* Sticky */;\n  canBind = true;\n  canEdit = true;\n  canClone = true;\n  getShape = (props) => {\n    return C3.deepMerge(\n      {\n        id: \"id\",\n        type: \"sticky\" /* Sticky */,\n        name: \"Sticky\",\n        parentId: \"page\",\n        childIndex: 1,\n        point: [0, 0],\n        size: [300, 300],\n        text: \"\",\n        rotation: 0,\n        style: defaultTextStyle\n      },\n      props\n    );\n  };\n  Component = TDShapeUtil.Component(({ shape, meta, events, isGhost, isBinding, isEditing, onShapeBlur, onShapeChange }, reference) => {\n    const font = getStickyFontStyle(shape.style);\n    const { color, fill } = getStickyShapeStyle(shape.style);\n    const rContainer = React40.useRef(null);\n    const rTextArea = React40.useRef(null);\n    const rRenderedText = React40.useRef(null);\n    const rIsMounted = React40.useRef(false);\n    const handlePointerDown = React40.useCallback((event) => {\n      event.stopPropagation();\n    }, []);\n    const astNode = React40.useMemo(() => {\n      const childTree = $tw.wiki.parseText(\"text/vnd.tiddlywiki\", shape.text).tree;\n      return { type: \"tiddler\", children: childTree };\n    }, [shape.text]);\n    (0, import_tw_react.useWidget)(astNode, rRenderedText, { skip: isEditing });\n    const onChange = React40.useCallback(\n      (text) => {\n        onShapeChange?.({\n          id: shape.id,\n          type: shape.type,\n          text: TLDR.normalizeText(text)\n        });\n      },\n      [onShapeChange, shape.id, shape.type]\n    );\n    const handleTextChange = React40.useCallback(\n      (event) => {\n        onChange(event.currentTarget.value);\n      },\n      [onChange]\n    );\n    const handleKeyDown = React40.useCallback(\n      (event) => {\n        if (event.key === \"Escape\") {\n          event.preventDefault();\n          event.stopPropagation();\n          onShapeBlur?.();\n          return;\n        }\n        if (event.key === \"Tab\" && shape.text.length === 0) {\n          event.preventDefault();\n          return;\n        }\n        if (!(event.key === \"Meta\" || event.metaKey)) {\n          event.stopPropagation();\n        } else if (event.key === \"z\" && event.metaKey) {\n          if (event.shiftKey) {\n            document.execCommand(\"redo\", false);\n          } else {\n            document.execCommand(\"undo\", false);\n          }\n          event.stopPropagation();\n          event.preventDefault();\n          return;\n        }\n        if ((event.metaKey || event.ctrlKey) && event.key === \"=\") {\n          event.preventDefault();\n        }\n        if (event.key === \"Tab\") {\n          event.preventDefault();\n          if (event.shiftKey) {\n            TextAreaUtils.unindent(event.currentTarget);\n          } else {\n            TextAreaUtils.indent(event.currentTarget);\n          }\n          onShapeChange?.({ ...shape, text: TLDR.normalizeText(event.currentTarget.value) });\n        }\n      },\n      [shape, onShapeBlur, onShapeChange]\n    );\n    const handleBlur = React40.useCallback(\n      (event) => {\n        event.currentTarget.setSelectionRange(0, 0);\n        onShapeBlur?.();\n      },\n      [onShapeBlur]\n    );\n    const handleFocus = React40.useCallback(\n      (event) => {\n        if (!isEditing)\n          return;\n        if (!rIsMounted.current)\n          return;\n        event.currentTarget.select();\n      },\n      [isEditing]\n    );\n    React40.useEffect(() => {\n      if (isEditing) {\n        rIsMounted.current = true;\n        const elm = rTextArea.current;\n        elm.focus();\n        elm.select();\n      }\n    }, [isEditing]);\n    const style = {\n      font,\n      color,\n      textShadow: `0.5px 0.5px 2px rgba(255, 255, 255,.5)`\n    };\n    const getClickedTWElement = React40.useCallback((event) => {\n      const buttonOrLinkInWikiText = event.target.querySelectorAll(\"a,button\");\n      const clickedElement = Array.from(buttonOrLinkInWikiText).find((element) => {\n        const rect = element.getBoundingClientRect();\n        return event.clientX > rect.x && event.clientX < rect.x + rect.width && event.clientY > rect.y && event.clientY < rect.y + rect.height;\n      });\n      return clickedElement;\n    }, []);\n    const onPointerUp = React40.useCallback(\n      (event) => {\n        const clickedElement = getClickedTWElement(event);\n        if (clickedElement !== void 0) {\n          event.preventDefault();\n          event.stopPropagation();\n          const newClickEvent = new MouseEvent(\"click\", { ...event.nativeEvent });\n          clickedElement.dispatchEvent(newClickEvent);\n        }\n        events.onPointerUp(event);\n      },\n      [events, getClickedTWElement]\n    );\n    return /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(Xs, { ref: reference, ...events, onPointerUp, children: /* @__PURE__ */ (0, import_jsx_runtime56.jsxs)(StyledStickyContainer, { ref: rContainer, isGhost, style: { backgroundColor: fill, ...style }, children: [\n      isBinding && /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(\n        \"div\",\n        {\n          className: \"tl-binding-indicator\",\n          style: {\n            position: \"absolute\",\n            top: -this.bindingDistance,\n            left: -this.bindingDistance,\n            width: `calc(100% + ${this.bindingDistance * 2}px)`,\n            height: `calc(100% + ${this.bindingDistance * 2}px)`,\n            backgroundColor: \"var(--tl-selectFill)\"\n          }\n        }\n      ),\n      /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(StyledText2, { ref: rRenderedText, isEditing, alignment: shape.style.textAlign }),\n      isEditing && /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(\n        StyledTextArea,\n        {\n          className: STICKY_TEXT_AREA_CLASS_NAME,\n          ref: rTextArea,\n          onPointerDown: handlePointerDown,\n          value: shape.text,\n          onChange: handleTextChange,\n          onKeyDown: handleKeyDown,\n          onFocus: handleFocus,\n          onBlur: handleBlur,\n          tabIndex: -1,\n          autoComplete: \"false\",\n          autoCapitalize: \"false\",\n          autoCorrect: \"false\",\n          autoSave: \"false\",\n          autoFocus: true,\n          spellCheck: true,\n          alignment: shape.style.textAlign,\n          onContextMenu: stopPropagation,\n          onCopy: stopPropagation,\n          onPaste: stopPropagation,\n          onCut: stopPropagation\n        }\n      )\n    ] }) });\n  });\n  Indicator = TDShapeUtil.Indicator(({ shape }) => {\n    const {\n      size: [width, height]\n    } = shape;\n    return /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(\"rect\", { x: 0, y: 0, rx: 3, ry: 3, width: Math.max(1, width), height: Math.max(1, height) });\n  });\n  getBounds = (shape) => {\n    return getBoundsRectangle(shape, this.boundsCache);\n  };\n  shouldRender = (previous, next) => {\n    return next.size !== previous.size || next.style !== previous.style || next.text !== previous.text;\n  };\n  transform = transformRectangle;\n  transformSingle = transformSingleRectangle;\n  getSvgElement = (shape) => {\n    const bounds = this.getBounds(shape);\n    const style = getStickyShapeStyle(shape.style);\n    const fontSize = getStickyFontSize(shape.style.size) * (shape.style.scale ?? 1);\n    const fontFamily = getFontFace(shape.style.font).slice(1, -1);\n    const textAlign = shape.style.textAlign ?? \"start\" /* Start */;\n    const textElm = getTextSvgElement(shape.text, fontSize, fontFamily, textAlign, bounds.width - PADDING * 2, true);\n    textElm.setAttribute(\"fill\", style.color);\n    textElm.setAttribute(\"transform\", `translate(${PADDING}, ${PADDING})`);\n    const g6 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    const rect = document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n    rect.setAttribute(\"width\", String(bounds.width));\n    rect.setAttribute(\"height\", String(bounds.height));\n    rect.setAttribute(\"fill\", style.fill);\n    rect.setAttribute(\"rx\", \"3\");\n    rect.setAttribute(\"ry\", \"3\");\n    g6.appendChild(rect);\n    g6.appendChild(textElm);\n    return g6;\n  };\n};\nvar PADDING = 16;\nvar StyledStickyContainer = styled(\"div\", {\n  pointerEvents: \"all\",\n  position: \"relative\",\n  backgroundColor: \"transparent\",\n  height: \"100%\",\n  width: \"100%\",\n  padding: `${PADDING}px`,\n  borderRadius: \"3px\",\n  perspective: \"800px\",\n  variants: {\n    isGhost: {\n      false: { opacity: 1 },\n      true: { transition: \"opacity .2s\", opacity: GHOSTED_OPACITY }\n    }\n  }\n});\nvar commonTextWrapping = {\n  whiteSpace: \"pre-wrap\",\n  overflowWrap: \"break-word\",\n  letterSpacing: LETTER_SPACING\n};\nvar StyledText2 = styled(\"div\", {\n  position: \"absolute\",\n  top: PADDING,\n  left: PADDING,\n  width: `calc(100% - ${PADDING * 2}px)`,\n  height: \"fit-content\",\n  font: \"inherit\",\n  pointerEvents: \"none\",\n  userSelect: \"none\",\n  variants: {\n    isEditing: {\n      true: {\n        opacity: 0\n      },\n      false: {\n        opacity: 1\n      }\n    },\n    alignment: {\n      [\"start\" /* Start */]: {\n        textAlign: \"left\"\n      },\n      [\"middle\" /* Middle */]: {\n        textAlign: \"center\"\n      },\n      [\"end\" /* End */]: {\n        textAlign: \"right\"\n      },\n      [\"justify\" /* Justify */]: {\n        textAlign: \"justify\"\n      }\n    }\n  },\n  ...commonTextWrapping\n});\nvar StyledTextArea = styled(\"textarea\", {\n  width: \"100%\",\n  height: \"100%\",\n  border: \"none\",\n  overflow: \"hidden\",\n  background: \"none\",\n  outline: \"none\",\n  textAlign: \"left\",\n  font: \"inherit\",\n  padding: 0,\n  color: \"#333\",\n  verticalAlign: \"top\",\n  resize: \"none\",\n  caretColor: \"black\",\n  ...commonTextWrapping,\n  variants: {\n    alignment: {\n      [\"start\" /* Start */]: {\n        textAlign: \"left\"\n      },\n      [\"middle\" /* Middle */]: {\n        textAlign: \"center\"\n      },\n      [\"end\" /* End */]: {\n        textAlign: \"right\"\n      },\n      [\"justify\" /* Justify */]: {\n        textAlign: \"justify\"\n      }\n    }\n  },\n  \"&:focus\": {\n    outline: \"none\",\n    border: \"none\"\n  }\n});\n\n// src/components/Tldraw/state/shapes/TextUtil/TextUtil.tsx\nvar React41 = __toESM(require(\"react\"));\nvar import_jsx_runtime57 = require(\"react/jsx-runtime\");\nvar TextUtil = class extends TDShapeUtil {\n  type = \"text\" /* Text */;\n  isAspectRatioLocked = true;\n  canEdit = true;\n  canBind = true;\n  canClone = true;\n  bindingDistance = BINDING_DISTANCE / 2;\n  getShape = (props) => {\n    return C3.deepMerge(\n      {\n        id: \"id\",\n        type: \"text\" /* Text */,\n        name: \"Text\",\n        parentId: \"page\",\n        childIndex: 1,\n        point: [0, 0],\n        rotation: 0,\n        text: \" \",\n        style: defaultTextStyle\n      },\n      props\n    );\n  };\n  texts = /* @__PURE__ */ new Map();\n  Component = TDShapeUtil.Component(({ shape, isBinding, isGhost, isEditing, onShapeBlur, onShapeChange, meta, events }, ref) => {\n    const { text, style } = shape;\n    const styles = getShapeStyle(style);\n    const font = getFontStyle(shape.style);\n    const rInput = React41.useRef(null);\n    const rIsMounted = React41.useRef(false);\n    const rEditedText = React41.useRef(text);\n    React41.useLayoutEffect(() => {\n      if (text !== rEditedText.current) {\n        let delta = [0, 0];\n        this.texts.set(shape.id, text);\n        const currentBounds = this.getBounds(shape);\n        const nextBounds = this.getBounds(shape);\n        switch (shape.style.textAlign) {\n          case \"start\" /* Start */: {\n            break;\n          }\n          case \"middle\" /* Middle */: {\n            delta = e.div([nextBounds.width - currentBounds.width, 0], 2);\n            break;\n          }\n          case \"end\" /* End */: {\n            delta = [nextBounds.width - currentBounds.width, 0];\n            break;\n          }\n        }\n        rEditedText.current = text;\n        onShapeChange?.({\n          ...shape,\n          id: shape.id,\n          point: e.sub(shape.point, delta),\n          text\n        });\n      }\n    }, [text]);\n    const handleChange = React41.useCallback(\n      (e5) => {\n        let delta = [0, 0];\n        const newText = TLDR.normalizeText(e5.currentTarget.value);\n        const currentBounds = this.getBounds(shape);\n        this.texts.set(shape.id, newText);\n        const nextBounds = this.getBounds({\n          ...shape,\n          text: newText\n        });\n        switch (shape.style.textAlign) {\n          case \"start\" /* Start */: {\n            break;\n          }\n          case \"middle\" /* Middle */: {\n            delta = e.div([nextBounds.width - currentBounds.width, 0], 2);\n            break;\n          }\n          case \"end\" /* End */: {\n            delta = [nextBounds.width - currentBounds.width, 0];\n            break;\n          }\n        }\n        rEditedText.current = newText;\n        onShapeChange?.({\n          ...shape,\n          id: shape.id,\n          point: e.sub(shape.point, delta),\n          text: newText\n        });\n      },\n      [shape.id, shape.point]\n    );\n    const handleKeyDown = React41.useCallback(\n      (e5) => {\n        if (e5.key === \"Escape\") {\n          e5.preventDefault();\n          e5.stopPropagation();\n          onShapeBlur?.();\n          return;\n        }\n        if (e5.key === \"Tab\" && shape.text.length === 0) {\n          e5.preventDefault();\n          return;\n        }\n        if (e5.key === \"Enter\" && (e5.metaKey || e5.ctrlKey)) {\n          e5.preventDefault();\n          e5.stopPropagation();\n          rInput.current.blur();\n          return;\n        }\n        if (!(e5.key === \"Meta\" || e5.metaKey)) {\n          e5.stopPropagation();\n        } else if (e5.key === \"z\" && e5.metaKey) {\n          if (e5.shiftKey) {\n            document.execCommand(\"redo\", false);\n          } else {\n            document.execCommand(\"undo\", false);\n          }\n          e5.stopPropagation();\n          e5.preventDefault();\n          return;\n        }\n        if ((e5.metaKey || e5.ctrlKey) && e5.key === \"=\") {\n          e5.preventDefault();\n        }\n        if (e5.key === \"Tab\") {\n          e5.preventDefault();\n          if (e5.shiftKey) {\n            TextAreaUtils.unindent(e5.currentTarget);\n          } else {\n            TextAreaUtils.indent(e5.currentTarget);\n          }\n          onShapeChange?.({ ...shape, text: TLDR.normalizeText(e5.currentTarget.value) });\n        }\n      },\n      [shape, onShapeChange]\n    );\n    const handleBlur = React41.useCallback((e5) => {\n      e5.currentTarget.setSelectionRange(0, 0);\n      onShapeBlur?.();\n    }, []);\n    const handleFocus = React41.useCallback(\n      (e5) => {\n        if (!isEditing)\n          return;\n        if (!rIsMounted.current)\n          return;\n        if (document.activeElement === e5.currentTarget) {\n          e5.currentTarget.select();\n        }\n      },\n      [isEditing]\n    );\n    const handlePointerDown = React41.useCallback(\n      (e5) => {\n        if (isEditing) {\n          e5.stopPropagation();\n        }\n      },\n      [isEditing]\n    );\n    const rWasEditing = React41.useRef(isEditing);\n    React41.useEffect(() => {\n      if (isEditing) {\n        rWasEditing.current = true;\n        this.texts.set(shape.id, text);\n        requestAnimationFrame(() => {\n          rIsMounted.current = true;\n          const elm = rInput.current;\n          if (elm) {\n            elm.focus();\n            elm.select();\n          }\n        });\n      } else if (rWasEditing.current) {\n        rWasEditing.current = false;\n        onShapeBlur?.();\n      }\n    }, [isEditing]);\n    return /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(Xs, { ref, ...events, children: /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(Wrapper2, { isGhost, isEditing, onPointerDown: handlePointerDown, children: /* @__PURE__ */ (0, import_jsx_runtime57.jsxs)(\n      InnerWrapper,\n      {\n        style: {\n          font,\n          color: styles.stroke,\n          textAlign: getTextAlign(style.textAlign)\n        },\n        children: [\n          isBinding && /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(\n            \"div\",\n            {\n              className: \"tl-binding-indicator\",\n              style: {\n                position: \"absolute\",\n                top: -this.bindingDistance,\n                left: -this.bindingDistance,\n                width: `calc(100% + ${this.bindingDistance * 2}px)`,\n                height: `calc(100% + ${this.bindingDistance * 2}px)`,\n                backgroundColor: \"var(--tl-selectFill)\"\n              }\n            }\n          ),\n          isEditing ? /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(\n            TextArea,\n            {\n              ref: rInput,\n              style: {\n                font,\n                color: styles.stroke\n              },\n              name: \"text\",\n              tabIndex: -1,\n              autoComplete: \"false\",\n              autoCapitalize: \"false\",\n              autoCorrect: \"false\",\n              autoSave: \"false\",\n              autoFocus: true,\n              placeholder: \"\",\n              spellCheck: \"true\",\n              wrap: \"off\",\n              dir: \"auto\",\n              datatype: \"wysiwyg\",\n              defaultValue: text,\n              color: styles.stroke,\n              onFocus: handleFocus,\n              onChange: handleChange,\n              onKeyDown: handleKeyDown,\n              onBlur: handleBlur,\n              onPointerDown: handlePointerDown,\n              onContextMenu: stopPropagation,\n              onCopy: stopPropagation,\n              onPaste: stopPropagation,\n              onCut: stopPropagation\n            }\n          ) : text,\n          \"\\u200B\"\n        ]\n      }\n    ) }) });\n  });\n  Indicator = TDShapeUtil.Indicator(({ shape }) => {\n    const { width, height } = this.getBounds(shape);\n    return /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(\"rect\", { x: 0, y: 0, width, height });\n  });\n  getBounds = (shape) => {\n    const bounds = C3.getFromCache(this.boundsCache, shape, () => {\n      if (!melm2) {\n        return { minX: 0, minY: 0, maxX: 10, maxY: 10, width: 10, height: 10 };\n      }\n      if (!melm2.parentNode)\n        document.body.appendChild(melm2);\n      melm2.style.font = getFontStyle(shape.style);\n      melm2.textContent = this.texts.get(shape.id) ?? shape.text;\n      const width = melm2.offsetWidth || 1;\n      const height = melm2.offsetHeight || 1;\n      return {\n        minX: 0,\n        maxX: width,\n        minY: 0,\n        maxY: height,\n        width,\n        height\n      };\n    });\n    return C3.translateBounds(bounds, shape.point);\n  };\n  shouldRender = (prev, next) => {\n    return next.text !== prev.text || next.style.scale !== prev.style.scale || next.style !== prev.style;\n  };\n  transform = (shape, bounds, { initialShape, scaleX, scaleY }) => {\n    const {\n      rotation = 0,\n      style: { scale = 1 }\n    } = initialShape;\n    const nextScale = scale * Math.abs(Math.min(scaleX, scaleY));\n    return {\n      point: [bounds.minX, bounds.minY],\n      rotation: scaleX < 0 && scaleY >= 0 || scaleY < 0 && scaleX >= 0 ? -(rotation || 0) : rotation,\n      style: {\n        ...initialShape.style,\n        scale: nextScale\n      }\n    };\n  };\n  transformSingle = (shape, bounds, { initialShape, scaleX, scaleY }) => {\n    const {\n      style: { scale = 1 }\n    } = initialShape;\n    return {\n      point: e.toFixed([bounds.minX, bounds.minY]),\n      style: {\n        ...initialShape.style,\n        scale: scale * Math.max(Math.abs(scaleY), Math.abs(scaleX))\n      }\n    };\n  };\n  onDoubleClickBoundsHandle = (shape) => {\n    const center = this.getCenter(shape);\n    const newCenter = this.getCenter({\n      ...shape,\n      style: {\n        ...shape.style,\n        scale: 1\n      }\n    });\n    return {\n      style: {\n        ...shape.style,\n        scale: 1\n      },\n      point: e.toFixed(e.add(shape.point, e.sub(center, newCenter)))\n    };\n  };\n  getSvgElement = (shape) => {\n    const bounds = this.getBounds(shape);\n    const style = getShapeStyle(shape.style);\n    const fontSize = getFontSize(shape.style.size, shape.style.font) * (shape.style.scale ?? 1);\n    const fontFamily = getFontFace(shape.style.font).slice(1, -1);\n    const textAlign = shape.style.textAlign ?? \"start\" /* Start */;\n    const textElm = getTextSvgElement(shape.text, fontSize, fontFamily, textAlign, bounds.width, false);\n    textElm.setAttribute(\"fill\", style.stroke);\n    return textElm;\n  };\n};\nvar melm2;\nfunction getMeasurementDiv2() {\n  document.querySelector(\"#__textMeasure\")?.remove();\n  const pre = document.createElement(\"pre\");\n  pre.id = \"__textMeasure\";\n  Object.assign(pre.style, {\n    whiteSpace: \"pre\",\n    width: \"auto\",\n    border: \"1px solid transparent\",\n    padding: \"4px\",\n    margin: \"0px\",\n    letterSpacing: LETTER_SPACING,\n    opacity: \"0\",\n    position: \"absolute\",\n    top: \"-500px\",\n    left: \"0px\",\n    zIndex: \"9999\",\n    pointerEvents: \"none\",\n    userSelect: \"none\",\n    alignmentBaseline: \"mathematical\",\n    dominantBaseline: \"mathematical\"\n  });\n  pre.tabIndex = -1;\n  document.body.appendChild(pre);\n  return pre;\n}\nif (typeof window !== \"undefined\") {\n  melm2 = getMeasurementDiv2();\n}\nvar Wrapper2 = styled(\"div\", {\n  width: \"100%\",\n  height: \"100%\",\n  variants: {\n    isGhost: {\n      false: { opacity: 1 },\n      true: { transition: \"opacity .2s\", opacity: GHOSTED_OPACITY }\n    },\n    isEditing: {\n      false: {\n        pointerEvents: \"all\",\n        userSelect: \"all\"\n      },\n      true: {\n        pointerEvents: \"none\",\n        userSelect: \"none\"\n      }\n    }\n  }\n});\nvar commonTextWrapping2 = {\n  whiteSpace: \"pre-wrap\",\n  overflowWrap: \"break-word\"\n};\nvar InnerWrapper = styled(\"div\", {\n  position: \"absolute\",\n  width: \"100%\",\n  height: \"100%\",\n  padding: \"4px\",\n  zIndex: 1,\n  minHeight: 1,\n  minWidth: 1,\n  lineHeight: 1,\n  letterSpacing: LETTER_SPACING,\n  outline: 0,\n  fontWeight: \"500\",\n  backfaceVisibility: \"hidden\",\n  userSelect: \"none\",\n  pointerEvents: \"none\",\n  WebkitUserSelect: \"none\",\n  WebkitTouchCallout: \"none\",\n  isEditing: {\n    false: {},\n    true: {\n      pointerEvents: \"all\",\n      background: \"$boundsBg\",\n      userSelect: \"text\",\n      WebkitUserSelect: \"text\"\n    }\n  },\n  ...commonTextWrapping2\n});\nvar TextArea = styled(\"textarea\", {\n  position: \"absolute\",\n  top: 0,\n  left: 0,\n  zIndex: 1,\n  width: \"100%\",\n  height: \"100%\",\n  border: \"none\",\n  padding: \"4px\",\n  resize: \"none\",\n  textAlign: \"inherit\",\n  minHeight: \"inherit\",\n  minWidth: \"inherit\",\n  lineHeight: \"inherit\",\n  letterSpacing: \"inherit\",\n  outline: 0,\n  fontWeight: \"inherit\",\n  overflow: \"hidden\",\n  backfaceVisibility: \"hidden\",\n  display: \"inline-block\",\n  pointerEvents: \"all\",\n  background: \"$boundsBg\",\n  userSelect: \"text\",\n  WebkitUserSelect: \"text\",\n  ...commonTextWrapping2,\n  \"&:focus\": {\n    outline: \"none\",\n    border: \"none\"\n  }\n});\n\n// src/components/Tldraw/state/shapes/TriangleUtil/TriangleUtil.tsx\nvar React44 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/state/shapes/TriangleUtil/components/DashedTriangle.tsx\nvar React42 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/state/shapes/TriangleUtil/triangleHelpers.ts\nfunction getTrianglePoints(size, offset = 0, rotation = 0) {\n  const [w7, h6] = size;\n  let points = [\n    [w7 / 2, 0],\n    [w7, h6],\n    [0, h6]\n  ];\n  if (offset)\n    points = getOffsetPolygon(points, offset);\n  if (rotation)\n    points = points.map((pt2) => p.rotWith(pt2, [w7 / 2, h6 / 2], rotation));\n  return points;\n}\nfunction getTriangleCentroid(size) {\n  const [w7, h6] = size;\n  const points = [\n    [w7 / 2, 0],\n    [w7, h6],\n    [0, h6]\n  ];\n  return [(points[0][0] + points[1][0] + points[2][0]) / 3, (points[0][1] + points[1][1] + points[2][1]) / 3];\n}\nfunction getTriangleDrawPoints(id, size, strokeWidth) {\n  const [w7, h6] = size;\n  const getRandom = C3.rng(id);\n  const offsets = Array.from({ length: 3 }).map(() => {\n    return [getRandom() * strokeWidth * 0.75, getRandom() * strokeWidth * 0.75];\n  });\n  const corners = [p.add([w7 / 2, 0], offsets[0]), p.add([w7, h6], offsets[1]), p.add([0, h6], offsets[2])];\n  const rm = Math.round(Math.abs(getRandom() * 2 * 3));\n  const lines = C3.rotateArray(\n    [p.pointsBetween(corners[0], corners[1], 32), p.pointsBetween(corners[1], corners[2], 32), p.pointsBetween(corners[2], corners[0], 32)],\n    rm\n  );\n  const points = [...lines.flat(), ...lines[0]];\n  return {\n    points\n  };\n}\nfunction getDrawStrokeInfo2(id, size, style) {\n  const { strokeWidth } = getShapeStyle(style);\n  const { points } = getTriangleDrawPoints(id, size, strokeWidth);\n  const options = {\n    size: strokeWidth,\n    thinning: 0.65,\n    streamline: 0.3,\n    smoothing: 1,\n    simulatePressure: false,\n    last: true\n  };\n  return { points, options };\n}\nfunction getTrianglePath(id, size, style) {\n  const { points, options } = getDrawStrokeInfo2(id, size, style);\n  const stroke = _e(points, options);\n  return C3.getSvgPathFromStroke(stroke);\n}\nfunction getTriangleIndicatorPathTDSnapshot(id, size, style) {\n  const { points, options } = getDrawStrokeInfo2(id, size, style);\n  return C3.getSvgPathFromStrokePoints(me(points, options));\n}\n\n// src/components/Tldraw/state/shapes/TriangleUtil/components/DashedTriangle.tsx\nvar import_jsx_runtime58 = require(\"react/jsx-runtime\");\nvar DashedTriangle = React42.memo(function DashedTriangle2({ id, size, style, isSelected }) {\n  const { stroke, strokeWidth, fill } = getShapeStyle(style);\n  const sw = 1 + strokeWidth * 1.618;\n  const points = getTrianglePoints(size);\n  const sides = C3.pointsToLineSegments(points, true);\n  const paths = sides.map(([start, end], i4) => {\n    const { strokeDasharray, strokeDashoffset } = C3.getPerfectDashProps(p.dist(start, end), strokeWidth * 1.618, style.dash);\n    return /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(\n      \"line\",\n      {\n        x1: start[0],\n        y1: start[1],\n        x2: end[0],\n        y2: end[1],\n        stroke,\n        strokeWidth: sw,\n        strokeLinecap: \"round\",\n        strokeDasharray,\n        strokeDashoffset\n      },\n      id + \"_\" + i4\n    );\n  });\n  const bgPath = points.join(\",\");\n  return /* @__PURE__ */ (0, import_jsx_runtime58.jsxs)(import_jsx_runtime58.Fragment, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(\"polygon\", { className: style.isFilled || isSelected ? \"tl-fill-hitarea\" : \"tl-stroke-hitarea\", points: bgPath }),\n    style.isFilled && /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(\"polygon\", { fill, points: bgPath, pointerEvents: \"none\" }),\n    /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(\"g\", { pointerEvents: \"stroke\", children: paths })\n  ] });\n});\n\n// src/components/Tldraw/state/shapes/TriangleUtil/components/DrawTriangle.tsx\nvar React43 = __toESM(require(\"react\"));\nvar import_jsx_runtime59 = require(\"react/jsx-runtime\");\nvar DrawTriangle = React43.memo(function DrawTriangle2({ id, size, style, isSelected }) {\n  const { stroke, strokeWidth, fill } = getShapeStyle(style);\n  const pathTDSnapshot = getTrianglePath(id, size, style);\n  const indicatorPath = getTriangleIndicatorPathTDSnapshot(id, size, style);\n  return /* @__PURE__ */ (0, import_jsx_runtime59.jsxs)(import_jsx_runtime59.Fragment, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(\"path\", { className: style.isFilled || isSelected ? \"tl-fill-hitarea\" : \"tl-stroke-hitarea\", d: indicatorPath }),\n    style.isFilled && /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(\"path\", { d: indicatorPath, fill, pointerEvents: \"none\" }),\n    /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(\"path\", { d: pathTDSnapshot, fill: stroke, stroke, strokeWidth, pointerEvents: \"none\" })\n  ] });\n});\n\n// src/components/Tldraw/state/shapes/TriangleUtil/components/TriangleBindingIndicator.tsx\nvar import_jsx_runtime60 = require(\"react/jsx-runtime\");\nfunction TriangleBindingIndicator({ size }) {\n  const trianglePoints = getTrianglePoints(size).join(\",\");\n  return /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(\"polygon\", { className: \"tl-binding-indicator\", points: trianglePoints, strokeWidth: BINDING_DISTANCE * 2 });\n}\n\n// src/components/Tldraw/state/shapes/TriangleUtil/TriangleUtil.tsx\nvar import_jsx_runtime61 = require(\"react/jsx-runtime\");\nvar TriangleUtil = class extends TDShapeUtil {\n  type = \"triangle\" /* Triangle */;\n  canBind = true;\n  canClone = true;\n  canEdit = true;\n  getShape = (props) => {\n    return C3.deepMerge(\n      {\n        id: \"id\",\n        type: \"triangle\" /* Triangle */,\n        name: \"Triangle\",\n        parentId: \"page\",\n        childIndex: 1,\n        point: [0, 0],\n        size: [1, 1],\n        rotation: 0,\n        style: defaultStyle,\n        label: \"\",\n        labelPoint: [0.5, 0.5]\n      },\n      props\n    );\n  };\n  Component = TDShapeUtil.Component(\n    ({ shape, bounds, isBinding, isEditing, isSelected, isGhost, meta, events, onShapeChange, onShapeBlur }, ref) => {\n      const { id, label = \"\", size, style, labelPoint = LABEL_POINT } = shape;\n      const font = getFontStyle(style);\n      const styles = getShapeStyle(style);\n      const Component = style.dash === \"draw\" /* Draw */ ? DrawTriangle : DashedTriangle;\n      const handleLabelChange = React44.useCallback((label2) => onShapeChange?.({ id, label: label2 }), [onShapeChange]);\n      const offsetY = React44.useMemo(() => {\n        const center = p.div(size, 2);\n        const centroid = getTriangleCentroid(size);\n        return (centroid[1] - center[1]) * 0.72;\n      }, [size]);\n      return /* @__PURE__ */ (0, import_jsx_runtime61.jsxs)(FullWrapper4, { ref, ...events, children: [\n        /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(\n          TextLabel,\n          {\n            font,\n            text: label,\n            color: styles.stroke,\n            offsetX: (labelPoint[0] - 0.5) * bounds.width,\n            offsetY: offsetY + (labelPoint[1] - 0.5) * bounds.height,\n            isEditing,\n            onChange: handleLabelChange,\n            onBlur: onShapeBlur\n          }\n        ),\n        /* @__PURE__ */ (0, import_jsx_runtime61.jsxs)(te, { id: shape.id + \"_svg\", opacity: isGhost ? GHOSTED_OPACITY : 1, children: [\n          isBinding && /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(TriangleBindingIndicator, { size }),\n          /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(Component, { id, style, size, isSelected })\n        ] })\n      ] });\n    }\n  );\n  Indicator = TDShapeUtil.Indicator(({ shape }) => {\n    const { size } = shape;\n    return /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(\"polygon\", { points: getTrianglePoints(size).join(\",\") });\n  });\n  getPoints(shape) {\n    const {\n      rotation = 0,\n      point: [x5, y6],\n      size: [w7, h6]\n    } = shape;\n    return [\n      [x5 + w7 / 2, y6],\n      [x5, y6 + h6],\n      [x5 + w7, y6 + h6]\n    ].map((pt2) => p.rotWith(pt2, this.getCenter(shape), rotation));\n  }\n  shouldRender = (prev, next) => {\n    return next.size !== prev.size || next.style !== prev.style || next.label !== prev.label;\n  };\n  getBounds = (shape) => {\n    return getBoundsRectangle(shape, this.boundsCache);\n  };\n  getExpandedBounds = (shape) => {\n    return C3.getBoundsFromPoints(getTrianglePoints(shape.size, this.bindingDistance).map((pt2) => p.add(pt2, shape.point)));\n  };\n  hitTestLineSegment = (shape, A5, B4) => {\n    return S(A5, B4, this.getPoints(shape)).didIntersect;\n  };\n  hitTestBounds = (shape, bounds) => {\n    return C3.boundsContained(this.getBounds(shape), bounds) || Se(bounds, this.getPoints(shape)).length > 0;\n  };\n  getBindingPoint = (shape, fromShape, point, origin, direction, bindAnywhere) => {\n    const expandedBounds = this.getExpandedBounds(shape);\n    if (!C3.pointInBounds(point, expandedBounds))\n      return;\n    const points = getTrianglePoints(shape.size).map((pt2) => p.add(pt2, shape.point));\n    const expandedPoints = getTrianglePoints(shape.size, this.bindingDistance).map((pt2) => p.add(pt2, shape.point));\n    const closestDistanceToEdge = C3.pointsToLineSegments(points, true).map(([a7, b6]) => p.distanceToLineSegment(a7, b6, point)).sort((a7, b6) => a7 - b6)[0];\n    if (!(C3.pointInPolygon(point, expandedPoints) || closestDistanceToEdge < this.bindingDistance))\n      return;\n    const intersections = C3.pointsToLineSegments([...expandedPoints, expandedPoints[0]]).map((segment) => x(origin, direction, segment[0], segment[1])).filter((intersection2) => intersection2.didIntersect).flatMap((intersection2) => intersection2.points);\n    if (intersections.length === 0)\n      return;\n    const center = p.add(getTriangleCentroid(shape.size), shape.point);\n    const intersection = intersections.sort((a7, b6) => p.dist(b6, origin) - p.dist(a7, origin))[0];\n    const middlePoint = p.med(point, intersection);\n    let anchor;\n    let distance;\n    if (bindAnywhere) {\n      anchor = p.dist(point, center) < BINDING_DISTANCE / 2 ? center : point;\n      distance = 0;\n    } else {\n      if (p.distanceToLineSegment(point, middlePoint, center) < BINDING_DISTANCE / 2) {\n        anchor = center;\n      } else {\n        anchor = middlePoint;\n      }\n      if (C3.pointInPolygon(point, points)) {\n        distance = this.bindingDistance;\n      } else {\n        distance = Math.max(this.bindingDistance, closestDistanceToEdge);\n      }\n    }\n    const bindingPoint = p.divV(p.sub(anchor, [expandedBounds.minX, expandedBounds.minY]), [expandedBounds.width, expandedBounds.height]);\n    return {\n      point: p.clampV(bindingPoint, 0, 1),\n      distance\n    };\n  };\n  transform = transformRectangle;\n  transformSingle = transformSingleRectangle;\n};\nvar FullWrapper4 = styled(\"div\", { width: \"100%\", height: \"100%\" });\n\n// src/components/Tldraw/state/shapes/index.ts\nvar Rectangle = new RectangleUtil();\nvar Triangle = new TriangleUtil();\nvar Ellipse = new EllipseUtil();\nvar Draw = new DrawUtil();\nvar Arrow = new ArrowUtil();\nvar Text = new TextUtil();\nvar Group = new GroupUtil();\nvar Sticky = new StickyUtil();\nvar Image2 = new ImageUtil();\nvar shapeUtils = {\n  [\"rectangle\" /* Rectangle */]: Rectangle,\n  [\"triangle\" /* Triangle */]: Triangle,\n  [\"ellipse\" /* Ellipse */]: Ellipse,\n  [\"draw\" /* Draw */]: Draw,\n  [\"arrow\" /* Arrow */]: Arrow,\n  [\"text\" /* Text */]: Text,\n  [\"group\" /* Group */]: Group,\n  [\"sticky\" /* Sticky */]: Sticky,\n  [\"image\" /* Image */]: Image2\n};\nvar getShapeUtil = (shape) => {\n  if (typeof shape === \"string\")\n    return shapeUtils[shape];\n  return shapeUtils[shape.type];\n};\n\n// src/components/Tldraw/state/TLDR.ts\nvar isDevelopment = true;\nvar _TLDR = class {\n  static getShapeUtil(shape) {\n    if (shape === void 0) {\n      debugger;\n      throw new Error(`shape is undefined in getShapeUtil`);\n    }\n    return getShapeUtil(shape);\n  }\n  static getSelectedShapes(data, pageId) {\n    const page = _TLDR.getPage(data, pageId);\n    const selectedIds = _TLDR.getSelectedIds(data, pageId);\n    return selectedIds.map((id) => page.shapes[id]);\n  }\n  static screenToWorld(data, point) {\n    const camera = _TLDR.getPageState(data, data.appState.currentPageId).camera;\n    return e.sub(e.div(point, camera.zoom), camera.point);\n  }\n  static getCameraZoom(zoom) {\n    return C3.clamp(zoom, 0.1, 5);\n  }\n  static getPage(data, pageId) {\n    return data.document.pages[pageId];\n  }\n  static getPageState(data, pageId) {\n    return data.document.pageStates[pageId];\n  }\n  static getSelectedIds(data, pageId) {\n    return _TLDR.getPageState(data, pageId).selectedIds;\n  }\n  static getShapes(data, pageId) {\n    return Object.values(_TLDR.getPage(data, pageId).shapes);\n  }\n  static getCamera(data, pageId) {\n    return _TLDR.getPageState(data, pageId).camera;\n  }\n  static getShape(data, shapeId, pageId) {\n    return _TLDR.getPage(data, pageId).shapes[shapeId];\n  }\n  static getCenter(shape) {\n    return _TLDR.getShapeUtil(shape).getCenter(shape);\n  }\n  static getBounds(shape) {\n    return _TLDR.getShapeUtil(shape).getBounds(shape);\n  }\n  static getRotatedBounds(shape) {\n    return _TLDR.getShapeUtil(shape).getRotatedBounds(shape);\n  }\n  static getSelectedBounds(data) {\n    return C3.getCommonBounds(_TLDR.getSelectedShapes(data, data.appState.currentPageId).map((shape) => _TLDR.getShapeUtil(shape).getBounds(shape)));\n  }\n  static getParentId(data, id, pageId) {\n    return _TLDR.getShape(data, id, pageId).parentId;\n  }\n  static getDocumentBranch(data, id, pageId) {\n    const shape = _TLDR.getShape(data, id, pageId);\n    if (shape.children === void 0)\n      return [id];\n    return [id, ...shape.children.flatMap((childId) => _TLDR.getDocumentBranch(data, childId, pageId))];\n  }\n  static getSelectedBranchSnapshot(data, pageId, function_) {\n    const page = _TLDR.getPage(data, pageId);\n    const copies = _TLDR.getSelectedIds(data, pageId).flatMap((id) => _TLDR.getDocumentBranch(data, id, pageId).map((id2) => page.shapes[id2])).filter((shape) => !shape.isLocked).map(C3.deepClone);\n    if (function_ !== void 0) {\n      return copies.map((shape) => ({ id: shape.id, ...function_(shape) }));\n    }\n    return copies;\n  }\n  static getSelectedShapeSnapshot(data, pageId, function_) {\n    const copies = _TLDR.getSelectedShapes(data, pageId).filter((shape) => !shape.isLocked).map(C3.deepClone);\n    if (function_ !== void 0) {\n      return copies.map((shape) => ({ id: shape.id, ...function_(shape) }));\n    }\n    return copies;\n  }\n  static getAllEffectedShapeIds(data, ids, pageId) {\n    const page = _TLDR.getPage(data, pageId);\n    const visited = new Set(ids);\n    ids.forEach((id) => {\n      const shape = page.shapes[id];\n      function collectDescendants(shape2) {\n        if (shape2.children === void 0)\n          return;\n        shape2.children.filter((childId) => !visited.has(childId)).forEach((childId) => {\n          visited.add(childId);\n          collectDescendants(page.shapes[childId]);\n        });\n      }\n      collectDescendants(shape);\n      function collectAscendants(shape2) {\n        const parentId = shape2.parentId;\n        if (parentId === page.id)\n          return;\n        if (visited.has(parentId))\n          return;\n        visited.add(parentId);\n        collectAscendants(page.shapes[parentId]);\n      }\n      collectAscendants(shape);\n      visited.forEach((id2) => {\n        Object.values(page.bindings).filter((binding) => binding.fromId === id2 || binding.toId === id2).forEach((binding) => visited.add(binding.fromId === id2 ? binding.toId : binding.fromId));\n      });\n    });\n    return [...visited.values()];\n  }\n  static getLinkedShapeIds(data, pageId, direction, includeArrows = true) {\n    const selectedIds = _TLDR.getSelectedIds(data, pageId);\n    const page = _TLDR.getPage(data, pageId);\n    const linkedIds = new Set(selectedIds);\n    const checkedIds = /* @__PURE__ */ new Set();\n    const idsToCheck = [...selectedIds];\n    const arrows = new Set(\n      Object.values(page.shapes).filter((shape) => {\n        return shape.type === \"arrow\" /* Arrow */ && (shape.handles.start.bindingId || shape.handles?.end.bindingId);\n      })\n    );\n    while (idsToCheck.length > 0) {\n      const id = idsToCheck.pop();\n      if (!(id && arrows.size > 0))\n        break;\n      if (checkedIds.has(id))\n        continue;\n      checkedIds.add(id);\n      arrows.forEach((arrow2) => {\n        const {\n          handles: {\n            start: { bindingId: startBindingId },\n            end: { bindingId: endBindingId }\n          }\n        } = arrow2;\n        const startBinding = startBindingId ? page.bindings[startBindingId] : null;\n        const endBinding = endBindingId ? page.bindings[endBindingId] : null;\n        let hit = false;\n        if (startBinding != void 0 && startBinding.toId === id) {\n          if (direction === \"center\") {\n            hit = true;\n          } else if (arrow2.decorations?.start && endBinding != void 0) {\n            hit = direction === \"left\";\n          } else {\n            hit = direction === \"right\";\n          }\n          if (hit) {\n            if (includeArrows)\n              linkedIds.add(arrow2.id);\n            linkedIds.add(id);\n            if (endBinding != void 0) {\n              linkedIds.add(endBinding.toId);\n              idsToCheck.push(endBinding.toId);\n            }\n          }\n        } else if (endBinding != void 0 && endBinding.toId === id) {\n          if (direction === \"center\") {\n            hit = true;\n          } else if (arrow2.decorations?.end && startBinding != void 0) {\n            hit = direction === \"left\";\n          } else {\n            hit = direction === \"right\";\n          }\n          if (hit) {\n            if (includeArrows)\n              linkedIds.add(arrow2.id);\n            linkedIds.add(id);\n            if (startBinding != void 0) {\n              linkedIds.add(startBinding.toId);\n              idsToCheck.push(startBinding.toId);\n            }\n          }\n        }\n        if ((startBinding == void 0 || linkedIds.has(startBinding.toId)) && (endBinding == void 0 || linkedIds.has(endBinding.toId))) {\n          arrows.delete(arrow2);\n        }\n      });\n    }\n    return [...linkedIds.values()];\n  }\n  static getChildIndexAbove(data, id, pageId) {\n    const page = data.document.pages[pageId];\n    const shape = page.shapes[id];\n    let siblings;\n    if (shape.parentId === page.id) {\n      siblings = Object.values(page.shapes).filter((shape2) => shape2.parentId === page.id).sort((a7, b6) => a7.childIndex - b6.childIndex);\n    } else {\n      const parent = page.shapes[shape.parentId];\n      if (parent.children == void 0)\n        throw new Error(\"No children in parent!\");\n      siblings = parent.children.map((childId) => page.shapes[childId]).sort((a7, b6) => a7.childIndex - b6.childIndex);\n    }\n    const index2 = siblings.indexOf(shape);\n    const nextSibling = siblings[index2 + 1];\n    if (!nextSibling)\n      return shape.childIndex + 1;\n    return nextSibling.childIndex;\n  }\n  static getBeforeShape(shape, change) {\n    return Object.fromEntries(Object.keys(change).map((k6) => [k6, shape[k6]]));\n  }\n  static mutateShapes(data, ids, function_, pageId, forceChildrenTraversal = false) {\n    const beforeShapes = {};\n    const afterShapes = {};\n    ids.forEach((id, index2) => {\n      const shape = _TLDR.getShape(data, id, pageId);\n      if (shape.isLocked)\n        return;\n      if (shape?.type === \"group\" && (ids.length === 1 || forceChildrenTraversal)) {\n        shape.children.forEach((id2, index_) => {\n          const shape2 = _TLDR.getShape(data, id2, pageId);\n          if (shape2.isLocked)\n            return;\n          const change2 = function_(shape2, index_);\n          if (change2 != void 0) {\n            beforeShapes[id2] = _TLDR.getBeforeShape(shape2, change2);\n            afterShapes[id2] = change2;\n          }\n        });\n      }\n      const change = function_(shape, index2);\n      if (change != void 0) {\n        beforeShapes[id] = _TLDR.getBeforeShape(shape, change);\n        afterShapes[id] = change;\n      }\n    });\n    const dataWithMutations = C3.deepMerge(data, {\n      document: {\n        pages: {\n          [data.appState.currentPageId]: {\n            shapes: afterShapes\n          }\n        }\n      }\n    });\n    return {\n      before: beforeShapes,\n      after: afterShapes,\n      data: dataWithMutations\n    };\n  }\n  static createShapes(data, shapes, pageId) {\n    const before = {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: {\n              ...Object.fromEntries(\n                shapes.flatMap((shape) => {\n                  const results = [[shape.id, void 0]];\n                  if (shape.parentId !== pageId) {\n                    const parent = _TLDR.getShape(data, shape.parentId, pageId);\n                    if (parent.children == void 0)\n                      throw new Error(\"No children in parent!\");\n                    results.push([parent.id, { children: parent.children }]);\n                  }\n                  return results;\n                })\n              )\n            }\n          }\n        }\n      }\n    };\n    const after = {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: {\n              shapes: {\n                ...Object.fromEntries(\n                  shapes.flatMap((shape) => {\n                    const results = [[shape.id, shape]];\n                    if (shape.parentId !== pageId) {\n                      const parent = _TLDR.getShape(data, shape.parentId, pageId);\n                      if (parent.children == void 0)\n                        throw new Error(\"No children in parent!\");\n                      results.push([parent.id, { children: [...parent.children, shape.id] }]);\n                    }\n                    return results;\n                  })\n                )\n              }\n            }\n          }\n        }\n      }\n    };\n    return {\n      before,\n      after\n    };\n  }\n  static deleteShapes(data, shapes, pageId) {\n    pageId = pageId || data.appState.currentPageId;\n    const page = _TLDR.getPage(data, pageId);\n    const shapeIds = typeof shapes[0] === \"string\" ? shapes : shapes.map((shape) => shape.id);\n    const before = {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: {\n              ...Object.fromEntries(\n                shapeIds.flatMap((id) => {\n                  const shape = page.shapes[id];\n                  const results = [[shape.id, shape]];\n                  if (shape.parentId !== pageId) {\n                    const parent = page.shapes[shape.parentId];\n                    if (parent.children == void 0)\n                      throw new Error(\"No children in parent!\");\n                    results.push([parent.id, { children: parent.children }]);\n                  }\n                  return results;\n                })\n              )\n            },\n            bindings: {\n              ...Object.fromEntries(\n                Object.values(page.bindings).filter((binding) => {\n                  return shapeIds.includes(binding.fromId) || shapeIds.includes(binding.toId);\n                }).map((binding) => {\n                  return [binding.id, binding];\n                })\n              )\n            }\n          }\n        }\n      }\n    };\n    const after = {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: {\n              ...Object.fromEntries(\n                shapeIds.flatMap((id) => {\n                  const shape = page.shapes[id];\n                  const results = [[shape.id, void 0]];\n                  if (shape.parentId !== page.id) {\n                    const parent = page.shapes[shape.parentId];\n                    if (parent.children == void 0)\n                      throw new Error(\"No children in parent!\");\n                    results.push([parent.id, { children: parent.children.filter((id2) => id2 !== shape.id) }]);\n                  }\n                  return results;\n                })\n              )\n            }\n          }\n        }\n      }\n    };\n    return {\n      before,\n      after\n    };\n  }\n  static onSessionComplete(shape) {\n    const delta = _TLDR.getShapeUtil(shape).onSessionComplete?.(shape);\n    if (delta == void 0)\n      return shape;\n    return { ...shape, ...delta };\n  }\n  static onChildrenChange(data, shape, pageId) {\n    if (shape.children == void 0)\n      return;\n    const delta = _TLDR.getShapeUtil(shape).onChildrenChange?.(\n      shape,\n      shape.children.map((id) => _TLDR.getShape(data, id, pageId))\n    );\n    if (delta == void 0)\n      return shape;\n    return { ...shape, ...delta };\n  }\n  static updateArrowBindings(page, arrowShape) {\n    const result = {\n      start: deepCopy(arrowShape.handles.start),\n      end: deepCopy(arrowShape.handles.end)\n    };\n    let start = {\n      isBound: false,\n      handle: arrowShape.handles.start,\n      point: e.add(arrowShape.handles.start.point, arrowShape.point)\n    };\n    let end = {\n      isBound: false,\n      handle: arrowShape.handles.end,\n      point: e.add(arrowShape.handles.end.point, arrowShape.point)\n    };\n    if (arrowShape.handles.start.bindingId) {\n      const hasDecoration = arrowShape.decorations?.start !== void 0;\n      const handle = arrowShape.handles.start;\n      const binding = page.bindings[arrowShape.handles.start.bindingId];\n      if (!binding)\n        throw new Error(\"Could not find a binding to match the start handle's bindingId: \" + arrowShape.handles.start.bindingId);\n      const target = page.shapes[binding.toId];\n      const util = _TLDR.getShapeUtil(target);\n      const bounds = util.getBounds(target);\n      const expandedBounds = util.getExpandedBounds(target);\n      const intersectBounds = hasDecoration ? C3.expandBounds(bounds, binding.distance) : bounds;\n      const { minX, minY, width, height } = expandedBounds;\n      const anchorPoint = e.add([minX, minY], e.mulV([width, height], e.rotWith(binding.point, [0.5, 0.5], target.rotation || 0)));\n      start = {\n        isBound: true,\n        hasDecoration,\n        binding,\n        handle,\n        point: anchorPoint,\n        util,\n        target,\n        bounds,\n        expandedBounds,\n        intersectBounds,\n        center: util.getCenter(target)\n      };\n    }\n    if (arrowShape.handles.end.bindingId) {\n      const hasDecoration = arrowShape.decorations?.end !== void 0;\n      const handle = arrowShape.handles.end;\n      const binding = page.bindings[arrowShape.handles.end.bindingId];\n      if (!binding)\n        throw new Error(\"Could not find a binding to match the end handle's bindingId\");\n      const target = page.shapes[binding.toId];\n      const util = _TLDR.getShapeUtil(target);\n      const bounds = util.getBounds(target);\n      const expandedBounds = util.getExpandedBounds(target);\n      const intersectBounds = hasDecoration ? C3.expandBounds(bounds, binding.distance) : bounds;\n      const { minX, minY, width, height } = expandedBounds;\n      const anchorPoint = e.add([minX, minY], e.mulV([width, height], e.rotWith(binding.point, [0.5, 0.5], target.rotation || 0)));\n      end = {\n        isBound: true,\n        hasDecoration,\n        binding,\n        handle,\n        point: anchorPoint,\n        util,\n        target,\n        bounds,\n        expandedBounds,\n        intersectBounds,\n        center: util.getCenter(target)\n      };\n    }\n    for (const ID of [\"end\", \"start\"]) {\n      const A5 = ID === \"start\" ? start : end;\n      const B4 = ID === \"start\" ? end : start;\n      if (A5.isBound) {\n        if (A5.binding.distance) {\n          const direction = e.uni(e.sub(A5.point, B4.point));\n          switch (A5.target.type) {\n            case \"ellipse\" /* Ellipse */: {\n              const hits = F(\n                B4.point,\n                direction,\n                A5.center,\n                A5.target.radius[0] + (A5.hasDecoration ? A5.binding.distance : 0),\n                A5.target.radius[1] + (A5.hasDecoration ? A5.binding.distance : 0),\n                A5.target.rotation || 0\n              ).points.sort((a7, b6) => e.dist(a7, B4.point) - e.dist(b6, B4.point));\n              if (hits[0] !== void 0) {\n                result[ID].point = e.toFixed(e.sub(hits[0], arrowShape.point));\n              }\n              break;\n            }\n            case \"triangle\" /* Triangle */: {\n              const targetPoint = A5.target.point;\n              const points = getTrianglePoints(A5.target.size, A5.hasDecoration ? BINDING_DISTANCE : 0, A5.target.rotation).map((pt2) => e.add(pt2, targetPoint));\n              const hits = C3.pointsToLineSegments(points, true).map(([p0, p1]) => x(B4.point, direction, p0, p1)).filter((intersection) => intersection.didIntersect).flatMap((intersection) => intersection.points).sort((a7, b6) => e.dist(a7, B4.point) - e.dist(b6, B4.point));\n              if (hits[0] !== void 0) {\n                result[ID].point = e.toFixed(e.sub(hits[0], arrowShape.point));\n              }\n              break;\n            }\n            default: {\n              const hits = se2(B4.point, direction, A5.intersectBounds, A5.target.rotation).filter((int) => int.didIntersect).map((int) => int.points[0]).sort((a7, b6) => e.dist(a7, B4.point) - e.dist(b6, B4.point));\n              if (!hits[0])\n                continue;\n              let bHit;\n              if (B4.isBound) {\n                const bHits = se2(B4.point, direction, B4.intersectBounds, B4.target.rotation).filter((int) => int.didIntersect).map((int) => int.points[0]).sort((a7, b6) => e.dist(a7, B4.point) - e.dist(b6, B4.point));\n                bHit = bHits[0];\n              }\n              if (B4.isBound && (hits.length < 2 || bHit != void 0 && hits[0] && Math.ceil(e.dist(hits[0], bHit)) < BINDING_DISTANCE * 2.5 || C3.boundsContain(A5.expandedBounds, B4.expandedBounds) || C3.boundsCollide(A5.expandedBounds, B4.expandedBounds))) {\n                const shortArrowDirection = e.uni(e.sub(B4.point, A5.point));\n                const shortArrowHits = se2(A5.point, shortArrowDirection, A5.bounds, A5.target.rotation).filter((int) => int.didIntersect).map((int) => int.points[0]);\n                if (!shortArrowHits[0])\n                  continue;\n                result[ID].point = e.toFixed(e.sub(shortArrowHits[0], arrowShape.point));\n                result[ID === \"start\" ? \"end\" : \"start\"].point = e.toFixed(\n                  e.add(\n                    e.sub(shortArrowHits[0], arrowShape.point),\n                    e.mul(\n                      shortArrowDirection,\n                      Math.min(e.dist(shortArrowHits[0], B4.point), BINDING_DISTANCE * 2.5 * (C3.boundsContain(B4.bounds, A5.intersectBounds) ? -1 : 1))\n                    )\n                  )\n                );\n              } else if (!B4.isBound && (hits[0] && e.dist(hits[0], B4.point) < BINDING_DISTANCE * 2.5 || C3.pointInBounds(B4.point, A5.intersectBounds))) {\n                const shortArrowDirection = e.uni(e.sub(A5.center, B4.point));\n                return _TLDR.getShapeUtil(arrowShape).onHandleChange?.(arrowShape, {\n                  [ID]: {\n                    ...arrowShape.handles[ID],\n                    point: e.toFixed(e.add(e.sub(B4.point, arrowShape.point), e.mul(shortArrowDirection, BINDING_DISTANCE * 2.5)))\n                  }\n                });\n              } else if (hits[0]) {\n                result[ID].point = e.toFixed(e.sub(hits[0], arrowShape.point));\n              }\n            }\n          }\n        } else {\n          result[ID].point = e.sub(A5.point, arrowShape.point);\n        }\n      }\n    }\n    return _TLDR.getShapeUtil(arrowShape).onHandleChange?.(arrowShape, result);\n  }\n  static transform(shape, bounds, info) {\n    const delta = _TLDR.getShapeUtil(shape).transform(shape, bounds, info);\n    if (!delta)\n      return shape;\n    return { ...shape, ...delta };\n  }\n  static transformSingle(shape, bounds, info) {\n    const delta = _TLDR.getShapeUtil(shape).transformSingle(shape, bounds, info);\n    if (delta == void 0)\n      return shape;\n    return { ...shape, ...delta };\n  }\n  static getRotatedShapeMutation(shape, center, origin, delta) {\n    const relativeCenter = e.sub(center, shape.point);\n    const rotatedCenter = e.rotWith(center, origin, delta);\n    const nextPoint = e.toFixed(e.sub(rotatedCenter, relativeCenter));\n    if (shape.handles !== void 0) {\n      const change = this.getShapeUtil(shape).onHandleChange?.(\n        { ...shape, point: nextPoint },\n        Object.fromEntries(\n          Object.entries(shape.handles).map(([handleId, handle]) => {\n            const point = e.toFixed(e.rotWith(handle.point, relativeCenter, delta));\n            return [handleId, { ...handle, point }];\n          })\n        )\n      );\n      return change;\n    }\n    const nextRotation = C3.clampRadians((shape.rotation || 0) + delta);\n    return {\n      point: nextPoint,\n      rotation: nextRotation\n    };\n  }\n  static updateParents(data, pageId, changedShapeIds) {\n    const page = _TLDR.getPage(data, pageId);\n    if (changedShapeIds.length === 0)\n      return;\n    const { shapes } = _TLDR.getPage(data, pageId);\n    const parentToUpdateIds = [...new Set(changedShapeIds.map((id) => shapes[id].parentId).values())].filter((id) => id !== page.id);\n    for (const parentId of parentToUpdateIds) {\n      const parent = shapes[parentId];\n      if (parent.children == void 0) {\n        throw new Error(\"A shape is parented to a shape without a children array.\");\n      }\n      _TLDR.onChildrenChange(data, parent, pageId);\n    }\n    _TLDR.updateParents(data, pageId, parentToUpdateIds);\n  }\n  static getBinding(data, id, pageId) {\n    return _TLDR.getPage(data, pageId).bindings[id];\n  }\n  static getBindings(data, pageId) {\n    const page = _TLDR.getPage(data, pageId);\n    return Object.values(page.bindings);\n  }\n  static getBindableShapeIds(data) {\n    return _TLDR.getShapes(data, data.appState.currentPageId).filter((shape) => _TLDR.getShapeUtil(shape).canBind).sort((a7, b6) => b6.childIndex - a7.childIndex).map((shape) => shape.id);\n  }\n  static getBindingsWithShapeIds(data, ids, pageId) {\n    return [\n      ...new Set(\n        _TLDR.getBindings(data, pageId).filter((binding) => {\n          return ids.includes(binding.toId) || ids.includes(binding.fromId);\n        })\n      ).values()\n    ];\n  }\n  static getRelatedBindings(data, ids, pageId) {\n    const changedShapeIds = new Set(ids);\n    const page = _TLDR.getPage(data, pageId);\n    const bindingsArray = Object.values(page.bindings);\n    const bindingsToUpdate = new Set(bindingsArray.filter((binding) => changedShapeIds.has(binding.toId) || changedShapeIds.has(binding.fromId)));\n    let previousSize = bindingsToUpdate.size;\n    let delta = -1;\n    while (delta !== 0) {\n      bindingsToUpdate.forEach((binding) => {\n        const fromId = binding.fromId;\n        for (const otherBinding of bindingsArray) {\n          if (otherBinding.fromId === fromId) {\n            bindingsToUpdate.add(otherBinding);\n          }\n          if (otherBinding.toId === fromId) {\n            bindingsToUpdate.add(otherBinding);\n          }\n        }\n      });\n      delta = bindingsToUpdate.size - previousSize;\n      previousSize = bindingsToUpdate.size;\n    }\n    return [...bindingsToUpdate.values()];\n  }\n  static normalizeText(text) {\n    return text.replace(_TLDR.fixNewLines, \"\\n\").split(\"\\n\").map((x5) => x5 || \" \").join(\"\\n\");\n  }\n  static assertShapeHasProperty(shape, property) {\n    if (shape[property] === void 0) {\n      throw new Error();\n    }\n  }\n  static warn(e5) {\n    if (isDevelopment) {\n      console.warn(e5);\n    }\n  }\n  static error(e5) {\n    if (isDevelopment) {\n      console.error(e5);\n    }\n  }\n  static getSvgString(svg, scale = 1) {\n    const clone = svg.cloneNode(true);\n    svg.setAttribute(\"width\", +svg.getAttribute(\"width\") * scale + \"\");\n    svg.setAttribute(\"height\", +svg.getAttribute(\"height\") * scale + \"\");\n    return new XMLSerializer().serializeToString(clone).replaceAll(\"&#10;      \", \"\").replaceAll(/((\\s|\")\\d*\\.\\d{2})(\\d*)(\\b|\"|\\))/g, \"$1\");\n  }\n  static getSvgAsDataUrl(svg, scale = 1) {\n    const svgString = _TLDR.getSvgString(svg, scale);\n    const base64SVG = window.btoa(unescape(svgString));\n    return `data:image/svg+xml;base64,${base64SVG}`;\n  }\n  static async getImageForSvg(svg, type = \"png\" /* PNG */, options = {}) {\n    const { scale = 2, quality = 1 } = options;\n    const svgString = _TLDR.getSvgString(svg, scale);\n    const width = +svg.getAttribute(\"width\");\n    const height = +svg.getAttribute(\"height\");\n    if (!svgString)\n      return;\n    const canvas = await new Promise((resolve) => {\n      const image = new Image();\n      image.crossOrigin = \"anonymous\";\n      const base64SVG = window.btoa(unescape(encodeURIComponent(svgString)));\n      const dataUrl = `data:image/svg+xml;base64,${base64SVG}`;\n      image.onload = () => {\n        const canvas2 = document.createElement(\"canvas\");\n        const context = canvas2.getContext(\"2d\");\n        canvas2.width = width;\n        canvas2.height = height;\n        context.drawImage(image, 0, 0, width, height);\n        URL.revokeObjectURL(dataUrl);\n        resolve(canvas2);\n      };\n      image.onerror = () => {\n        console.warn(\"Could not convert that SVG to an image.\");\n      };\n      image.src = dataUrl;\n    });\n    const blob = await new Promise((resolve) => canvas.toBlob((blob2) => resolve(blob2), \"image/\" + type, quality));\n    return blob;\n  }\n};\nvar TLDR = _TLDR;\n__publicField(TLDR, \"copyStringToClipboard\", (string) => {\n  try {\n    if (navigator.clipboard) {\n      navigator.clipboard.write([\n        new ClipboardItem({\n          \"text/plain\": new Blob([string], { type: \"text/plain\" })\n        })\n      ]);\n    }\n  } catch {\n    const textarea = document.createElement(\"textarea\");\n    textarea.setAttribute(\"position\", \"fixed\");\n    textarea.setAttribute(\"top\", \"0\");\n    textarea.setAttribute(\"readonly\", \"true\");\n    textarea.setAttribute(\"contenteditable\", \"true\");\n    textarea.style.position = \"fixed\";\n    textarea.value = string;\n    document.body.appendChild(textarea);\n    textarea.focus();\n    textarea.select();\n    try {\n      const range = document.createRange();\n      range.selectNodeContents(textarea);\n      const sel = window.getSelection();\n      if (sel != void 0) {\n        sel.removeAllRanges();\n        sel.addRange(range);\n        textarea.setSelectionRange(0, textarea.value.length);\n      }\n      document.execCommand(\"copy\");\n    } catch {\n      null;\n    } finally {\n      textarea.remove();\n    }\n  }\n});\n__publicField(TLDR, \"flattenShape\", (data, shape) => {\n  return [\n    shape,\n    ...(shape.children ?? []).map((childId) => _TLDR.getShape(data, childId, data.appState.currentPageId)).sort((a7, b6) => a7.childIndex - b6.childIndex).flatMap((shape2) => _TLDR.flattenShape(data, shape2))\n  ];\n});\n__publicField(TLDR, \"flattenPage\", (data, pageId) => {\n  return Object.values(data.document.pages[pageId].shapes).sort((a7, b6) => a7.childIndex - b6.childIndex).reduce((accumulator, shape) => [...accumulator, ..._TLDR.flattenShape(data, shape)], []);\n});\n__publicField(TLDR, \"getTopChildIndex\", (data, pageId) => {\n  const shapes = _TLDR.getShapes(data, pageId);\n  return shapes.length === 0 ? 1 : shapes.filter((shape) => shape.parentId === pageId).sort((a7, b6) => b6.childIndex - a7.childIndex)[0].childIndex + 1;\n});\n__publicField(TLDR, \"fixNewLines\", /\\r?\\n|\\r/g);\n\n// src/components/Tldraw/state/shapes/shared/TextLabel.tsx\nvar import_jsx_runtime62 = require(\"react/jsx-runtime\");\nvar TextLabel = React45.memo(function TextLabel2({\n  font,\n  text,\n  color,\n  offsetX = 0,\n  offsetY = 0,\n  scale = 1,\n  isEditing = false,\n  onBlur,\n  onChange\n}) {\n  const rInput = React45.useRef(null);\n  const rIsMounted = React45.useRef(false);\n  const handleChange = React45.useCallback(\n    (e5) => {\n      onChange(TLDR.normalizeText(e5.currentTarget.value));\n    },\n    [onChange]\n  );\n  const handleKeyDown = React45.useCallback(\n    (e5) => {\n      if (e5.key === \"Escape\") {\n        e5.preventDefault();\n        e5.stopPropagation();\n        onBlur?.();\n        return;\n      }\n      if (e5.key === \"Tab\" && text.length === 0) {\n        e5.preventDefault();\n        return;\n      }\n      if (!(e5.key === \"Meta\" || e5.metaKey)) {\n        e5.stopPropagation();\n      } else if (e5.key === \"z\" && e5.metaKey) {\n        if (e5.shiftKey) {\n          document.execCommand(\"redo\", false);\n        } else {\n          document.execCommand(\"undo\", false);\n        }\n        e5.stopPropagation();\n        e5.preventDefault();\n        return;\n      }\n      if ((e5.metaKey || e5.ctrlKey) && e5.key === \"=\") {\n        e5.preventDefault();\n      }\n      if (e5.key === \"Tab\") {\n        e5.preventDefault();\n        if (e5.shiftKey) {\n          TextAreaUtils.unindent(e5.currentTarget);\n        } else {\n          TextAreaUtils.indent(e5.currentTarget);\n        }\n        onChange?.(TLDR.normalizeText(e5.currentTarget.value));\n      }\n    },\n    [onChange]\n  );\n  const handleBlur = React45.useCallback(\n    (e5) => {\n      e5.currentTarget.setSelectionRange(0, 0);\n      onBlur?.();\n    },\n    [onBlur]\n  );\n  const handleFocus = React45.useCallback(\n    (e5) => {\n      if (!isEditing)\n        return;\n      if (!rIsMounted.current)\n        return;\n      if (document.activeElement === e5.currentTarget) {\n        e5.currentTarget.select();\n      }\n    },\n    [isEditing]\n  );\n  const handlePointerDown = React45.useCallback(\n    (e5) => {\n      if (isEditing) {\n        e5.stopPropagation();\n      }\n    },\n    [isEditing]\n  );\n  const rWasEditing = React45.useRef(isEditing);\n  React45.useEffect(() => {\n    if (isEditing) {\n      rWasEditing.current = true;\n      requestAnimationFrame(() => {\n        rIsMounted.current = true;\n        const elm = rInput.current;\n        if (elm) {\n          elm.focus();\n          elm.select();\n        }\n      });\n    } else if (rWasEditing.current) {\n      onBlur?.();\n      rWasEditing.current = false;\n    }\n  }, [isEditing, onBlur]);\n  const rInnerWrapper = React45.useRef(null);\n  React45.useLayoutEffect(() => {\n    const elm = rInnerWrapper.current;\n    if (!elm)\n      return;\n    const size = getTextLabelSize(text, font);\n    elm.style.transform = `scale(${scale}, ${scale}) translate(${offsetX}px, ${offsetY}px)`;\n    elm.style.width = size[0] + 1 + \"px\";\n    elm.style.height = size[1] + 1 + \"px\";\n  }, [text, font, offsetY, offsetX, scale]);\n  return /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(TextWrapper, { children: /* @__PURE__ */ (0, import_jsx_runtime62.jsxs)(\n    InnerWrapper2,\n    {\n      ref: rInnerWrapper,\n      hasText: !!text,\n      isEditing,\n      style: {\n        font,\n        color\n      },\n      children: [\n        isEditing ? /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(\n          TextArea2,\n          {\n            ref: rInput,\n            style: {\n              font,\n              color\n            },\n            name: \"text\",\n            tabIndex: -1,\n            autoComplete: \"false\",\n            autoCapitalize: \"false\",\n            autoCorrect: \"false\",\n            autoSave: \"false\",\n            autoFocus: true,\n            placeholder: \"\",\n            spellCheck: \"true\",\n            wrap: \"off\",\n            dir: \"auto\",\n            datatype: \"wysiwyg\",\n            defaultValue: text,\n            color,\n            onFocus: handleFocus,\n            onChange: handleChange,\n            onKeyDown: handleKeyDown,\n            onBlur: handleBlur,\n            onPointerDown: handlePointerDown,\n            onContextMenu: stopPropagation,\n            onCopy: stopPropagation,\n            onPaste: stopPropagation,\n            onCut: stopPropagation\n          }\n        ) : text,\n        \"\\u200B\"\n      ]\n    }\n  ) });\n});\nvar TextWrapper = styled(\"div\", {\n  position: \"absolute\",\n  top: 0,\n  left: 0,\n  width: \"100%\",\n  height: \"100%\",\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  pointerEvents: \"none\",\n  userSelect: \"none\",\n  variants: {\n    isGhost: {\n      false: { opacity: 1 },\n      true: { transition: \"opacity .2s\", opacity: GHOSTED_OPACITY }\n    }\n  }\n});\nvar commonTextWrapping3 = {\n  whiteSpace: \"pre-wrap\",\n  overflowWrap: \"break-word\",\n  letterSpacing: LETTER_SPACING\n};\nvar InnerWrapper2 = styled(\"div\", {\n  position: \"absolute\",\n  padding: \"4px\",\n  zIndex: 1,\n  minHeight: 1,\n  minWidth: 1,\n  lineHeight: 1,\n  outline: 0,\n  fontWeight: \"500\",\n  textAlign: \"center\",\n  backfaceVisibility: \"hidden\",\n  userSelect: \"none\",\n  WebkitUserSelect: \"none\",\n  WebkitTouchCallout: \"none\",\n  variants: {\n    hasText: {\n      false: {\n        pointerEvents: \"none\"\n      },\n      true: {\n        pointerEvents: \"all\"\n      }\n    },\n    isEditing: {\n      false: {\n        userSelect: \"none\"\n      },\n      true: {\n        background: \"$boundsBg\",\n        userSelect: \"text\",\n        WebkitUserSelect: \"text\"\n      }\n    }\n  },\n  ...commonTextWrapping3\n});\nvar TextArea2 = styled(\"textarea\", {\n  position: \"absolute\",\n  top: 0,\n  left: 0,\n  zIndex: 1,\n  width: \"100%\",\n  height: \"100%\",\n  border: \"none\",\n  padding: \"4px\",\n  resize: \"none\",\n  textAlign: \"inherit\",\n  minHeight: \"inherit\",\n  minWidth: \"inherit\",\n  lineHeight: \"inherit\",\n  outline: 0,\n  fontWeight: \"inherit\",\n  overflow: \"hidden\",\n  backfaceVisibility: \"hidden\",\n  display: \"inline-block\",\n  pointerEvents: \"all\",\n  background: \"$boundsBg\",\n  userSelect: \"text\",\n  WebkitUserSelect: \"text\",\n  fontSmooth: \"always\",\n  WebkitFontSmoothing: \"subpixel-antialiased\",\n  MozOsxFontSmoothing: \"auto\",\n  ...commonTextWrapping3,\n  \"&:focus\": {\n    outline: \"none\",\n    border: \"none\"\n  }\n});\n\n// src/components/Tldraw/state/shapes/shared/transformRectangle.ts\nfunction transformRectangle(shape, bounds, { initialShape, transformOrigin, scaleX, scaleY }) {\n  if (shape.rotation || initialShape.isAspectRatioLocked) {\n    const size = p.toFixed(p.mul(initialShape.size, Math.min(Math.abs(scaleX), Math.abs(scaleY))));\n    const point = p.toFixed([\n      bounds.minX + (bounds.width - shape.size[0]) * (scaleX < 0 ? 1 - transformOrigin[0] : transformOrigin[0]),\n      bounds.minY + (bounds.height - shape.size[1]) * (scaleY < 0 ? 1 - transformOrigin[1] : transformOrigin[1])\n    ]);\n    const rotation = scaleX < 0 && scaleY >= 0 || scaleY < 0 && scaleX >= 0 ? initialShape.rotation ? -initialShape.rotation : 0 : initialShape.rotation;\n    return {\n      size,\n      point,\n      rotation\n    };\n  } else {\n    return {\n      point: p.toFixed([bounds.minX, bounds.minY]),\n      size: p.toFixed([bounds.width, bounds.height])\n    };\n  }\n}\n\n// src/components/Tldraw/state/shapes/shared/transformSingleRectangle.ts\nfunction transformSingleRectangle(shape, bounds) {\n  return {\n    size: p.toFixed([bounds.width, bounds.height]),\n    point: p.toFixed([bounds.minX, bounds.minY])\n  };\n}\n\n// src/components/Tldraw/components/TopPanel/StyleMenu/StyleMenu.tsx\nvar import_jsx_runtime63 = require(\"react/jsx-runtime\");\nvar currentStyleSelector = (s5) => s5.appState.currentStyle;\nvar selectedIdsSelector = (s5) => s5.document.pageStates[s5.appState.currentPageId].selectedIds;\nvar STYLE_KEYS = Object.keys(defaultTextStyle);\nvar DASH_ICONS = {\n  [\"draw\" /* Draw */]: /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(DashDrawIcon, {}),\n  [\"solid\" /* Solid */]: /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(DashSolidIcon, {}),\n  [\"dashed\" /* Dashed */]: /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(DashDashedIcon, {}),\n  [\"dotted\" /* Dotted */]: /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(DashDottedIcon, {})\n};\nvar SIZE_ICONS = {\n  [\"small\" /* Small */]: /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(SizeSmallIcon, {}),\n  [\"medium\" /* Medium */]: /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(SizeMediumIcon, {}),\n  [\"large\" /* Large */]: /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(SizeLargeIcon, {})\n};\nvar ALIGN_ICONS = {\n  [\"start\" /* Start */]: /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(TextAlignLeftIcon, {}),\n  [\"middle\" /* Middle */]: /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(TextAlignCenterIcon, {}),\n  [\"end\" /* End */]: /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(TextAlignRightIcon, {}),\n  [\"justify\" /* Justify */]: /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(TextAlignJustifyIcon, {})\n};\nvar themeSelector = (s5) => \"light\";\nvar keepOpenSelector = (s5) => s5.settings.keepStyleMenuOpen;\nvar optionsSelector = (s5) => {\n  const { activeTool, currentPageId: pageId } = s5.appState;\n  switch (activeTool) {\n    case \"select\": {\n      const page = s5.document.pages[pageId];\n      let hasText = false;\n      let hasLabel = false;\n      for (const id of s5.document.pageStates[pageId].selectedIds) {\n        if (\"text\" in page.shapes[id])\n          hasText = true;\n        if (\"label\" in page.shapes[id])\n          hasLabel = true;\n      }\n      return hasText ? \"text\" : hasLabel ? \"label\" : \"\";\n    }\n    case \"text\" /* Text */: {\n      return \"text\";\n    }\n    case \"rectangle\" /* Rectangle */: {\n      return \"label\";\n    }\n    case \"ellipse\" /* Ellipse */: {\n      return \"label\";\n    }\n    case \"triangle\" /* Triangle */: {\n      return \"label\";\n    }\n    case \"arrow\" /* Arrow */: {\n      return \"label\";\n    }\n    case \"line\" /* Line */: {\n      return \"label\";\n    }\n  }\n  return false;\n};\nvar StyleMenu = React46.memo(function ColorMenu() {\n  const app = useTldrawApp();\n  const theme = app.useStore(themeSelector);\n  const keepOpen = app.useStore(keepOpenSelector);\n  const options = app.useStore(optionsSelector);\n  const currentStyle = app.useStore(currentStyleSelector);\n  const selectedIds = app.useStore(selectedIdsSelector);\n  const [displayedStyle, setDisplayedStyle] = React46.useState(currentStyle);\n  const rDisplayedStyle = React46.useRef(currentStyle);\n  React46.useEffect(() => {\n    const {\n      appState: { currentStyle: currentStyle2 },\n      page,\n      selectedIds: selectedIds2\n    } = app;\n    let commonStyle = {};\n    if (selectedIds2.length <= 0) {\n      commonStyle = currentStyle2;\n    } else {\n      const overrides = /* @__PURE__ */ new Set([]);\n      app.selectedIds.map((id) => page.shapes[id]).forEach((shape) => {\n        STYLE_KEYS.forEach((key) => {\n          if (overrides.has(key))\n            return;\n          if (commonStyle[key] === void 0) {\n            commonStyle[key] = shape.style[key];\n          } else {\n            if (commonStyle[key] === shape.style[key])\n              return;\n            commonStyle[key] = shape.style[key];\n            overrides.add(key);\n          }\n        });\n      });\n    }\n    if (JSON.stringify(commonStyle) !== JSON.stringify(rDisplayedStyle.current)) {\n      rDisplayedStyle.current = commonStyle;\n      setDisplayedStyle(commonStyle);\n    }\n  }, [currentStyle, selectedIds]);\n  const handleToggleKeepOpen = React46.useCallback((checked) => {\n    app.setSetting(\"keepStyleMenuOpen\", checked);\n  }, []);\n  const handleToggleFilled = React46.useCallback((checked) => {\n    app.style({ isFilled: checked });\n  }, []);\n  const handleDashChange = React46.useCallback((value) => {\n    app.style({ dash: value });\n  }, []);\n  const handleSizeChange = React46.useCallback((value) => {\n    app.style({ size: value });\n  }, []);\n  const handleFontChange = React46.useCallback((value) => {\n    app.style({ font: value });\n  }, []);\n  const handleTextAlignChange = React46.useCallback((value) => {\n    app.style({ textAlign: value });\n  }, []);\n  const handleMenuOpenChange = React46.useCallback(\n    (open) => {\n      app.setMenuOpen(open);\n    },\n    [app]\n  );\n  return /* @__PURE__ */ (0, import_jsx_runtime63.jsxs)($d08ef79370b62062$export$be92b6f5f03c0fe9, { dir: \"ltr\", onOpenChange: handleMenuOpenChange, open: keepOpen ? true : void 0, modal: false, children: [\n    /* @__PURE__ */ (0, import_jsx_runtime63.jsx)($d08ef79370b62062$export$41fb9f06171c75f4, { asChild: true, id: \"TD-Styles\", children: /* @__PURE__ */ (0, import_jsx_runtime63.jsxs)(ToolButton, { variant: \"text\", children: [\n      /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(FormattedMessage, { id: \"styles\" }),\n      /* @__PURE__ */ (0, import_jsx_runtime63.jsxs)(\n        OverlapIcons,\n        {\n          style: {\n            color: strokes[theme][displayedStyle.color]\n          },\n          children: [\n            displayedStyle.isFilled && /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(CircleIcon2, { size: 16, stroke: \"none\", fill: fills[theme][displayedStyle.color] }),\n            DASH_ICONS[displayedStyle.dash]\n          ]\n        }\n      )\n    ] }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime63.jsxs)(DMContent, { id: \"language-menu\", side: \"bottom\", align: \"end\", sideOffset: 4, alignOffset: 4, children: [\n      /* @__PURE__ */ (0, import_jsx_runtime63.jsxs)(StyledRow, { variant: \"tall\", id: \"TD-Styles-Color-Container\", children: [\n        /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(\"span\", { children: /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(FormattedMessage, { id: \"style.menu.color\" }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(ColorGrid, { children: Object.keys(strokes.light).map((style) => /* @__PURE__ */ (0, import_jsx_runtime63.jsx)($d08ef79370b62062$export$6d08773d2e66f8f2, { onSelect: preventEvent, asChild: true, id: `TD-Styles-Color-Swatch-${style}`, children: /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(ToolButton, { variant: \"icon\", isActive: displayedStyle.color === style, onClick: () => app.style({ color: style }), children: /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(\n          CircleIcon2,\n          {\n            size: 18,\n            strokeWidth: 2.5,\n            fill: displayedStyle.isFilled ? fills[theme][style] : \"transparent\",\n            stroke: strokes.light[style]\n          }\n        ) }) }, style)) })\n      ] }),\n      /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(DMCheckboxItem, { variant: \"styleMenu\", checked: !!displayedStyle.isFilled, onCheckedChange: handleToggleFilled, id: \"TD-Styles-Fill\", children: /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(FormattedMessage, { id: \"style.menu.fill\" }) }),\n      /* @__PURE__ */ (0, import_jsx_runtime63.jsxs)(StyledRow, { id: \"TD-Styles-Dash-Container\", children: [\n        /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(FormattedMessage, { id: \"style.menu.dash\" }),\n        /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(StyledGroup, { dir: \"ltr\", value: displayedStyle.dash, onValueChange: handleDashChange, children: Object.values(DashStyle).map((style) => /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(\n          DMRadioItem,\n          {\n            isActive: style === displayedStyle.dash,\n            value: style,\n            onSelect: preventEvent,\n            bp: breakpoints,\n            id: `TD-Styles-Dash-${style}`,\n            children: DASH_ICONS[style]\n          },\n          style\n        )) })\n      ] }),\n      /* @__PURE__ */ (0, import_jsx_runtime63.jsxs)(StyledRow, { id: \"TD-Styles-Size-Container\", children: [\n        /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(FormattedMessage, { id: \"style.menu.size\" }),\n        /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(StyledGroup, { dir: \"ltr\", value: displayedStyle.size, onValueChange: handleSizeChange, children: Object.values(SizeStyle).map((sizeStyle) => /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(\n          DMRadioItem,\n          {\n            isActive: sizeStyle === displayedStyle.size,\n            value: sizeStyle,\n            onSelect: preventEvent,\n            bp: breakpoints,\n            id: `TD-Styles-Dash-${sizeStyle}`,\n            children: SIZE_ICONS[sizeStyle]\n          },\n          sizeStyle\n        )) })\n      ] }),\n      (options === \"text\" || options === \"label\") && /* @__PURE__ */ (0, import_jsx_runtime63.jsxs)(import_jsx_runtime63.Fragment, { children: [\n        /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(Divider, {}),\n        /* @__PURE__ */ (0, import_jsx_runtime63.jsxs)(StyledRow, { id: \"TD-Styles-Font-Container\", children: [\n          /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(FormattedMessage, { id: \"style.menu.font\" }),\n          /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(StyledGroup, { dir: \"ltr\", value: displayedStyle.font, onValueChange: handleFontChange, children: Object.values(FontStyle).map((fontStyle) => /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(\n            DMRadioItem,\n            {\n              isActive: fontStyle === displayedStyle.font,\n              value: fontStyle,\n              onSelect: preventEvent,\n              bp: breakpoints,\n              id: `TD-Styles-Font-${fontStyle}`,\n              children: /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(FontIcon, { fontStyle, children: \"Aa\" })\n            },\n            fontStyle\n          )) })\n        ] }),\n        options === \"text\" && /* @__PURE__ */ (0, import_jsx_runtime63.jsxs)(StyledRow, { id: \"TD-Styles-Align-Container\", children: [\n          /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(FormattedMessage, { id: \"style.menu.align\" }),\n          /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(StyledGroup, { dir: \"ltr\", value: displayedStyle.textAlign, onValueChange: handleTextAlignChange, children: Object.values(AlignStyle).map((style) => /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(\n            DMRadioItem,\n            {\n              isActive: style === displayedStyle.textAlign,\n              value: style,\n              onSelect: preventEvent,\n              bp: breakpoints,\n              id: `TD-Styles-Align-${style}`,\n              children: ALIGN_ICONS[style]\n            },\n            style\n          )) })\n        ] })\n      ] }),\n      /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(Divider, {}),\n      /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(DMCheckboxItem, { variant: \"styleMenu\", checked: keepOpen, onCheckedChange: handleToggleKeepOpen, id: \"TD-Styles-Keep-Open\", children: /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(FormattedMessage, { id: \"style.menu.keep.open\" }) })\n    ] })\n  ] });\n});\nvar ColorGrid = styled(\"div\", {\n  display: \"grid\",\n  gridTemplateColumns: \"repeat(4, auto)\",\n  gap: 0\n});\nvar StyledRow = styled(\"div\", {\n  position: \"relative\",\n  width: \"100%\",\n  background: \"none\",\n  border: \"none\",\n  cursor: \"pointer\",\n  minHeight: \"32px\",\n  outline: \"none\",\n  color: \"$text\",\n  fontFamily: \"$ui\",\n  fontWeight: 400,\n  fontSize: \"$1\",\n  padding: \"$2 0 $2 $3\",\n  borderRadius: 4,\n  userSelect: \"none\",\n  margin: 0,\n  display: \"flex\",\n  gap: \"$3\",\n  flexDirection: \"row\",\n  alignItems: \"center\",\n  justifyContent: \"space-between\",\n  variants: {\n    variant: {\n      tall: {\n        alignItems: \"flex-start\",\n        padding: \"0 0 0 $3\",\n        \"& > span\": {\n          paddingTop: \"$4\"\n        }\n      }\n    }\n  }\n});\nvar StyledGroup = styled($d08ef79370b62062$export$3323ad73d55f587e, {\n  display: \"flex\",\n  flexDirection: \"row\",\n  gap: \"$1\"\n});\nvar OverlapIcons = styled(\"div\", {\n  display: \"grid\",\n  \"& > *\": {\n    gridColumn: 1,\n    gridRow: 1\n  }\n});\nvar FontIcon = styled(\"div\", {\n  width: 32,\n  height: 32,\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  fontSize: \"$3\",\n  variants: {\n    fontStyle: {\n      [\"script\" /* Script */]: {\n        fontFamily: \"Caveat Brush\"\n      },\n      [\"sans\" /* Sans */]: {\n        fontFamily: \"Recursive\"\n      },\n      [\"serif\" /* Serif */]: {\n        fontFamily: \"Georgia\"\n      },\n      [\"mono\" /* Mono */]: {\n        fontFamily: \"Recursive Mono\"\n      }\n    }\n  }\n});\n\n// src/components/Tldraw/components/TopPanel/ZoomMenu/ZoomMenu.tsx\nvar import_jsx_runtime64 = require(\"react/jsx-runtime\");\nvar zoomSelector = (s5) => s5.document.pageStates[s5.appState.currentPageId].camera.zoom;\nvar ZoomMenu = function ZoomMenu2() {\n  const app = useTldrawApp();\n  const zoom = app.useStore(zoomSelector);\n  return /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)($d08ef79370b62062$export$be92b6f5f03c0fe9, { dir: \"ltr\", children: [\n    /* @__PURE__ */ (0, import_jsx_runtime64.jsx)($d08ef79370b62062$export$41fb9f06171c75f4, { dir: \"ltr\", asChild: true, id: \"TD-Zoom\", children: /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)(FixedWidthToolButton, { onDoubleClick: app.resetZoom, variant: \"text\", children: [\n      Math.round(zoom * 100),\n      \"%\"\n    ] }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)(DMContent, { align: \"end\", children: [\n      /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(DMItem, { onSelect: preventEvent, onClick: app.zoomIn, kbd: \"#+\", id: \"TD-Zoom-Zoom_In\", children: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(FormattedMessage, { id: \"zoom.in\" }) }),\n      /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(DMItem, { onSelect: preventEvent, onClick: app.zoomOut, kbd: \"#\\u2212\", id: \"TD-Zoom-Zoom_Out\", children: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(FormattedMessage, { id: \"zoom.out\" }) }),\n      /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)(DMItem, { onSelect: preventEvent, onClick: app.resetZoom, kbd: \"\\u21E70\", id: \"TD-Zoom-Zoom_To_100%\", children: [\n        /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(FormattedMessage, { id: \"zoom.to\" }),\n        \" 100%\"\n      ] }),\n      /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(DMItem, { onSelect: preventEvent, onClick: app.zoomToFit, kbd: \"\\u21E71\", id: \"TD-Zoom-To_Fit\", children: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(FormattedMessage, { id: \"zoom.to.fit\" }) }),\n      /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(DMItem, { onSelect: preventEvent, onClick: app.zoomToSelection, kbd: \"\\u21E72\", id: \"TD-Zoom-To_Selection\", children: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(FormattedMessage, { id: \"zoom.to.selection\" }) })\n    ] })\n  ] });\n};\nvar FixedWidthToolButton = styled(ToolButton, {\n  minWidth: 56\n});\n\n// src/components/Tldraw/components/TopPanel/TopPanel.tsx\nvar import_jsx_runtime65 = require(\"react/jsx-runtime\");\nfunction _TopPanel({ readOnly, showPages, showMenu, showStyles, showZoom }) {\n  const app = useTldrawApp();\n  return /* @__PURE__ */ (0, import_jsx_runtime65.jsxs)(StyledTopPanel, { children: [\n    (showMenu || showPages) && /* @__PURE__ */ (0, import_jsx_runtime65.jsxs)(Panel, { side: \"left\", id: \"TD-MenuPanel\", children: [\n      showMenu && /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(Menu, { readOnly }),\n      showPages && /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(PageMenu, {})\n    ] }),\n    /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(StyledSpacer, {}),\n    (showStyles || showZoom) && /* @__PURE__ */ (0, import_jsx_runtime65.jsxs)(Panel, { side: \"right\", children: [\n      readOnly ? /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(ReadOnlyLabel, { children: \"Read Only\" }) : /* @__PURE__ */ (0, import_jsx_runtime65.jsxs)(import_jsx_runtime65.Fragment, { children: [\n        /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(ToolButton, { children: /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(UndoIcon, { onClick: app.undo }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(ToolButton, { children: /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(UndoIcon, { onClick: app.redo, flipHorizontal: true }) })\n      ] }),\n      showZoom && /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(ZoomMenu, {}),\n      showStyles && !readOnly && /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(StyleMenu, {})\n    ] })\n  ] });\n}\nvar StyledTopPanel = styled(\"div\", {\n  width: \"100%\",\n  position: \"absolute\",\n  top: 0,\n  left: 0,\n  right: 0,\n  display: \"flex\",\n  flexDirection: \"row\",\n  pointerEvents: \"none\",\n  \"& > *\": {\n    pointerEvents: \"all\"\n  }\n});\nvar StyledSpacer = styled(\"div\", {\n  flexGrow: 2,\n  pointerEvents: \"none\"\n});\nvar ReadOnlyLabel = styled(\"div\", {\n  width: \"100%\",\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  fontFamily: \"$ui\",\n  fontSize: \"$1\",\n  paddingLeft: \"$4\",\n  paddingRight: \"$1\",\n  userSelect: \"none\"\n});\nvar TopPanel = React47.memo(_TopPanel);\n\n// src/components/Tldraw/hooks/useCursor.ts\nvar import_react40 = __toESM(require(\"react\"));\nfunction useCursor(reference) {\n  import_react40.default.useEffect(() => {\n    let isPointing = false;\n    let isSpacePanning = false;\n    const elm = reference.current;\n    if (elm == void 0)\n      return;\n    const onKeyDown = (e5) => {\n      if (e5.key === \" \" && !isSpacePanning) {\n        isSpacePanning = true;\n        if (isPointing) {\n          elm.setAttribute(\"style\", \"cursor: grabbing !important\");\n        } else {\n          elm.setAttribute(\"style\", \"cursor: grab !important\");\n        }\n      }\n    };\n    const onKeyUp = (e5) => {\n      if (e5.key === \" \") {\n        isSpacePanning = false;\n        elm.setAttribute(\"style\", \"cursor: initial\");\n      }\n    };\n    const onPointerDown = (e5) => {\n      isPointing = true;\n      if (e5.button === 1) {\n        elm.setAttribute(\"style\", \"cursor: grabbing !important\");\n      }\n      if (e5.button === 0 && isSpacePanning) {\n        elm.setAttribute(\"style\", \"cursor: grabbing !important\");\n      }\n    };\n    const onPointerUp = () => {\n      isPointing = false;\n      if (isSpacePanning) {\n        elm.setAttribute(\"style\", \"cursor: grab !important\");\n      } else {\n        elm.setAttribute(\"style\", \"cursor: initial\");\n      }\n    };\n    elm.addEventListener(\"keydown\", onKeyDown);\n    elm.addEventListener(\"keyup\", onKeyUp);\n    elm.addEventListener(\"pointerdown\", onPointerDown);\n    elm.addEventListener(\"pointerup\", onPointerUp);\n    return () => {\n      elm.removeEventListener(\"keydown\", onKeyDown);\n      elm.removeEventListener(\"keyup\", onKeyUp);\n      elm.removeEventListener(\"pointerdown\", onPointerDown);\n      elm.removeEventListener(\"pointerup\", onPointerUp);\n    };\n  }, [reference.current]);\n}\n\n// node_modules/zustand/esm/vanilla.mjs\nvar createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\") ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const destroy = () => listeners.clear();\n  const api = { setState, getState, subscribe, destroy };\n  state = createState(setState, getState, api);\n  return api;\n};\nvar createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;\n\n// node_modules/zustand/esm/index.mjs\nvar import_react41 = require(\"react\");\nvar import_with_selector = __toESM(require_with_selector(), 1);\nvar { useSyncExternalStoreWithSelector } = import_with_selector.default;\nfunction useStore(api, selector = api.getState, equalityFn) {\n  const slice = useSyncExternalStoreWithSelector(\n    api.subscribe,\n    api.getState,\n    api.getServerState || api.getState,\n    selector,\n    equalityFn\n  );\n  (0, import_react41.useDebugValue)(slice);\n  return slice;\n}\nvar createImpl = (createState) => {\n  const api = typeof createState === \"function\" ? createStore(createState) : createState;\n  const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);\n  Object.assign(useBoundStore, api);\n  return useBoundStore;\n};\nvar create = (createState) => createState ? createImpl(createState) : createImpl;\n\n// src/components/Tldraw/state/StateManager/StateManager.ts\nvar StateManager = class {\n  initialState;\n  store;\n  pointer = -1;\n  _state;\n  _status = \"loading\";\n  stack = [];\n  _snapshot;\n  useStore;\n  ready;\n  isPaused = false;\n  constructor(initialState, id, version, update) {\n    this._state = deepCopy(initialState);\n    this._snapshot = deepCopy(initialState);\n    this.initialState = deepCopy(initialState);\n    this.store = createStore(() => this._state);\n    this.useStore = create(this.store);\n    this.ready = new Promise((resolve) => {\n      let message = \"none\";\n      this._status = \"ready\";\n      resolve(message);\n    }).then((message) => {\n      if (this.onReady)\n        this.onReady(message);\n      return message;\n    });\n  }\n  persist = (patch, id) => {\n    if (this._status !== \"ready\")\n      return;\n    if (this.onPersist) {\n      this.onPersist(this._state, patch, id);\n    }\n  };\n  applyPatch = (patch, id) => {\n    const prev = this._state;\n    const next = C3.deepMerge(this._state, patch);\n    const final = this.cleanup(next, prev, patch, id);\n    if (this.onStateWillChange) {\n      this.onStateWillChange(final, id);\n    }\n    this._state = final;\n    this.store.setState(this._state, true);\n    if (this.onStateDidChange) {\n      this.onStateDidChange(this._state, id);\n    }\n    return this;\n  };\n  migrate = (next) => {\n    return next;\n  };\n  cleanup = (nextState, _prevState, _patch, _id) => nextState;\n  onStateWillChange;\n  onStateDidChange;\n  patchState = (patch, id) => {\n    this.applyPatch(patch, id);\n    if (this.onPatch) {\n      this.onPatch(this._state, patch, id);\n    }\n    return this;\n  };\n  replaceState = (state, id) => {\n    const final = this.cleanup(state, this._state, state, id);\n    if (this.onStateWillChange) {\n      this.onStateWillChange(final, \"replace\");\n    }\n    this._state = final;\n    this.store.setState(this._state, true);\n    if (this.onStateDidChange) {\n      this.onStateDidChange(this._state, \"replace\");\n    }\n    return this;\n  };\n  setState = (command, id = command.id) => {\n    if (this.pointer < this.stack.length - 1) {\n      this.stack = this.stack.slice(0, this.pointer + 1);\n    }\n    this.stack.push({ ...command, id });\n    this.pointer = this.stack.length - 1;\n    this.applyPatch(command.after, id);\n    if (this.onCommand)\n      this.onCommand(this._state, command, id);\n    this.persist(command.after, id);\n    return this;\n  };\n  pause() {\n    this.isPaused = true;\n  }\n  resume() {\n    this.isPaused = false;\n  }\n  onReady;\n  onPatch;\n  onCommand;\n  onPersist;\n  onReplace;\n  onReset;\n  onResetHistory;\n  onUndo;\n  onRedo;\n  reset = () => {\n    if (this.onStateWillChange) {\n      this.onStateWillChange(this.initialState, \"reset\");\n    }\n    this._state = this.initialState;\n    this.store.setState(this._state, true);\n    this.resetHistory();\n    this.persist({}, \"reset\");\n    if (this.onStateDidChange) {\n      this.onStateDidChange(this._state, \"reset\");\n    }\n    if (this.onReset) {\n      this.onReset(this._state);\n    }\n    return this;\n  };\n  replaceHistory = (history, pointer = history.length - 1) => {\n    this.stack = history;\n    this.pointer = pointer;\n    if (this.onReplace) {\n      this.onReplace(this._state);\n    }\n    return this;\n  };\n  resetHistory = () => {\n    this.stack = [];\n    this.pointer = -1;\n    if (this.onResetHistory) {\n      this.onResetHistory(this._state);\n    }\n    return this;\n  };\n  undo = () => {\n    if (!this.isPaused) {\n      if (!this.canUndo)\n        return this;\n      const command = this.stack[this.pointer];\n      this.pointer--;\n      this.applyPatch(command.before, `undo`);\n      this.persist(command.before, \"undo\");\n    }\n    if (this.onUndo)\n      this.onUndo(this._state);\n    return this;\n  };\n  redo = () => {\n    if (!this.isPaused) {\n      if (!this.canRedo)\n        return this;\n      this.pointer++;\n      const command = this.stack[this.pointer];\n      this.applyPatch(command.after, \"redo\");\n      this.persist(command.after, \"undo\");\n    }\n    if (this.onRedo)\n      this.onRedo(this._state);\n    return this;\n  };\n  setSnapshot = () => {\n    this._snapshot = { ...this._state };\n    return this;\n  };\n  forceUpdate = () => {\n    this.store.setState(this._state, true);\n  };\n  get canUndo() {\n    return this.pointer > -1;\n  }\n  get canRedo() {\n    return this.pointer < this.stack.length - 1;\n  }\n  get state() {\n    return this._state;\n  }\n  get status() {\n    return this._status;\n  }\n  get snapshot() {\n    return this._snapshot;\n  }\n};\n\n// src/components/Tldraw/state/commands/alignShapes/alignShapes.ts\nfunction alignShapes(app, ids, type) {\n  const { currentPageId } = app;\n  const initialShapes = ids.map((id) => app.getShape(id));\n  const boundsForShapes = initialShapes.map((shape) => {\n    return {\n      id: shape.id,\n      point: [...shape.point],\n      bounds: TLDR.getBounds(shape)\n    };\n  });\n  const commonBounds = C3.getCommonBounds(boundsForShapes.map(({ bounds }) => bounds));\n  const midX = commonBounds.minX + commonBounds.width / 2;\n  const midY = commonBounds.minY + commonBounds.height / 2;\n  const deltaMap = Object.fromEntries(\n    boundsForShapes.map(({ id, point, bounds }) => {\n      return [\n        id,\n        {\n          prev: point,\n          next: {\n            [\"top\" /* Top */]: [point[0], commonBounds.minY],\n            [\"centerVertical\" /* CenterVertical */]: [point[0], midY - bounds.height / 2],\n            [\"bottom\" /* Bottom */]: [point[0], commonBounds.maxY - bounds.height],\n            [\"left\" /* Left */]: [commonBounds.minX, point[1]],\n            [\"centerHorizontal\" /* CenterHorizontal */]: [midX - bounds.width / 2, point[1]],\n            [\"right\" /* Right */]: [commonBounds.maxX - bounds.width, point[1]]\n          }[type]\n        }\n      ];\n    })\n  );\n  const { before, after } = TLDR.mutateShapes(\n    app.state,\n    ids,\n    (shape) => {\n      if (!deltaMap[shape.id])\n        return shape;\n      return { point: deltaMap[shape.id].next };\n    },\n    currentPageId,\n    false\n  );\n  initialShapes.forEach((shape) => {\n    if (shape.type === \"group\" /* Group */) {\n      const delta = e.sub(after[shape.id].point, before[shape.id].point);\n      shape.children.forEach((id) => {\n        const child = app.getShape(id);\n        before[child.id] = { point: child.point };\n        after[child.id] = { point: e.add(child.point, delta) };\n      });\n      delete before[shape.id];\n      delete after[shape.id];\n    }\n  });\n  return {\n    id: \"align\",\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: before\n          }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: after\n          }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/changePage/changePage.ts\nfunction changePage(app, pageId) {\n  return {\n    id: \"change_page\",\n    before: {\n      appState: {\n        currentPageId: app.currentPageId\n      }\n    },\n    after: {\n      appState: {\n        currentPageId: pageId\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/shared/getIncrementedName.ts\nfunction getIncrementedName(name, others) {\n  let result = name;\n  const set = new Set(others);\n  while (set.has(result)) {\n    result = /^.*(\\d+)$/.exec(result)?.[1] ? result.replace(/(\\d+)(?=\\D?)$/, (m6) => (+m6 + 1).toString()) : `${result} 1`;\n  }\n  return result;\n}\n\n// src/components/Tldraw/state/commands/shared/removeShapesFromPage.ts\nfunction removeShapesFromPage(data, ids, pageId) {\n  const before = {\n    shapes: {},\n    bindings: {}\n  };\n  const after = {\n    shapes: {},\n    bindings: {}\n  };\n  const parentsToUpdate = [];\n  const deletedIds = /* @__PURE__ */ new Set();\n  const assetsToRemove = /* @__PURE__ */ new Set();\n  ids.filter((id) => !TLDR.getShape(data, id, pageId).isLocked).forEach((id) => {\n    deletedIds.add(id);\n    const shape = TLDR.getShape(data, id, pageId);\n    before.shapes[id] = shape;\n    after.shapes[id] = void 0;\n    if (shape.children !== void 0) {\n      shape.children.forEach((childId) => {\n        deletedIds.add(childId);\n        const child = TLDR.getShape(data, childId, pageId);\n        before.shapes[childId] = child;\n        after.shapes[childId] = void 0;\n      });\n    }\n    if (shape.parentId !== pageId) {\n      parentsToUpdate.push(TLDR.getShape(data, shape.parentId, pageId));\n    }\n    if (shape.assetId) {\n      assetsToRemove.add(shape.assetId);\n    }\n  });\n  parentsToUpdate.forEach((parent) => {\n    if (ids.includes(parent.id))\n      return;\n    deletedIds.add(parent.id);\n    before.shapes[parent.id] = { children: parent.children };\n    after.shapes[parent.id] = { children: parent.children.filter((id) => !ids.includes(id)) };\n    if (after.shapes[parent.id]?.children.length === 0) {\n      after.shapes[parent.id] = void 0;\n      before.shapes[parent.id] = TLDR.getShape(data, parent.id, pageId);\n    }\n  });\n  const page = TLDR.getPage(data, pageId);\n  Object.values(page.bindings).filter((binding) => deletedIds.has(binding.fromId) || deletedIds.has(binding.toId)).forEach((binding) => {\n    for (const id of [binding.toId, binding.fromId]) {\n      if (after.shapes[id] === void 0) {\n        before.bindings[binding.id] = binding;\n        after.bindings[binding.id] = void 0;\n        const shape = page.shapes[id];\n        if (shape && shape.handles) {\n          Object.values(shape.handles).filter((handle) => handle.bindingId === binding.id).forEach((handle) => {\n            before.shapes[id] = {\n              ...before.shapes[id],\n              handles: {\n                ...before.shapes[id]?.handles,\n                [handle.id]: {\n                  ...before.shapes[id]?.handles?.[handle.id],\n                  bindingId: binding.id\n                }\n              }\n            };\n            if (!deletedIds.has(id)) {\n              after.shapes[id] = {\n                ...after.shapes[id],\n                handles: {\n                  ...after.shapes[id]?.handles,\n                  [handle.id]: {\n                    ...after.shapes[id]?.handles?.[handle.id],\n                    bindingId: void 0\n                  }\n                }\n              };\n            }\n          });\n        }\n      }\n    }\n  });\n  Object.values(data.document.pages).flatMap((page2) => Object.values(page2.shapes)).forEach((shape) => {\n    if (\"assetId\" in shape && shape.assetId && !deletedIds.has(shape.id)) {\n      assetsToRemove.delete(shape.assetId);\n    }\n  });\n  return { before, after, assetsToRemove: [...assetsToRemove] };\n}\n\n// src/components/Tldraw/state/commands/createPage/createPage.ts\nfunction createPage(app, center, pageId = C3.uniqueId(), pageName = \"Page\") {\n  const { currentPageId } = app;\n  const pages = Object.values(app.state.document.pages).sort((a7, b6) => (a7.childIndex ?? 0) - (b6.childIndex ?? 0));\n  const topPage = pages[pages.length - 1];\n  const nextChildIndex = topPage?.childIndex ? topPage?.childIndex + 1 : 1;\n  const page = {\n    id: pageId,\n    name: getIncrementedName(\n      pageName,\n      pages.map((p6) => p6.name ?? \"\")\n    ),\n    childIndex: nextChildIndex,\n    shapes: {},\n    bindings: {}\n  };\n  const pageState = {\n    id: pageId,\n    selectedIds: [],\n    camera: { point: center, zoom: 1 },\n    editingId: void 0,\n    bindingId: void 0,\n    hoveredId: void 0,\n    pointedId: void 0\n  };\n  return {\n    id: \"create_page\",\n    before: {\n      appState: {\n        currentPageId\n      },\n      document: {\n        pages: {\n          [pageId]: void 0\n        },\n        pageStates: {\n          [pageId]: void 0\n        }\n      }\n    },\n    after: {\n      appState: {\n        currentPageId: page.id\n      },\n      document: {\n        pages: {\n          [pageId]: page\n        },\n        pageStates: {\n          [pageId]: pageState\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/createShapes/createShapes.ts\nfunction createShapes(app, shapes, bindings = []) {\n  const { currentPageId } = app;\n  const beforeShapes = {};\n  const afterShapes = {};\n  shapes.forEach((shape) => {\n    beforeShapes[shape.id] = void 0;\n    afterShapes[shape.id] = shape;\n  });\n  const beforeBindings = {};\n  const afterBindings = {};\n  bindings.forEach((binding) => {\n    beforeBindings[binding.id] = void 0;\n    afterBindings[binding.id] = binding;\n  });\n  return {\n    id: \"create\",\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: beforeShapes,\n            bindings: beforeBindings\n          }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: [...app.selectedIds]\n          }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: afterShapes,\n            bindings: afterBindings\n          }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: shapes.map((shape) => shape.id)\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/deletePage/deletePage.ts\nfunction deletePage(app, pageId) {\n  const {\n    currentPageId,\n    document: { pages, pageStates }\n  } = app;\n  const pagesArr = Object.values(pages).sort((a7, b6) => (a7.childIndex || 0) - (b6.childIndex || 0));\n  const currentIndex = pagesArr.findIndex((page) => page.id === pageId);\n  let nextCurrentPageId;\n  if (pageId === currentPageId) {\n    if (currentIndex === pagesArr.length - 1) {\n      nextCurrentPageId = pagesArr[pagesArr.length - 2].id;\n    } else {\n      nextCurrentPageId = pagesArr[currentIndex + 1].id;\n    }\n  } else {\n    nextCurrentPageId = currentPageId;\n  }\n  return {\n    id: \"delete_page\",\n    before: {\n      appState: {\n        currentPageId: pageId\n      },\n      document: {\n        pages: {\n          [pageId]: { ...pages[pageId] }\n        },\n        pageStates: {\n          [pageId]: { ...pageStates[pageId] }\n        }\n      }\n    },\n    after: {\n      appState: {\n        currentPageId: nextCurrentPageId\n      },\n      document: {\n        pages: {\n          [pageId]: void 0\n        },\n        pageStates: {\n          [pageId]: void 0\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/deleteShapes/deleteShapes.ts\nvar removeAssetsFromDocument = (assets, idsToRemove) => {\n  const afterAssets = { ...assets };\n  idsToRemove.forEach((id) => afterAssets[id] = void 0);\n  return afterAssets;\n};\nfunction deleteShapes(app, ids, pageId = app.currentPageId) {\n  const {\n    pageState,\n    selectedIds,\n    document: { assets: beforeAssets }\n  } = app;\n  const { before, after, assetsToRemove } = removeShapesFromPage(app.state, ids, pageId);\n  const afterAssets = removeAssetsFromDocument(beforeAssets, assetsToRemove);\n  return {\n    id: \"delete\",\n    before: {\n      document: {\n        assets: beforeAssets,\n        pages: {\n          [pageId]: before\n        },\n        pageStates: {\n          [pageId]: { selectedIds: [...app.selectedIds] }\n        }\n      }\n    },\n    after: {\n      document: {\n        assets: afterAssets,\n        pages: {\n          [pageId]: after\n        },\n        pageStates: {\n          [pageId]: {\n            selectedIds: selectedIds.filter((id) => !ids.includes(id)),\n            hoveredId: pageState.hoveredId && ids.includes(pageState.hoveredId) ? void 0 : pageState.hoveredId\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/distributeShapes/distributeShapes.ts\nfunction distributeShapes(app, ids, type) {\n  const { currentPageId } = app;\n  const initialShapes = ids.map((id) => app.getShape(id));\n  const deltaMap = Object.fromEntries(getDistributions(initialShapes, type).map((d6) => [d6.id, d6]));\n  const { before, after } = TLDR.mutateShapes(\n    app.state,\n    ids.filter((id) => deltaMap[id] !== void 0),\n    (shape) => ({ point: deltaMap[shape.id]?.next }),\n    currentPageId\n  );\n  initialShapes.forEach((shape) => {\n    if (shape.type === \"group\" /* Group */) {\n      const delta = p.sub(after[shape.id].point, before[shape.id].point);\n      shape.children.forEach((id) => {\n        const child = app.getShape(id);\n        before[child.id] = { point: child.point };\n        after[child.id] = { point: p.add(child.point, delta) };\n      });\n      delete before[shape.id];\n      delete after[shape.id];\n    }\n  });\n  return {\n    id: \"distribute\",\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: before }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: after }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    }\n  };\n}\nfunction getDistributions(initialShapes, type) {\n  const entries = initialShapes.map((shape) => {\n    const utils = TLDR.getShapeUtil(shape);\n    return {\n      id: shape.id,\n      point: [...shape.point],\n      bounds: utils.getBounds(shape),\n      center: utils.getCenter(shape)\n    };\n  });\n  const len = entries.length;\n  const commonBounds = C3.getCommonBounds(entries.map(({ bounds }) => bounds));\n  const results = [];\n  switch (type) {\n    case \"horizontal\" /* Horizontal */: {\n      const span = entries.reduce((a7, c5) => a7 + c5.bounds.width, 0);\n      if (span > commonBounds.width) {\n        const left = entries.sort((a7, b6) => a7.bounds.minX - b6.bounds.minX)[0];\n        const right = entries.sort((a7, b6) => b6.bounds.maxX - a7.bounds.maxX)[0];\n        const entriesToMove = entries.filter((a7) => a7 !== left && a7 !== right).sort((a7, b6) => a7.center[0] - b6.center[0]);\n        const step = (right.center[0] - left.center[0]) / (len - 1);\n        const x5 = left.center[0] + step;\n        entriesToMove.forEach(({ id, point, bounds }, i4) => {\n          results.push({\n            id,\n            prev: point,\n            next: [x5 + step * i4 - bounds.width / 2, bounds.minY]\n          });\n        });\n      } else {\n        const entriesToMove = entries.sort((a7, b6) => a7.center[0] - b6.center[0]);\n        let x5 = commonBounds.minX;\n        const step = (commonBounds.width - span) / (len - 1);\n        entriesToMove.forEach(({ id, point, bounds }) => {\n          results.push({ id, prev: point, next: [x5, bounds.minY] });\n          x5 += bounds.width + step;\n        });\n      }\n      break;\n    }\n    case \"vertical\" /* Vertical */: {\n      const span = entries.reduce((a7, c5) => a7 + c5.bounds.height, 0);\n      if (span > commonBounds.height) {\n        const top2 = entries.sort((a7, b6) => a7.bounds.minY - b6.bounds.minY)[0];\n        const bottom = entries.sort((a7, b6) => b6.bounds.maxY - a7.bounds.maxY)[0];\n        const entriesToMove = entries.filter((a7) => a7 !== top2 && a7 !== bottom).sort((a7, b6) => a7.center[1] - b6.center[1]);\n        const step = (bottom.center[1] - top2.center[1]) / (len - 1);\n        const y6 = top2.center[1] + step;\n        entriesToMove.forEach(({ id, point, bounds }, i4) => {\n          results.push({\n            id,\n            prev: point,\n            next: [bounds.minX, y6 + step * i4 - bounds.height / 2]\n          });\n        });\n      } else {\n        const entriesToMove = entries.sort((a7, b6) => a7.center[1] - b6.center[1]);\n        let y6 = commonBounds.minY;\n        const step = (commonBounds.height - span) / (len - 1);\n        entriesToMove.forEach(({ id, point, bounds }) => {\n          results.push({ id, prev: point, next: [bounds.minX, y6] });\n          y6 += bounds.height + step;\n        });\n      }\n      break;\n    }\n  }\n  return results;\n}\n\n// src/components/Tldraw/state/commands/duplicatePage/duplicatePage.ts\nfunction duplicatePage(app, pageId) {\n  const {\n    currentPageId,\n    pageState: { camera }\n  } = app;\n  const page = app.document.pages[pageId];\n  const newId = C3.uniqueId();\n  const nextPage = {\n    ...page,\n    id: newId,\n    name: page.name + \" Copy\",\n    shapes: Object.fromEntries(\n      Object.entries(page.shapes).map(([id, shape]) => {\n        return [\n          id,\n          {\n            ...shape,\n            parentId: shape.parentId === page.id ? newId : shape.parentId\n          }\n        ];\n      })\n    )\n  };\n  return {\n    id: \"duplicate_page\",\n    before: {\n      appState: {\n        currentPageId\n      },\n      document: {\n        pages: {\n          [newId]: void 0\n        },\n        pageStates: {\n          [newId]: void 0\n        }\n      }\n    },\n    after: {\n      appState: {\n        currentPageId: newId\n      },\n      document: {\n        pages: {\n          [newId]: nextPage\n        },\n        pageStates: {\n          [newId]: {\n            ...page,\n            id: newId,\n            selectedIds: [],\n            camera: { ...camera },\n            editingId: void 0,\n            bindingId: void 0,\n            hoveredId: void 0,\n            pointedId: void 0\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/duplicateShapes/duplicateShapes.ts\nfunction duplicateShapes(app, ids, point) {\n  const { selectedIds, currentPageId, page, shapes } = app;\n  const before = {\n    shapes: {},\n    bindings: {}\n  };\n  const after = {\n    shapes: {},\n    bindings: {}\n  };\n  const duplicateMap = {};\n  const shapesToDuplicate = ids.map((id) => app.getShape(id)).filter((shape) => !ids.includes(shape.parentId));\n  shapesToDuplicate.forEach((shape) => {\n    const duplicatedId = C3.uniqueId();\n    before.shapes[duplicatedId] = void 0;\n    after.shapes[duplicatedId] = {\n      ...C3.deepClone(shape),\n      id: duplicatedId,\n      childIndex: TLDR.getChildIndexAbove(app.state, shape.id, currentPageId)\n    };\n    if (shape.children) {\n      after.shapes[duplicatedId].children = [];\n    }\n    if (shape.parentId !== currentPageId) {\n      const parent = app.getShape(shape.parentId);\n      before.shapes[parent.id] = {\n        ...before.shapes[parent.id],\n        children: parent.children\n      };\n      after.shapes[parent.id] = {\n        ...after.shapes[parent.id],\n        children: [...(after.shapes[parent.id] || parent).children, duplicatedId]\n      };\n    }\n    duplicateMap[shape.id] = duplicatedId;\n  });\n  shapesToDuplicate.forEach((shape) => {\n    if (shape.children) {\n      shape.children.forEach((childId) => {\n        const child = app.getShape(childId);\n        const duplicatedId = C3.uniqueId();\n        const duplicatedParentId = duplicateMap[shape.id];\n        before.shapes[duplicatedId] = void 0;\n        after.shapes[duplicatedId] = {\n          ...C3.deepClone(child),\n          id: duplicatedId,\n          parentId: duplicatedParentId,\n          childIndex: TLDR.getChildIndexAbove(app.state, child.id, currentPageId)\n        };\n        duplicateMap[childId] = duplicatedId;\n        after.shapes[duplicateMap[shape.id]]?.children?.push(duplicatedId);\n      });\n    }\n  });\n  const dupedShapeIds = new Set(Object.keys(duplicateMap));\n  Object.values(page.bindings).filter((binding) => dupedShapeIds.has(binding.fromId) || dupedShapeIds.has(binding.toId)).forEach((binding) => {\n    if (dupedShapeIds.has(binding.fromId)) {\n      if (dupedShapeIds.has(binding.toId)) {\n        const duplicatedBindingId = C3.uniqueId();\n        const duplicatedBinding = {\n          ...C3.deepClone(binding),\n          id: duplicatedBindingId,\n          fromId: duplicateMap[binding.fromId],\n          toId: duplicateMap[binding.toId]\n        };\n        before.bindings[duplicatedBindingId] = void 0;\n        after.bindings[duplicatedBindingId] = duplicatedBinding;\n        const boundShape = after.shapes[duplicatedBinding.fromId];\n        Object.values(boundShape.handles).forEach((handle) => {\n          if (handle.bindingId === binding.id) {\n            handle.bindingId = duplicatedBindingId;\n          }\n        });\n      } else {\n        const boundShape = after.shapes[duplicateMap[binding.fromId]];\n        Object.values(boundShape.handles).forEach((handle) => {\n          if (handle.bindingId === binding.id) {\n            handle.bindingId = void 0;\n          }\n        });\n      }\n    }\n  });\n  const shapesToMove = Object.values(after.shapes);\n  if (point) {\n    const commonBounds = C3.getCommonBounds(shapesToMove.map((shape) => TLDR.getBounds(shape)));\n    const center = C3.getBoundsCenter(commonBounds);\n    shapesToMove.forEach((shape) => {\n      if (!shape.point)\n        return;\n      shape.point = e.sub(point, e.sub(center, shape.point));\n    });\n  } else {\n    const offset = [16, 16];\n    shapesToMove.forEach((shape) => {\n      if (!shape.point)\n        return;\n      shape.point = e.add(shape.point, offset);\n    });\n  }\n  shapesToMove.forEach((shape) => {\n    if (shape.isLocked) {\n      shape.isLocked = false;\n    }\n  });\n  return {\n    id: \"duplicate\",\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: before\n        },\n        pageStates: {\n          [currentPageId]: { selectedIds }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: after\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: [...dupedShapeIds.values()].map((id) => duplicateMap[id])\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/flipShapes/flipShapes.ts\nfunction flipShapes(app, ids, type) {\n  const {\n    selectedIds,\n    currentPageId,\n    page: { shapes }\n  } = app;\n  const boundsForShapes = ids.map((id) => TLDR.getBounds(shapes[id]));\n  const isSinglySelectedGroup = ids.length === 1 && shapes[ids[0]].type === \"group\";\n  const commonBounds = C3.getCommonBounds(boundsForShapes);\n  const { before, after } = TLDR.mutateShapes(\n    app.state,\n    ids,\n    (shape) => {\n      const shapeBounds = TLDR.getBounds(shape);\n      const isChildOfGroup = shape.parentId !== currentPageId;\n      switch (type) {\n        case \"horizontal\" /* Horizontal */: {\n          if (isChildOfGroup && !isSinglySelectedGroup) {\n            const groupBounds = TLDR.getBounds(shapes[shape.parentId]);\n            const newGroupBounds = C3.getRelativeTransformedBoundingBox(commonBounds, commonBounds, groupBounds, true, false);\n            const dx = newGroupBounds.minX - groupBounds.minX;\n            return TLDR.getShapeUtil(shape).transform(\n              shape,\n              { ...shapeBounds, minX: shapeBounds.minX + dx, maxX: shapeBounds.maxX + dx },\n              {\n                type: He.TopLeft,\n                scaleX: 1,\n                scaleY: 1,\n                initialShape: shape,\n                transformOrigin: [0.5, 0.5]\n              }\n            );\n          }\n          const newShapeBounds = C3.getRelativeTransformedBoundingBox(commonBounds, commonBounds, shapeBounds, true, false);\n          return TLDR.getShapeUtil(shape).transform(shape, newShapeBounds, {\n            type: He.TopLeft,\n            scaleX: -1,\n            scaleY: 1,\n            initialShape: shape,\n            transformOrigin: [0.5, 0.5]\n          });\n        }\n        case \"vertical\" /* Vertical */: {\n          if (isChildOfGroup && !isSinglySelectedGroup) {\n            const groupBounds = TLDR.getBounds(shapes[shape.parentId]);\n            const newGroupBounds = C3.getRelativeTransformedBoundingBox(commonBounds, commonBounds, groupBounds, false, true);\n            const dy = newGroupBounds.minY - groupBounds.minY;\n            return TLDR.getShapeUtil(shape).transform(\n              shape,\n              { ...shapeBounds, minY: shapeBounds.minY + dy, maxY: shapeBounds.maxY + dy },\n              {\n                type: He.TopLeft,\n                scaleX: 1,\n                scaleY: 1,\n                initialShape: shape,\n                transformOrigin: [0.5, 0.5]\n              }\n            );\n          }\n          const newShapeBounds = C3.getRelativeTransformedBoundingBox(commonBounds, commonBounds, shapeBounds, false, true);\n          return TLDR.getShapeUtil(shape).transform(shape, newShapeBounds, {\n            type: He.TopLeft,\n            scaleX: 1,\n            scaleY: -1,\n            initialShape: shape,\n            transformOrigin: [0.5, 0.5]\n          });\n        }\n      }\n    },\n    currentPageId,\n    true\n  );\n  return {\n    id: \"flip\",\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: before }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds\n          }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: after }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/groupShapes/groupShapes.ts\nfunction groupShapes(app, ids, groupId, pageId) {\n  if (ids.length < 2)\n    return;\n  const beforeShapes = {};\n  const afterShapes = {};\n  const beforeBindings = {};\n  const afterBindings = {};\n  const idsToGroup = [...ids];\n  const shapesToGroup = [];\n  const deletedGroupIds = [];\n  const otherEffectedGroups = [];\n  for (const id of ids) {\n    const shape = app.getShape(id);\n    if (shape.isLocked)\n      continue;\n    if (shape.children === void 0) {\n      shapesToGroup.push(shape);\n    } else {\n      const childIds = shape.children.filter((id2) => !app.getShape(id2).isLocked);\n      otherEffectedGroups.push(shape);\n      idsToGroup.push(...childIds);\n      shapesToGroup.push(...childIds.map((id2) => app.getShape(id2)).filter(Boolean));\n    }\n  }\n  if (shapesToGroup.every((shape) => shape.parentId === shapesToGroup[0].parentId) && shapesToGroup[0].parentId !== pageId) {\n    const commonParent = app.getShape(shapesToGroup[0].parentId);\n    if (commonParent.children?.length === idsToGroup.length) {\n      return;\n    }\n  }\n  const flattenedShapes = TLDR.flattenPage(app.state, pageId);\n  const shapeIndexMap = Object.fromEntries(shapesToGroup.map((shape) => [shape.id, flattenedShapes.indexOf(shape)]));\n  const sortedShapes = shapesToGroup.sort((a7, b6) => shapeIndexMap[a7.id] - shapeIndexMap[b6.id]);\n  const groupParentId = pageId;\n  const groupChildIndex = (sortedShapes.find((shape) => shape.parentId === pageId) || sortedShapes[0]).childIndex;\n  const groupBounds = C3.getCommonBounds(shapesToGroup.map((shape) => TLDR.getBounds(shape)));\n  beforeShapes[groupId] = void 0;\n  afterShapes[groupId] = TLDR.getShapeUtil(\"group\" /* Group */).create({\n    id: groupId,\n    childIndex: groupChildIndex,\n    parentId: groupParentId,\n    point: [groupBounds.minX, groupBounds.minY],\n    size: [groupBounds.width, groupBounds.height],\n    children: sortedShapes.map((shape) => shape.id)\n  });\n  sortedShapes.forEach((shape, index2) => {\n    if (shape.parentId !== pageId) {\n      const parentShape = app.getShape(shape.parentId);\n      otherEffectedGroups.push(parentShape);\n    }\n    beforeShapes[shape.id] = {\n      ...beforeShapes[shape.id],\n      parentId: shape.parentId,\n      childIndex: shape.childIndex\n    };\n    afterShapes[shape.id] = {\n      ...afterShapes[shape.id],\n      parentId: groupId,\n      childIndex: index2 + 1\n    };\n  });\n  while (otherEffectedGroups.length > 0) {\n    const shape = otherEffectedGroups.pop();\n    if (!shape)\n      break;\n    const nextChildren = (beforeShapes[shape.id]?.children || shape.children).filter(\n      (childId) => childId && !(idsToGroup.includes(childId) || deletedGroupIds.includes(childId))\n    );\n    if (nextChildren.length === 0) {\n      beforeShapes[shape.id] = shape;\n      afterShapes[shape.id] = void 0;\n      if (shape.parentId !== pageId) {\n        deletedGroupIds.push(shape.id);\n        otherEffectedGroups.push(app.getShape(shape.parentId));\n      }\n    } else {\n      beforeShapes[shape.id] = {\n        ...beforeShapes[shape.id],\n        children: shape.children\n      };\n      afterShapes[shape.id] = {\n        ...afterShapes[shape.id],\n        children: nextChildren\n      };\n    }\n  }\n  const { bindings } = app;\n  const deletedGroupIdsSet = new Set(deletedGroupIds);\n  bindings.forEach((binding) => {\n    for (const id of [binding.toId, binding.fromId]) {\n      if (deletedGroupIdsSet.has(id)) {\n        beforeBindings[binding.id] = binding;\n        afterBindings[binding.id] = void 0;\n        const shape = app.getShape(id);\n        if (shape.handles) {\n          Object.values(shape.handles).filter((handle) => handle.bindingId === binding.id).forEach((handle) => {\n            beforeShapes[id] = {\n              ...beforeShapes[id],\n              handles: {\n                ...beforeShapes[id]?.handles,\n                [handle.id]: { bindingId: binding.id }\n              }\n            };\n            if (!deletedGroupIds.includes(id)) {\n              afterShapes[id] = {\n                ...afterShapes[id],\n                handles: {\n                  ...afterShapes[id]?.handles,\n                  [handle.id]: { bindingId: void 0 }\n                }\n              };\n            }\n          });\n        }\n      }\n    }\n  });\n  return {\n    id: \"group\",\n    before: {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: beforeShapes,\n            bindings: beforeBindings\n          }\n        },\n        pageStates: {\n          [pageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: afterShapes,\n            bindings: beforeBindings\n          }\n        },\n        pageStates: {\n          [pageId]: {\n            selectedIds: [groupId]\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/moveShapesToPage/moveShapesToPage.ts\nfunction moveShapesToPage(app, ids, viewportBounds, fromPageId, toPageId) {\n  const { page } = app;\n  const fromPage = {\n    before: {\n      shapes: {},\n      bindings: {}\n    },\n    after: {\n      shapes: {},\n      bindings: {}\n    }\n  };\n  const toPage = {\n    before: {\n      shapes: {},\n      bindings: {}\n    },\n    after: {\n      shapes: {},\n      bindings: {}\n    }\n  };\n  const movingShapeIds = /* @__PURE__ */ new Set();\n  const shapesToMove = /* @__PURE__ */ new Set();\n  ids.map((id) => app.getShape(id, fromPageId)).filter((shape) => !shape.isLocked).forEach((shape) => {\n    movingShapeIds.add(shape.id);\n    shapesToMove.add(shape);\n    if (shape.children !== void 0) {\n      shape.children.forEach((childId) => {\n        movingShapeIds.add(childId);\n        shapesToMove.add(app.getShape(childId, fromPageId));\n      });\n    }\n  });\n  const startingChildIndex = TLDR.getTopChildIndex(app.state, toPageId);\n  const movingShapes = [...shapesToMove.values()];\n  movingShapes.forEach((shape, i4) => {\n    fromPage.before.shapes[shape.id] = shape;\n    fromPage.after.shapes[shape.id] = void 0;\n    toPage.before.shapes[shape.id] = void 0;\n    toPage.after.shapes[shape.id] = shape;\n    if (!movingShapeIds.has(shape.parentId)) {\n      toPage.after.shapes[shape.id] = {\n        ...shape,\n        parentId: toPageId,\n        childIndex: startingChildIndex + i4\n      };\n      if (shape.parentId !== fromPageId) {\n        const parent = app.getShape(shape.parentId, fromPageId);\n        fromPage.before.shapes[parent.id] = {\n          children: parent.children\n        };\n        fromPage.after.shapes[parent.id] = {\n          children: parent.children.filter((childId) => childId !== shape.id)\n        };\n      }\n    }\n  });\n  Object.values(page.bindings).filter((binding) => movingShapeIds.has(binding.fromId) || movingShapeIds.has(binding.toId)).forEach((binding) => {\n    fromPage.before.bindings[binding.id] = binding;\n    fromPage.after.bindings[binding.id] = void 0;\n    const fromBoundShape = app.getShape(binding.fromId, fromPageId);\n    const shouldCopy = movingShapeIds.has(binding.fromId) && movingShapeIds.has(binding.toId);\n    if (shouldCopy) {\n      toPage.before.bindings[binding.id] = void 0;\n      toPage.after.bindings[binding.id] = binding;\n    } else {\n      if (movingShapeIds.has(binding.fromId)) {\n        const fromShape = app.getShape(binding.fromId, fromPageId);\n        const handle = Object.values(fromBoundShape.handles).find((handle2) => handle2.bindingId === binding.id);\n        const handleId = handle.id;\n        const toPageShape = toPage.after.shapes[fromShape.id];\n        toPageShape.handles = {\n          ...toPageShape.handles,\n          [handleId]: {\n            ...toPageShape.handles[handleId],\n            bindingId: void 0\n          }\n        };\n      } else {\n        const fromShape = app.getShape(binding.fromId, fromPageId);\n        const handle = Object.values(fromBoundShape.handles).find((handle2) => handle2.bindingId === binding.id);\n        fromPage.before.shapes[fromShape.id] = {\n          handles: { [handle.id]: { bindingId: binding.id } }\n        };\n        fromPage.after.shapes[fromShape.id] = {\n          handles: { [handle.id]: { bindingId: void 0 } }\n        };\n      }\n    }\n  });\n  const toPageState = app.state.document.pageStates[toPageId];\n  const bounds = C3.getCommonBounds(movingShapes.map((shape) => TLDR.getBounds(shape)));\n  const zoom = TLDR.getCameraZoom(\n    viewportBounds.width < viewportBounds.height ? (viewportBounds.width - 128) / bounds.width : (viewportBounds.height - 128) / bounds.height\n  );\n  const mx = (viewportBounds.width - bounds.width * zoom) / 2 / zoom;\n  const my = (viewportBounds.height - bounds.height * zoom) / 2 / zoom;\n  const point = e.toFixed(e.add([-bounds.minX, -bounds.minY], [mx, my]));\n  return {\n    id: \"move_to_page\",\n    before: {\n      appState: {\n        currentPageId: fromPageId\n      },\n      document: {\n        pages: {\n          [fromPageId]: fromPage.before,\n          [toPageId]: toPage.before\n        },\n        pageStates: {\n          [fromPageId]: { selectedIds: ids },\n          [toPageId]: {\n            selectedIds: toPageState.selectedIds,\n            camera: toPageState.camera\n          }\n        }\n      }\n    },\n    after: {\n      appState: {\n        currentPageId: toPageId\n      },\n      document: {\n        pages: {\n          [fromPageId]: fromPage.after,\n          [toPageId]: toPage.after\n        },\n        pageStates: {\n          [fromPageId]: { selectedIds: [] },\n          [toPageId]: {\n            selectedIds: ids,\n            camera: {\n              zoom,\n              point\n            }\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/movePage/movePage.ts\nfunction movePage(app, pageId, index2) {\n  const { pages } = app.document;\n  const movingPage = pages[pageId];\n  const beforePages = Object.values(pages).sort((a7, b6) => (a7.childIndex ?? 0) - (b6.childIndex ?? 0));\n  const fromIndex = beforePages.indexOf(movingPage);\n  const afterPages = [...beforePages];\n  afterPages.splice(fromIndex, 1);\n  afterPages.splice(index2 > fromIndex ? index2 - 1 : index2, 0, movingPage);\n  return {\n    id: \"move_page\",\n    before: {\n      document: {\n        pages: Object.fromEntries(beforePages.map((p6) => [p6.id, { childIndex: p6.childIndex }]))\n      }\n    },\n    after: {\n      document: {\n        pages: Object.fromEntries(afterPages.map((p6, childIndex) => [p6.id, { childIndex }]))\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/reorderShapes/reorderShapes.ts\nfunction reorderShapes(app, ids, type) {\n  const { currentPageId, page } = app;\n  const parentIds = new Set(ids.map((id) => app.getShape(id).parentId));\n  let result = { before: {}, after: {} };\n  let startIndex;\n  let startChildIndex;\n  let step;\n  [...parentIds.values()].forEach((parentId) => {\n    let sortedChildren = [];\n    if (parentId === page.id) {\n      sortedChildren = Object.values(page.shapes).sort((a7, b6) => a7.childIndex - b6.childIndex);\n    } else {\n      const parent = app.getShape(parentId);\n      if (!parent.children)\n        throw new Error(\"No children in parent!\");\n      sortedChildren = parent.children.map((childId) => app.getShape(childId)).sort((a7, b6) => a7.childIndex - b6.childIndex);\n    }\n    const sortedChildIds = sortedChildren.map((shape) => shape.id);\n    const sortedIndicesToMove = ids.filter((id) => sortedChildIds.includes(id)).map((id) => sortedChildIds.indexOf(id)).sort((a7, b6) => a7 - b6);\n    if (sortedIndicesToMove.length === sortedChildIds.length)\n      return;\n    switch (type) {\n      case \"toBack\" /* ToBack */: {\n        for (let i4 = 0; i4 < sortedChildIds.length; i4++) {\n          if (sortedIndicesToMove.includes(i4))\n            continue;\n          startIndex = i4;\n          break;\n        }\n        startChildIndex = sortedChildren[startIndex].childIndex;\n        step = startChildIndex / (sortedIndicesToMove.length + 1);\n        result = TLDR.mutateShapes(\n          app.state,\n          sortedIndicesToMove.map((i4) => sortedChildren[i4].id).reverse(),\n          (_shape, i4) => ({\n            childIndex: startChildIndex - (i4 + 1) * step\n          }),\n          currentPageId\n        );\n        break;\n      }\n      case \"toFront\" /* ToFront */: {\n        for (let i4 = sortedChildIds.length - 1; i4 >= 0; i4--) {\n          if (sortedIndicesToMove.includes(i4))\n            continue;\n          startIndex = i4;\n          break;\n        }\n        startChildIndex = sortedChildren[startIndex].childIndex;\n        step = 1;\n        result = TLDR.mutateShapes(\n          app.state,\n          sortedIndicesToMove.map((i4) => sortedChildren[i4].id),\n          (_shape, i4) => ({\n            childIndex: startChildIndex + (i4 + 1)\n          }),\n          currentPageId\n        );\n        break;\n      }\n      case \"backward\" /* Backward */: {\n        const indexMap = {};\n        for (let i4 = sortedChildIds.length - 1; i4 >= 0; i4--) {\n          if (sortedIndicesToMove.includes(i4)) {\n            for (let j4 = i4; j4 >= 0; j4--) {\n              if (!sortedIndicesToMove.includes(j4)) {\n                const endChildIndex = sortedChildren[j4].childIndex;\n                let startChildIndex2;\n                let step2;\n                if (j4 === 0) {\n                  startChildIndex2 = endChildIndex / 2;\n                  step2 = endChildIndex / 2 / (i4 - j4 + 1);\n                } else {\n                  startChildIndex2 = sortedChildren[j4 - 1].childIndex;\n                  step2 = (endChildIndex - startChildIndex2) / (i4 - j4 + 1);\n                  startChildIndex2 += step2;\n                }\n                for (let k6 = 0; k6 < i4 - j4; k6++) {\n                  indexMap[sortedChildren[j4 + k6 + 1].id] = startChildIndex2 + step2 * k6;\n                }\n                break;\n              }\n            }\n          }\n        }\n        if (Object.values(indexMap).length > 0) {\n          result = TLDR.mutateShapes(\n            app.state,\n            sortedIndicesToMove.map((i4) => sortedChildren[i4].id),\n            (shape) => ({\n              childIndex: indexMap[shape.id]\n            }),\n            currentPageId\n          );\n        }\n        break;\n      }\n      case \"forward\" /* Forward */: {\n        const indexMap = {};\n        for (let i4 = 0; i4 < sortedChildIds.length; i4++) {\n          if (sortedIndicesToMove.includes(i4)) {\n            for (let j4 = i4; j4 < sortedChildIds.length; j4++) {\n              if (!sortedIndicesToMove.includes(j4)) {\n                startChildIndex = sortedChildren[j4].childIndex;\n                const step2 = j4 === sortedChildIds.length - 1 ? 1 : (sortedChildren[j4 + 1].childIndex - startChildIndex) / (j4 - i4 + 1);\n                for (let k6 = 0; k6 < j4 - i4; k6++) {\n                  indexMap[sortedChildren[i4 + k6].id] = startChildIndex + step2 * (k6 + 1);\n                }\n                break;\n              }\n            }\n          }\n        }\n        if (Object.values(indexMap).length > 0) {\n          result = TLDR.mutateShapes(\n            app.state,\n            sortedIndicesToMove.map((i4) => sortedChildren[i4].id),\n            (shape) => ({\n              childIndex: indexMap[shape.id]\n            }),\n            currentPageId\n          );\n        }\n        break;\n      }\n    }\n  });\n  return {\n    id: \"move\",\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: result.before }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: result.after }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/renamePage/renamePage.ts\nfunction renamePage(app, pageId, name) {\n  const { page } = app;\n  return {\n    id: \"rename_page\",\n    before: {\n      document: {\n        pages: {\n          [pageId]: { name: page.name }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [pageId]: { name }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/resetBounds/resetBounds.ts\nfunction resetBounds(app, ids, pageId) {\n  const { currentPageId } = app;\n  const { before, after } = TLDR.mutateShapes(app.state, ids, (shape) => app.getShapeUtil(shape).onDoubleClickBoundsHandle?.(shape), pageId);\n  return {\n    id: \"reset_bounds\",\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: before }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: after }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/rotateShapes/rotateShapes.ts\nvar PI23 = Math.PI * 2;\nfunction rotateShapes(app, ids, delta = -PI23 / 4) {\n  const { currentPageId } = app;\n  const before = {};\n  const after = {};\n  const shapesToRotate = ids.flatMap((id) => {\n    const shape = app.getShape(id);\n    return shape.children ? shape.children.map((childId) => app.getShape(childId)) : shape;\n  }).filter((shape) => !shape.isLocked);\n  const origin = C3.getBoundsCenter(C3.getCommonBounds(shapesToRotate.map((shape) => TLDR.getBounds(shape))));\n  shapesToRotate.forEach((shape) => {\n    const change = TLDR.getRotatedShapeMutation(shape, TLDR.getCenter(shape), origin, delta);\n    if (!change)\n      return;\n    before[shape.id] = TLDR.getBeforeShape(shape, change);\n    after[shape.id] = change;\n  });\n  return {\n    id: \"rotate\",\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: before }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: after }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/stretchShapes/stretchShapes.ts\nfunction stretchShapes(app, ids, type) {\n  const { currentPageId, selectedIds } = app;\n  const initialShapes = ids.map((id) => app.getShape(id));\n  const boundsForShapes = initialShapes.map((shape) => TLDR.getBounds(shape));\n  const commonBounds = C3.getCommonBounds(boundsForShapes);\n  const idsToMutate = ids.flatMap((id) => {\n    const shape = app.getShape(id);\n    return shape.children ? shape.children : shape.id;\n  }).filter((id) => !app.getShape(id).isLocked);\n  const { before, after } = TLDR.mutateShapes(\n    app.state,\n    idsToMutate,\n    (shape) => {\n      const bounds = TLDR.getBounds(shape);\n      switch (type) {\n        case \"horizontal\" /* Horizontal */: {\n          const newBounds = {\n            ...bounds,\n            minX: commonBounds.minX,\n            maxX: commonBounds.maxX,\n            width: commonBounds.width\n          };\n          return TLDR.getShapeUtil(shape).transformSingle(shape, newBounds, {\n            type: He.TopLeft,\n            scaleX: newBounds.width / bounds.width,\n            scaleY: 1,\n            initialShape: shape,\n            transformOrigin: [0.5, 0.5]\n          });\n        }\n        case \"vertical\" /* Vertical */: {\n          const newBounds = {\n            ...bounds,\n            minY: commonBounds.minY,\n            maxY: commonBounds.maxY,\n            height: commonBounds.height\n          };\n          return TLDR.getShapeUtil(shape).transformSingle(shape, newBounds, {\n            type: He.TopLeft,\n            scaleX: 1,\n            scaleY: newBounds.height / bounds.height,\n            initialShape: shape,\n            transformOrigin: [0.5, 0.5]\n          });\n        }\n      }\n    },\n    currentPageId\n  );\n  initialShapes.forEach((shape) => {\n    if (shape.type === \"group\" /* Group */) {\n      delete before[shape.id];\n      delete after[shape.id];\n    }\n  });\n  return {\n    id: \"stretch\",\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: before }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds\n          }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: after }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/styleShapes/styleShapes.ts\nfunction styleShapes(app, ids, changes) {\n  const { currentPageId, selectedIds } = app;\n  const shapeIdsToMutate = ids.flatMap((id) => TLDR.getDocumentBranch(app.state, id, currentPageId)).filter((id) => !app.getShape(id).isLocked);\n  const beforeShapes = {};\n  const afterShapes = {};\n  shapeIdsToMutate.map((id) => app.getShape(id)).filter((shape) => !shape.isLocked).forEach((shape) => {\n    beforeShapes[shape.id] = {\n      style: {\n        ...Object.fromEntries(Object.keys(changes).map((key) => [key, shape.style[key]]))\n      }\n    };\n    afterShapes[shape.id] = {\n      style: changes\n    };\n    if (shape.type === \"text\" /* Text */) {\n      beforeShapes[shape.id].point = shape.point;\n      afterShapes[shape.id].point = e.toFixed(\n        e.add(\n          shape.point,\n          e.sub(\n            app.getShapeUtil(shape).getCenter(shape),\n            app.getShapeUtil(shape).getCenter({\n              ...shape,\n              style: { ...shape.style, ...changes }\n            })\n          )\n        )\n      );\n    }\n  });\n  return {\n    id: \"style\",\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: beforeShapes\n          }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds\n          }\n        }\n      },\n      appState: {\n        currentStyle: { ...app.appState.currentStyle }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: afterShapes\n          }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      },\n      appState: {\n        currentStyle: changes\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/toggleShapesDecoration/toggleShapesDecoration.ts\nfunction toggleShapesDecoration(app, ids, decorationId) {\n  const { currentPageId, selectedIds } = app;\n  const beforeShapes = Object.fromEntries(\n    ids.map((id) => [\n      id,\n      {\n        decorations: {\n          [decorationId]: app.getShape(id).decorations?.[decorationId]\n        }\n      }\n    ])\n  );\n  const afterShapes = Object.fromEntries(\n    ids.filter((id) => !app.getShape(id).isLocked).map((id) => [\n      id,\n      {\n        decorations: {\n          [decorationId]: app.getShape(id).decorations?.[decorationId] ? void 0 : \"arrow\" /* Arrow */\n        }\n      }\n    ])\n  );\n  return {\n    id: \"toggle_decorations\",\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: beforeShapes }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds\n          }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: afterShapes }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/toggleShapesProp/toggleShapesProp.ts\nfunction toggleShapeProp(app, ids, prop) {\n  const { currentPageId } = app;\n  const initialShapes = ids.map((id) => app.getShape(id)).filter((shape) => prop === \"isLocked\" ? true : !shape.isLocked);\n  const isAllToggled = initialShapes.every((shape) => shape[prop]);\n  const before = {};\n  const after = {};\n  initialShapes.forEach((shape) => {\n    before[shape.id] = { [prop]: shape[prop] };\n    after[shape.id] = { [prop]: !isAllToggled };\n  });\n  return {\n    id: \"toggle\",\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: before\n          }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: after\n          }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/translateShapes/translateShapes.ts\nfunction translateShapes(app, ids, delta) {\n  const { currentPageId, selectedIds } = app;\n  app.rotationInfo.selectedIds = [...selectedIds];\n  const before = {\n    shapes: {},\n    bindings: {}\n  };\n  const after = {\n    shapes: {},\n    bindings: {}\n  };\n  const idsToMutate = ids.flatMap((id) => {\n    const shape = app.getShape(id);\n    return shape.children ? shape.children : shape.id;\n  }).filter((id) => !app.getShape(id).isLocked);\n  const change = TLDR.mutateShapes(\n    app.state,\n    idsToMutate,\n    (shape) => ({\n      point: e.toFixed(e.add(shape.point, delta))\n    }),\n    currentPageId\n  );\n  before.shapes = change.before;\n  after.shapes = change.after;\n  const bindingsToDelete = TLDR.getBindings(app.state, currentPageId).filter((binding) => ids.includes(binding.fromId) && !ids.includes(binding.toId));\n  bindingsToDelete.forEach((binding) => {\n    before.bindings[binding.id] = binding;\n    after.bindings[binding.id] = void 0;\n    for (const id of [binding.toId, binding.fromId]) {\n      const shape = app.getShape(id);\n      if (!shape.handles)\n        continue;\n      Object.values(shape.handles).filter((handle) => handle.bindingId === binding.id).forEach((handle) => {\n        before.shapes[id] = {\n          ...before.shapes[id],\n          handles: {\n            ...before.shapes[id]?.handles,\n            [handle.id]: { bindingId: binding.id }\n          }\n        };\n        after.shapes[id] = {\n          ...after.shapes[id],\n          handles: { ...after.shapes[id]?.handles, [handle.id]: { bindingId: void 0 } }\n        };\n      });\n    }\n  });\n  return {\n    id: \"translate\",\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: before\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: after\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/ungroupShapes/ungroupShapes.ts\nfunction ungroupShapes(app, selectedIds, groupShapes2, pageId) {\n  const { bindings } = app;\n  const beforeShapes = {};\n  const afterShapes = {};\n  const beforeBindings = {};\n  const afterBindings = {};\n  const beforeSelectedIds = selectedIds;\n  const afterSelectedIds = selectedIds.filter((id) => !groupShapes2.find((shape) => shape.id === id));\n  groupShapes2.filter((shape) => !shape.isLocked).forEach((groupShape) => {\n    const shapesToReparent = [];\n    const deletedGroupIds = [];\n    beforeShapes[groupShape.id] = groupShape;\n    afterShapes[groupShape.id] = void 0;\n    groupShape.children.forEach((id) => {\n      afterSelectedIds.push(id);\n      const shape = app.getShape(id, pageId);\n      shapesToReparent.push(shape);\n    });\n    const startingChildIndex = groupShape.childIndex;\n    const endingChildIndex = TLDR.getChildIndexAbove(app.state, groupShape.id, pageId);\n    const step = (endingChildIndex - startingChildIndex) / shapesToReparent.length;\n    const sortedShapes = shapesToReparent.sort((a7, b6) => a7.childIndex - b6.childIndex);\n    sortedShapes.forEach((shape, index2) => {\n      beforeShapes[shape.id] = {\n        parentId: shape.parentId,\n        childIndex: shape.childIndex\n      };\n      afterShapes[shape.id] = {\n        parentId: pageId,\n        childIndex: startingChildIndex + step * index2\n      };\n    });\n    bindings.filter((binding) => binding.toId === groupShape.id || binding.fromId === groupShape.id).forEach((binding) => {\n      for (const id of [binding.toId, binding.fromId]) {\n        if (afterShapes[id] === void 0) {\n          beforeBindings[binding.id] = binding;\n          afterBindings[binding.id] = void 0;\n          const shape = app.getShape(id, pageId);\n          if (shape.handles) {\n            Object.values(shape.handles).filter((handle) => handle.bindingId === binding.id).forEach((handle) => {\n              beforeShapes[id] = {\n                ...beforeShapes[id],\n                handles: {\n                  ...beforeShapes[id]?.handles,\n                  [handle.id]: { bindingId: binding.id }\n                }\n              };\n              if (!deletedGroupIds.includes(id)) {\n                afterShapes[id] = {\n                  ...afterShapes[id],\n                  handles: {\n                    ...afterShapes[id]?.handles,\n                    [handle.id]: { bindingId: void 0 }\n                  }\n                };\n              }\n            });\n          }\n        }\n      }\n    });\n  });\n  return {\n    id: \"ungroup\",\n    before: {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: beforeShapes,\n            bindings: beforeBindings\n          }\n        },\n        pageStates: {\n          [pageId]: {\n            selectedIds: beforeSelectedIds\n          }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: afterShapes,\n            bindings: beforeBindings\n          }\n        },\n        pageStates: {\n          [pageId]: {\n            selectedIds: afterSelectedIds\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/updateShapes/updateShapes.ts\nfunction updateShapes(app, updates, pageId) {\n  const ids = updates.map((update) => update.id);\n  const change = TLDR.mutateShapes(\n    app.state,\n    ids.filter((id) => !app.getShape(id, pageId).isLocked),\n    (_shape, i4) => updates[i4],\n    pageId\n  );\n  return {\n    id: \"update\",\n    before: {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: change.before\n          }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: change.after\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/setShapesProps/setShapesProps.ts\nfunction setShapesProps(app, ids, partial) {\n  const { currentPageId, selectedIds } = app;\n  const initialShapes = ids.map((id) => app.getShape(id)).filter((shape) => partial.isLocked ? true : !shape.isLocked);\n  const before = {};\n  const after = {};\n  const keys = Object.keys(partial);\n  initialShapes.forEach((shape) => {\n    before[shape.id] = Object.fromEntries(keys.map((key) => [key, shape[key]]));\n    after[shape.id] = partial;\n  });\n  return {\n    id: \"set_props\",\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: before\n          }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds\n          }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: after\n          }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/insertContent/insertContent.ts\nfunction insertContent(app, content, opts = {}) {\n  const { currentPageId } = app;\n  const { point, select, overwrite } = opts;\n  const page = app.document.pages[currentPageId];\n  const before = {\n    shapes: {},\n    bindings: {}\n  };\n  const afterAssets = {};\n  const after = {\n    shapes: {},\n    bindings: {}\n  };\n  if (overwrite) {\n    for (const shape of content.shapes) {\n      before.shapes[shape.id] = page.shapes[shape.id];\n      after.shapes[shape.id] = shape;\n    }\n    if (content.bindings) {\n      for (const binding of content.bindings) {\n        before.bindings[binding.id] = page.bindings[binding.id];\n        after.bindings[binding.id] = binding;\n      }\n    }\n    if (content.assets) {\n      for (const asset of content.assets) {\n        afterAssets[asset.id] = asset;\n      }\n    }\n  } else {\n    const oldToNewIds = {};\n    let nextIndex = TLDR.getTopChildIndex(app.state, currentPageId);\n    const shapesToInsert = content.shapes.sort((a7, b6) => a7.childIndex - b6.childIndex).map((shape) => {\n      const newShapeId = C3.uniqueId();\n      oldToNewIds[shape.id] = newShapeId;\n      return {\n        ...C3.deepClone(shape),\n        id: newShapeId\n      };\n    });\n    const visited = /* @__PURE__ */ new Set();\n    while (shapesToInsert.length > 0) {\n      const shape = shapesToInsert.shift();\n      if (!shape)\n        break;\n      visited.add(shape.id);\n      if (shape.parentId === \"currentPageId\") {\n        shape.parentId = currentPageId;\n        shape.childIndex = nextIndex++;\n      } else {\n        shape.parentId = oldToNewIds[shape.parentId];\n        const parent = after.shapes[shape.parentId];\n        if (!parent) {\n          if (visited.has(shape.id)) {\n            shape.parentId = \"currentPageId\";\n          }\n          shapesToInsert.push(shape);\n          continue;\n        }\n        parent.children.push(shape.id);\n      }\n      if (shape.children) {\n        shape.children = [];\n      }\n      before.shapes[shape.id] = void 0;\n      after.shapes[shape.id] = shape;\n    }\n    Object.values(after.shapes).forEach((shape) => {\n      if (shape.children && shape.children.length === 0) {\n        delete before.shapes[shape.id];\n        delete after.shapes[shape.id];\n      }\n    });\n    if (content.bindings) {\n      content.bindings.forEach((binding) => {\n        const newBindingId = C3.uniqueId();\n        oldToNewIds[binding.id] = newBindingId;\n        const toId = oldToNewIds[binding.toId];\n        const fromId = oldToNewIds[binding.fromId];\n        if (!toId || !fromId) {\n          if (fromId) {\n            const handles = after.shapes[fromId].handles;\n            if (handles) {\n              Object.values(handles).forEach((handle) => {\n                if (handle.bindingId === binding.id) {\n                  handle.bindingId = void 0;\n                }\n              });\n            }\n          }\n          if (toId) {\n            const handles = after.shapes[toId].handles;\n            if (handles) {\n              Object.values(handles).forEach((handle) => {\n                if (handle.bindingId === binding.id) {\n                  handle.bindingId = void 0;\n                }\n              });\n            }\n          }\n          return;\n        }\n        const fromHandles = after.shapes[fromId].handles;\n        if (fromHandles) {\n          Object.values(fromHandles).forEach((handle) => {\n            if (handle.bindingId === binding.id) {\n              handle.bindingId = newBindingId;\n            }\n          });\n        }\n        const toHandles = after.shapes[toId].handles;\n        if (toHandles) {\n          Object.values(after.shapes[toId].handles).forEach((handle) => {\n            if (handle.bindingId === binding.id) {\n              handle.bindingId = newBindingId;\n            }\n          });\n        }\n        const newBinding = {\n          ...C3.deepClone(binding),\n          id: newBindingId,\n          toId,\n          fromId\n        };\n        before.bindings[newBinding.id] = void 0;\n        after.bindings[newBinding.id] = newBinding;\n      });\n    }\n    const shapesToMove = Object.values(after.shapes);\n    if (shapesToMove.length > 0) {\n      if (point) {\n        const commonBounds = C3.getCommonBounds(shapesToMove.map((shape) => TLDR.getBounds(shape)));\n        const center = C3.getBoundsCenter(commonBounds);\n        shapesToMove.forEach((shape) => {\n          if (!shape.point)\n            return;\n          shape.point = e.sub(point, e.sub(center, shape.point));\n        });\n      } else {\n        const commonBounds = C3.getCommonBounds(shapesToMove.map(TLDR.getBounds));\n        if (!(C3.boundsContain(app.viewport, commonBounds) || C3.boundsCollide(app.viewport, commonBounds))) {\n          const center = e.toFixed(app.getPagePoint(app.centerPoint));\n          const centeredBounds = C3.centerBounds(commonBounds, center);\n          const delta = e.sub(C3.getBoundsCenter(centeredBounds), C3.getBoundsCenter(commonBounds));\n          shapesToMove.forEach((shape) => {\n            shape.point = e.toFixed(e.add(shape.point, delta));\n          });\n        }\n      }\n    }\n    if (content.assets) {\n      for (const asset of content.assets) {\n        afterAssets[asset.id] = asset;\n      }\n    }\n  }\n  const elm = document.createElement(\"textarea\");\n  Object.values(after.shapes).forEach((shape) => {\n    if (\"text\" in shape) {\n      elm.innerHTML = shape.text;\n      shape.text = elm.value;\n    }\n    if (\"label\" in shape) {\n      elm.innerHTML = shape.label;\n      shape.label = elm.value;\n    }\n  });\n  elm.remove();\n  return {\n    id: \"insert\",\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: before\n        },\n        pageStates: {\n          [currentPageId]: { selectedIds: [...app.selectedIds] }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: after\n        },\n        assets: afterAssets,\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: select ? Object.keys(after.shapes) : [...app.selectedIds]\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/data/migrate.ts\nfunction migrate(state, newVersion) {\n  const { document: document2, settings } = state;\n  const { version = 0 } = document2;\n  if (!(\"assets\" in document2)) {\n    document2.assets = {};\n  }\n  const assetIdsInUse = /* @__PURE__ */ new Set();\n  Object.values(document2.pages).forEach(\n    (page) => Object.values(page.shapes).forEach((shape) => {\n      const { parentId, children, assetId } = shape;\n      if (assetId) {\n        assetIdsInUse.add(assetId);\n      }\n      if (parentId !== page.id && !page.shapes[parentId]) {\n        console.warn(\"Encountered a shape with a missing parent!\");\n        shape.parentId = page.id;\n      }\n      if (shape.type === \"group\" /* Group */ && children) {\n        children.forEach((childId) => {\n          if (!page.shapes[childId]) {\n            console.warn(\"Encountered a parent with a missing child!\", shape.id, childId);\n            children?.splice(children.indexOf(childId), 1);\n          }\n        });\n      }\n    })\n  );\n  Object.keys(document2.assets).forEach((assetId) => {\n    if (!assetIdsInUse.has(assetId)) {\n      delete document2.assets[assetId];\n    }\n  });\n  if (version !== newVersion) {\n    if (version < 14) {\n      Object.values(document2.pages).forEach((page) => {\n        Object.values(page.shapes).filter((shape) => shape.type === \"text\" /* Text */).forEach((shape) => shape.style.font === \"script\" /* Script */);\n      });\n    }\n    if (version <= 13) {\n      Object.values(document2.pages).forEach((page) => {\n        Object.values(page.bindings).forEach((binding) => {\n          Object.assign(binding, binding.meta);\n        });\n        Object.values(page.shapes).forEach((shape) => {\n          Object.entries(shape.style).forEach(([id, style]) => {\n            if (typeof style === \"string\") {\n              shape.style[id] = style.toLowerCase();\n            }\n          });\n          if (shape.type === \"arrow\" /* Arrow */ && shape.decorations) {\n            Object.entries(shape.decorations).forEach(([id, decoration]) => {\n              if (decoration === \"Arrow\") {\n                shape.decorations = {\n                  ...shape.decorations,\n                  [id]: \"arrow\" /* Arrow */\n                };\n              }\n            });\n          }\n        });\n      });\n    }\n    if (version <= 13.1) {\n      document2.name = \"New Document\";\n    }\n    if (version < 15) {\n      document2.assets = {};\n    }\n    Object.values(document2.pages).forEach((page) => {\n      Object.values(page.shapes).forEach((shape) => {\n        if (version < 15.2 && shape.type === \"image\" /* Image */) {\n          shape.style.isFilled = true;\n        }\n        if (version < 15.3 && (shape.type === \"rectangle\" /* Rectangle */ || shape.type === \"triangle\" /* Triangle */ || shape.type === \"ellipse\" /* Ellipse */ || shape.type === \"arrow\" /* Arrow */)) {\n          shape.label = shape.text || \"\";\n          shape.labelPoint = [0.5, 0.5];\n        }\n      });\n    });\n    if (version < 15.4) {\n      settings.dockPosition = \"bottom\";\n    }\n    if (version < 15.5) {\n      settings.exportBackground = \"transparent\" /* Transparent */;\n    }\n  }\n  Object.values(document2.pageStates).forEach((pageState) => {\n    pageState.selectedIds = pageState.selectedIds.filter((id) => {\n      return document2.pages[pageState.id].shapes[id] !== void 0;\n    });\n    pageState.bindingId = void 0;\n    pageState.editingId = void 0;\n    pageState.hoveredId = void 0;\n    pageState.pointedId = void 0;\n  });\n  document2.version = newVersion;\n  return state;\n}\n\n// node_modules/browser-fs-access/dist/index.modern.js\nvar e4 = (() => {\n  if (\"undefined\" == typeof self)\n    return false;\n  if (\"top\" in self && self !== top)\n    try {\n      top;\n    } catch (e5) {\n      return false;\n    }\n  else if (\"showOpenFilePicker\" in self)\n    return \"showOpenFilePicker\";\n  return false;\n})();\nvar t4 = e4 ? Promise.resolve().then(function() {\n  return l6;\n}) : Promise.resolve().then(function() {\n  return h5;\n});\nasync function n4(...e5) {\n  return (await t4).default(...e5);\n}\nvar r4 = e4 ? Promise.resolve().then(function() {\n  return y5;\n}) : Promise.resolve().then(function() {\n  return P3;\n});\nvar a6 = e4 ? Promise.resolve().then(function() {\n  return m5;\n}) : Promise.resolve().then(function() {\n  return k5;\n});\nvar s4 = async (e5) => {\n  const t5 = await e5.getFile();\n  return t5.handle = e5, t5;\n};\nvar c4 = async (e5 = [{}]) => {\n  Array.isArray(e5) || (e5 = [e5]);\n  const t5 = [];\n  e5.forEach((e6, n6) => {\n    t5[n6] = { description: e6.description || \"Files\", accept: {} }, e6.mimeTypes ? e6.mimeTypes.map((r6) => {\n      t5[n6].accept[r6] = e6.extensions || [];\n    }) : t5[n6].accept[\"*/*\"] = e6.extensions || [];\n  });\n  const n5 = await window.showOpenFilePicker({ id: e5[0].id, startIn: e5[0].startIn, types: t5, multiple: e5[0].multiple || false, excludeAcceptAllOption: e5[0].excludeAcceptAllOption || false }), r5 = await Promise.all(n5.map(s4));\n  return e5[0].multiple ? r5 : r5[0];\n};\nvar l6 = { __proto__: null, default: c4 };\nfunction u4(e5) {\n  function t5(e6) {\n    if (Object(e6) !== e6)\n      return Promise.reject(new TypeError(e6 + \" is not an object.\"));\n    var t6 = e6.done;\n    return Promise.resolve(e6.value).then(function(e7) {\n      return { value: e7, done: t6 };\n    });\n  }\n  return u4 = function(e6) {\n    this.s = e6, this.n = e6.next;\n  }, u4.prototype = { s: null, n: null, next: function() {\n    return t5(this.n.apply(this.s, arguments));\n  }, return: function(e6) {\n    var n5 = this.s.return;\n    return void 0 === n5 ? Promise.resolve({ value: e6, done: true }) : t5(n5.apply(this.s, arguments));\n  }, throw: function(e6) {\n    var n5 = this.s.return;\n    return void 0 === n5 ? Promise.reject(e6) : t5(n5.apply(this.s, arguments));\n  } }, new u4(e5);\n}\nvar p5 = async (e5, t5, n5 = e5.name, r5) => {\n  const i4 = [], a7 = [];\n  var o5, s5 = false, c5 = false;\n  try {\n    for (var l7, d6 = function(e6) {\n      var t6, n6, r6, i5 = 2;\n      for (\"undefined\" != typeof Symbol && (n6 = Symbol.asyncIterator, r6 = Symbol.iterator); i5--; ) {\n        if (n6 && null != (t6 = e6[n6]))\n          return t6.call(e6);\n        if (r6 && null != (t6 = e6[r6]))\n          return new u4(t6.call(e6));\n        n6 = \"@@asyncIterator\", r6 = \"@@iterator\";\n      }\n      throw new TypeError(\"Object is not async iterable\");\n    }(e5.values()); s5 = !(l7 = await d6.next()).done; s5 = false) {\n      const o6 = l7.value, s6 = `${n5}/${o6.name}`;\n      \"file\" === o6.kind ? a7.push(o6.getFile().then((t6) => (t6.directoryHandle = e5, t6.handle = o6, Object.defineProperty(t6, \"webkitRelativePath\", { configurable: true, enumerable: true, get: () => s6 })))) : \"directory\" !== o6.kind || !t5 || r5 && r5(o6) || i4.push(p5(o6, t5, s6, r5));\n    }\n  } catch (e6) {\n    c5 = true, o5 = e6;\n  } finally {\n    try {\n      s5 && null != d6.return && await d6.return();\n    } finally {\n      if (c5)\n        throw o5;\n    }\n  }\n  return [...(await Promise.all(i4)).flat(), ...await Promise.all(a7)];\n};\nvar d5 = async (e5 = {}) => {\n  e5.recursive = e5.recursive || false, e5.mode = e5.mode || \"read\";\n  const t5 = await window.showDirectoryPicker({ id: e5.id, startIn: e5.startIn, mode: e5.mode });\n  return p5(t5, e5.recursive, void 0, e5.skipDirectory);\n};\nvar y5 = { __proto__: null, default: d5 };\nvar f4 = async (e5, t5 = [{}], n5 = null, r5 = false, i4 = null) => {\n  Array.isArray(t5) || (t5 = [t5]), t5[0].fileName = t5[0].fileName || \"Untitled\";\n  const a7 = [];\n  let o5 = null;\n  if (e5 instanceof Blob && e5.type ? o5 = e5.type : e5.headers && e5.headers.get(\"content-type\") && (o5 = e5.headers.get(\"content-type\")), t5.forEach((e6, t6) => {\n    a7[t6] = { description: e6.description || \"Files\", accept: {} }, e6.mimeTypes ? (0 === t6 && o5 && e6.mimeTypes.push(o5), e6.mimeTypes.map((n6) => {\n      a7[t6].accept[n6] = e6.extensions || [];\n    })) : o5 ? a7[t6].accept[o5] = e6.extensions || [] : a7[t6].accept[\"*/*\"] = e6.extensions || [];\n  }), n5)\n    try {\n      await n5.getFile();\n    } catch (e6) {\n      if (n5 = null, r5)\n        throw e6;\n    }\n  const s5 = n5 || await window.showSaveFilePicker({ suggestedName: t5[0].fileName, id: t5[0].id, startIn: t5[0].startIn, types: a7, excludeAcceptAllOption: t5[0].excludeAcceptAllOption || false });\n  !n5 && i4 && i4(s5);\n  const c5 = await s5.createWritable();\n  if (\"stream\" in e5) {\n    const t6 = e5.stream();\n    return await t6.pipeTo(c5), s5;\n  }\n  return \"body\" in e5 ? (await e5.body.pipeTo(c5), s5) : (await c5.write(await e5), await c5.close(), s5);\n};\nvar m5 = { __proto__: null, default: f4 };\nvar w6 = async (e5 = [{}]) => (Array.isArray(e5) || (e5 = [e5]), new Promise((t5, n5) => {\n  const r5 = document.createElement(\"input\");\n  r5.type = \"file\";\n  const i4 = [...e5.map((e6) => e6.mimeTypes || []), ...e5.map((e6) => e6.extensions || [])].join();\n  r5.multiple = e5[0].multiple || false, r5.accept = i4 || \"\", r5.style.display = \"none\", document.body.append(r5);\n  const a7 = (e6) => {\n    \"function\" == typeof o5 && o5(), t5(e6);\n  }, o5 = e5[0].legacySetup && e5[0].legacySetup(a7, () => o5(n5), r5), s5 = () => {\n    window.removeEventListener(\"focus\", s5), r5.remove();\n  };\n  r5.addEventListener(\"click\", () => {\n    window.addEventListener(\"focus\", s5);\n  }), r5.addEventListener(\"change\", () => {\n    window.removeEventListener(\"focus\", s5), r5.remove(), a7(r5.multiple ? Array.from(r5.files) : r5.files[0]);\n  }), \"showPicker\" in HTMLInputElement.prototype ? r5.showPicker() : r5.click();\n}));\nvar h5 = { __proto__: null, default: w6 };\nvar v5 = async (e5 = [{}]) => (Array.isArray(e5) || (e5 = [e5]), e5[0].recursive = e5[0].recursive || false, new Promise((t5, n5) => {\n  const r5 = document.createElement(\"input\");\n  r5.type = \"file\", r5.webkitdirectory = true;\n  const i4 = (e6) => {\n    \"function\" == typeof a7 && a7(), t5(e6);\n  }, a7 = e5[0].legacySetup && e5[0].legacySetup(i4, () => a7(n5), r5);\n  r5.addEventListener(\"change\", () => {\n    let t6 = Array.from(r5.files);\n    e5[0].recursive ? e5[0].recursive && e5[0].skipDirectory && (t6 = t6.filter((t7) => t7.webkitRelativePath.split(\"/\").every((t8) => !e5[0].skipDirectory({ name: t8, kind: \"directory\" })))) : t6 = t6.filter((e6) => 2 === e6.webkitRelativePath.split(\"/\").length), i4(t6);\n  }), \"showPicker\" in HTMLInputElement.prototype ? r5.showPicker() : r5.click();\n}));\nvar P3 = { __proto__: null, default: v5 };\nvar b5 = async (e5, t5 = {}) => {\n  Array.isArray(t5) && (t5 = t5[0]);\n  const n5 = document.createElement(\"a\");\n  let r5 = e5;\n  \"body\" in e5 && (r5 = await async function(e6, t6) {\n    const n6 = e6.getReader(), r6 = new ReadableStream({ start: (e7) => async function t7() {\n      return n6.read().then(({ done: n7, value: r7 }) => {\n        if (!n7)\n          return e7.enqueue(r7), t7();\n        e7.close();\n      });\n    }() }), i5 = new Response(r6), a8 = await i5.blob();\n    return n6.releaseLock(), new Blob([a8], { type: t6 });\n  }(e5.body, e5.headers.get(\"content-type\"))), n5.download = t5.fileName || \"Untitled\", n5.href = URL.createObjectURL(await r5);\n  const i4 = () => {\n    \"function\" == typeof a7 && a7();\n  }, a7 = t5.legacySetup && t5.legacySetup(i4, () => a7(), n5);\n  return n5.addEventListener(\"click\", () => {\n    setTimeout(() => URL.revokeObjectURL(n5.href), 3e4), i4();\n  }), n5.click(), null;\n};\nvar k5 = { __proto__: null, default: b5 };\n\n// src/components/Tldraw/state/data/filesystem.ts\nasync function openAssetsFromFileSystem() {\n  return await n4({\n    description: \"Image\",\n    extensions: [...IMAGE_EXTENSIONS],\n    multiple: true\n  });\n}\nasync function fileToBase64(file) {\n  return await new Promise((resolve, reject) => {\n    if (file) {\n      const reader = new FileReader();\n      reader.readAsDataURL(file);\n      reader.onload = () => resolve(reader.result);\n      reader.onerror = (error) => reject(error);\n      reader.onabort = (error) => reject(error);\n    }\n  });\n}\nasync function fileToText(file) {\n  return await new Promise((resolve, reject) => {\n    if (file) {\n      const reader = new FileReader();\n      reader.readAsText(file);\n      reader.onload = () => resolve(reader.result);\n      reader.onerror = (error) => reject(error);\n      reader.onabort = (error) => reject(error);\n    }\n  });\n}\nasync function getImageSizeFromSrc(src) {\n  return await new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve([img.width, img.height]);\n    img.onerror = () => reject(new Error(\"Could not get image size\"));\n    img.src = src;\n  });\n}\n\n// src/components/Tldraw/state/sessions/BaseSession.ts\nvar BaseSession = class {\n  constructor(app) {\n    this.app = app;\n  }\n};\n\n// src/components/Tldraw/state/sessions/ArrowSession/ArrowSession.ts\nvar ArrowSession = class extends BaseSession {\n  type = \"arrow\" /* Arrow */;\n  performanceMode = void 0;\n  status = \"translatingHandle\" /* TranslatingHandle */;\n  newStartBindingId = C3.uniqueId();\n  draggedBindingId = C3.uniqueId();\n  didBind = false;\n  initialShape;\n  handleId;\n  bindableShapeIds;\n  initialBinding;\n  startBindingShapeId;\n  isCreate;\n  constructor(app, shapeId, handleId, isCreate = false) {\n    super(app);\n    this.isCreate = isCreate;\n    const { currentPageId } = app.state.appState;\n    const page = app.state.document.pages[currentPageId];\n    this.handleId = handleId;\n    this.initialShape = deepCopy(page.shapes[shapeId]);\n    this.bindableShapeIds = TLDR.getBindableShapeIds(app.state).filter((id) => !(id === this.initialShape.id || id === this.initialShape.parentId));\n    const oppositeHandleBindingId = this.initialShape.handles[handleId === \"start\" ? \"end\" : \"start\"]?.bindingId;\n    if (oppositeHandleBindingId) {\n      const oppositeToId = page.bindings[oppositeHandleBindingId]?.toId;\n      if (oppositeToId) {\n        this.bindableShapeIds = this.bindableShapeIds.filter((id) => id !== oppositeToId);\n      }\n    }\n    const { originPoint } = this.app;\n    if (this.isCreate) {\n      this.startBindingShapeId = this.bindableShapeIds.map((id) => page.shapes[id]).filter((shape) => !shape.isLocked && C3.pointInBounds(originPoint, TLDR.getShapeUtil(shape).getBounds(shape))).sort((a7, b6) => {\n        return b6.childIndex - a7.childIndex;\n      })[0]?.id;\n      if (this.startBindingShapeId) {\n        this.bindableShapeIds.splice(this.bindableShapeIds.indexOf(this.startBindingShapeId), 1);\n      }\n    } else {\n      const initialBindingId = this.initialShape.handles[this.handleId].bindingId;\n      if (initialBindingId) {\n        this.initialBinding = page.bindings[initialBindingId];\n      } else {\n        this.initialShape.handles[this.handleId].bindingId = void 0;\n      }\n    }\n  }\n  start = () => void 0;\n  update = () => {\n    const { initialShape } = this;\n    const {\n      currentPoint,\n      shiftKey,\n      altKey,\n      metaKey,\n      currentGrid,\n      settings: { showGrid }\n    } = this.app;\n    const shape = this.app.getShape(initialShape.id);\n    if (shape.isLocked)\n      return;\n    const { handles } = initialShape;\n    const handleId = this.handleId;\n    if (!handles[handleId].canBind)\n      return;\n    let delta = e.sub(currentPoint, e.add(handles[handleId].point, initialShape.point));\n    if (shiftKey) {\n      const A5 = altKey ? e.med(handles.start.point, handles.end.point) : handles[handleId === \"start\" ? \"end\" : \"start\"].point;\n      const B4 = handles[handleId].point;\n      const C6 = e.add(B4, delta);\n      const angle = e.angle(A5, C6);\n      const adjusted = e.rotWith(C6, A5, C3.snapAngleToSegments(angle, 24) - angle);\n      delta = e.add(delta, e.sub(adjusted, C6));\n    }\n    const nextPoint = e.add(handles[handleId].point, delta);\n    const handleChanges = {\n      [handleId]: {\n        ...handles[handleId],\n        point: showGrid ? e.snap(nextPoint, currentGrid) : e.toFixed(nextPoint),\n        bindingId: void 0\n      }\n    };\n    const utils = shapeUtils[\"arrow\" /* Arrow */];\n    const handleChange = utils.onHandleChange?.(initialShape, handleChanges);\n    if (!handleChange)\n      return;\n    const next = {\n      shape: C3.deepMerge(shape, handleChange),\n      bindings: {}\n    };\n    let draggedBinding;\n    const draggingHandle = next.shape.handles[this.handleId];\n    const oppositeHandle = next.shape.handles[this.handleId === \"start\" ? \"end\" : \"start\"];\n    if (this.startBindingShapeId) {\n      let nextStartBinding;\n      const startTarget = this.app.page.shapes[this.startBindingShapeId];\n      const startTargetUtils = TLDR.getShapeUtil(startTarget);\n      const center = startTargetUtils.getCenter(startTarget);\n      const startHandle = next.shape.handles.start;\n      const endHandle = next.shape.handles.end;\n      const rayPoint = e.add(startHandle.point, next.shape.point);\n      if (e.isEqual(rayPoint, center))\n        rayPoint[1]++;\n      const rayOrigin = center;\n      const isInsideShape = startTargetUtils.hitTestPoint(startTarget, currentPoint);\n      const rayDirection = e.uni(e.sub(rayPoint, rayOrigin));\n      const hasStartBinding = this.app.getBinding(this.newStartBindingId) !== void 0;\n      if (!metaKey && !startTargetUtils.hitTestPoint(startTarget, e.add(next.shape.point, endHandle.point))) {\n        nextStartBinding = this.findBindingPoint(shape, startTarget, \"start\", this.newStartBindingId, center, rayOrigin, rayDirection, isInsideShape);\n      }\n      if (nextStartBinding && !hasStartBinding) {\n        this.didBind = true;\n        next.bindings[this.newStartBindingId] = nextStartBinding;\n        next.shape = C3.deepMerge(next.shape, {\n          handles: {\n            start: {\n              bindingId: nextStartBinding.id\n            }\n          }\n        });\n      } else if (!nextStartBinding && hasStartBinding) {\n        this.didBind = false;\n        next.bindings[this.newStartBindingId] = void 0;\n        next.shape = C3.deepMerge(initialShape, {\n          handles: {\n            start: {\n              bindingId: void 0\n            }\n          }\n        });\n      }\n    }\n    if (!metaKey) {\n      const rayOrigin = e.add(oppositeHandle.point, next.shape.point);\n      const rayPoint = e.add(draggingHandle.point, next.shape.point);\n      const rayDirection = e.uni(e.sub(rayPoint, rayOrigin));\n      const startPoint = e.add(next.shape.point, next.shape.handles.start.point);\n      const endPoint = e.add(next.shape.point, next.shape.handles.end.point);\n      const targets = this.bindableShapeIds.map((id) => this.app.page.shapes[id]).sort((a7, b6) => b6.childIndex - a7.childIndex).filter((shape2) => {\n        if (shape2.isLocked)\n          return false;\n        const utils2 = TLDR.getShapeUtil(shape2);\n        return ![startPoint, endPoint].every((point) => utils2.hitTestPoint(shape2, point));\n      });\n      for (const target of targets) {\n        draggedBinding = this.findBindingPoint(shape, target, this.handleId, this.draggedBindingId, rayPoint, rayOrigin, rayDirection, altKey);\n        if (draggedBinding)\n          break;\n      }\n    }\n    if (draggedBinding) {\n      this.didBind = true;\n      next.bindings[this.draggedBindingId] = draggedBinding;\n      next.shape = C3.deepMerge(next.shape, {\n        handles: {\n          [this.handleId]: {\n            bindingId: this.draggedBindingId\n          }\n        }\n      });\n    } else {\n      this.didBind = this.didBind || false;\n      const currentBindingId = shape.handles[this.handleId].bindingId;\n      if (currentBindingId !== void 0) {\n        next.bindings[currentBindingId] = void 0;\n        next.shape = C3.deepMerge(next.shape, {\n          handles: {\n            [this.handleId]: {\n              bindingId: void 0\n            }\n          }\n        });\n      }\n    }\n    const change = TLDR.getShapeUtil(next.shape).onHandleChange?.(next.shape, next.shape.handles);\n    return {\n      document: {\n        pages: {\n          [this.app.currentPageId]: {\n            shapes: {\n              [shape.id]: { ...next.shape, ...change }\n            },\n            bindings: next.bindings\n          }\n        },\n        pageStates: {\n          [this.app.currentPageId]: {\n            bindingId: next.shape.handles[handleId].bindingId\n          }\n        }\n      }\n    };\n  };\n  cancel = () => {\n    const { initialShape, initialBinding, newStartBindingId, draggedBindingId } = this;\n    const currentShape = TLDR.onSessionComplete(this.app.page.shapes[initialShape.id]);\n    const isDeleting = this.isCreate || e.dist(currentShape.handles.start.point, currentShape.handles.end.point) < 4;\n    const afterBindings = {};\n    afterBindings[draggedBindingId] = void 0;\n    if (initialBinding) {\n      afterBindings[initialBinding.id] = isDeleting ? void 0 : initialBinding;\n    }\n    if (newStartBindingId) {\n      afterBindings[newStartBindingId] = void 0;\n    }\n    return {\n      document: {\n        pages: {\n          [this.app.currentPageId]: {\n            shapes: {\n              [initialShape.id]: isDeleting ? void 0 : initialShape\n            },\n            bindings: afterBindings\n          }\n        },\n        pageStates: {\n          [this.app.currentPageId]: {\n            selectedIds: isDeleting ? [] : [initialShape.id],\n            bindingId: void 0,\n            hoveredId: void 0,\n            editingId: void 0\n          }\n        }\n      }\n    };\n  };\n  complete = () => {\n    const { initialShape, initialBinding, newStartBindingId, startBindingShapeId, handleId } = this;\n    const currentShape = TLDR.onSessionComplete(this.app.page.shapes[initialShape.id]);\n    const currentBindingId = currentShape.handles[handleId].bindingId;\n    const length = e.dist(currentShape.handles.start.point, currentShape.handles.end.point);\n    if (!(currentBindingId || initialBinding) && length < 4)\n      return this.cancel();\n    const beforeBindings = {};\n    const afterBindings = {};\n    if (initialBinding) {\n      beforeBindings[initialBinding.id] = this.isCreate ? void 0 : initialBinding;\n      afterBindings[initialBinding.id] = void 0;\n    }\n    if (currentBindingId) {\n      beforeBindings[currentBindingId] = void 0;\n      afterBindings[currentBindingId] = this.app.page.bindings[currentBindingId];\n    }\n    if (startBindingShapeId) {\n      beforeBindings[newStartBindingId] = void 0;\n      afterBindings[newStartBindingId] = this.app.page.bindings[newStartBindingId];\n    }\n    return {\n      id: \"arrow\",\n      before: {\n        document: {\n          pages: {\n            [this.app.currentPageId]: {\n              shapes: {\n                [initialShape.id]: this.isCreate ? void 0 : initialShape\n              },\n              bindings: beforeBindings\n            }\n          },\n          pageStates: {\n            [this.app.currentPageId]: {\n              selectedIds: this.isCreate ? [] : [initialShape.id],\n              bindingId: void 0,\n              hoveredId: void 0,\n              editingId: void 0\n            }\n          }\n        }\n      },\n      after: {\n        document: {\n          pages: {\n            [this.app.currentPageId]: {\n              shapes: {\n                [initialShape.id]: currentShape\n              },\n              bindings: afterBindings\n            }\n          },\n          pageStates: {\n            [this.app.currentPageId]: {\n              selectedIds: [initialShape.id],\n              bindingId: void 0,\n              hoveredId: void 0,\n              editingId: void 0\n            }\n          }\n        }\n      }\n    };\n  };\n  findBindingPoint = (shape, target, handleId, bindingId, point, origin, direction, bindAnywhere) => {\n    const util = TLDR.getShapeUtil(target.type);\n    const bindingPoint = util.getBindingPoint(\n      target,\n      shape,\n      point,\n      origin,\n      direction,\n      bindAnywhere\n    );\n    if (!bindingPoint)\n      return;\n    return {\n      id: bindingId,\n      type: \"arrow\",\n      fromId: shape.id,\n      toId: target.id,\n      handleId,\n      point: e.toFixed(bindingPoint.point),\n      distance: bindingPoint.distance\n    };\n  };\n};\n\n// src/components/Tldraw/state/sessions/BrushSession/BrushSession.ts\nvar BrushSession = class extends BaseSession {\n  type = \"brush\" /* Brush */;\n  performanceMode = void 0;\n  status = \"brushing\" /* Brushing */;\n  initialSelectedIds;\n  shapesToTest;\n  constructor(app) {\n    super(app);\n    const { currentPageId } = app;\n    this.initialSelectedIds = new Set(this.app.selectedIds);\n    this.shapesToTest = this.app.shapes.filter(\n      (shape) => !(shape.isLocked || shape.isHidden || shape.parentId !== currentPageId || this.initialSelectedIds.has(shape.id) || this.initialSelectedIds.has(shape.parentId))\n    ).map((shape) => ({\n      id: shape.id,\n      bounds: this.app.getShapeUtil(shape).getBounds(shape),\n      selectId: shape.id\n    }));\n    this.update();\n  }\n  start = () => void 0;\n  update = () => {\n    const {\n      initialSelectedIds,\n      shapesToTest,\n      app: { metaKey, settings, originPoint, currentPoint }\n    } = this;\n    const brush = C3.getBoundsFromPoints([originPoint, currentPoint]);\n    const selectByContain = settings.isCadSelectMode ? !metaKey && originPoint[0] < currentPoint[0] : metaKey;\n    const hits = /* @__PURE__ */ new Set();\n    const selectedIds = new Set(initialSelectedIds);\n    shapesToTest.forEach(({ id, selectId }) => {\n      const shape = this.app.getShape(id);\n      if (!hits.has(selectId)) {\n        const util = this.app.getShapeUtil(shape);\n        if (selectByContain ? C3.boundsContain(brush, util.getBounds(shape)) : util.hitTestBounds(shape, brush)) {\n          hits.add(selectId);\n          if (!selectedIds.has(selectId)) {\n            selectedIds.add(selectId);\n          }\n        } else if (selectedIds.has(selectId)) {\n          selectedIds.delete(selectId);\n        }\n      }\n    });\n    const currentSelectedIds = this.app.selectedIds;\n    const didChange = selectedIds.size !== currentSelectedIds.length || currentSelectedIds.some((id) => !selectedIds.has(id));\n    const afterSelectedIds = didChange ? [...selectedIds.values()] : currentSelectedIds;\n    if (!didChange)\n      return {\n        appState: {\n          selectByContain\n        },\n        document: {\n          pageStates: {\n            [this.app.currentPageId]: {\n              brush\n            }\n          }\n        }\n      };\n    return {\n      appState: {\n        selectByContain\n      },\n      document: {\n        pageStates: {\n          [this.app.currentPageId]: {\n            brush,\n            selectedIds: afterSelectedIds\n          }\n        }\n      }\n    };\n  };\n  cancel = () => {\n    return {\n      appState: {\n        selectByContain: false\n      },\n      document: {\n        pageStates: {\n          [this.app.currentPageId]: {\n            brush: null,\n            selectedIds: [...this.initialSelectedIds.values()]\n          }\n        }\n      }\n    };\n  };\n  complete = () => {\n    return {\n      appState: {\n        selectByContain: false\n      },\n      document: {\n        pageStates: {\n          [this.app.currentPageId]: {\n            brush: null,\n            selectedIds: [...this.app.selectedIds]\n          }\n        }\n      }\n    };\n  };\n};\n\n// src/components/Tldraw/state/sessions/DrawSession/DrawSession.ts\nvar DrawSession = class extends BaseSession {\n  type = \"draw\" /* Draw */;\n  performanceMode = void 0;\n  status = \"creating\" /* Creating */;\n  topLeft;\n  points;\n  initialShape;\n  lastAdjustedPoint;\n  shiftedPoints = [];\n  shapeId;\n  isLocked;\n  isExtending;\n  lockedDirection;\n  constructor(app, id) {\n    super(app);\n    const { originPoint } = this.app;\n    this.shapeId = id;\n    this.initialShape = this.app.getShape(id);\n    this.topLeft = [...this.initialShape.point];\n    const currentPoint = [0, 0, originPoint[2] ?? 0.5];\n    const delta = e.sub(originPoint, this.topLeft);\n    const initialPoints = this.initialShape.points.map((pt2) => e.sub(pt2, delta).concat(pt2[2]));\n    this.isExtending = initialPoints.length > 0;\n    const newPoints = [];\n    if (this.isExtending) {\n      const prevPoint = initialPoints[initialPoints.length - 1];\n      if (prevPoint) {\n        newPoints.push(prevPoint, prevPoint);\n        const len = Math.floor(e.dist(prevPoint, currentPoint) / 16);\n        if (len > 1) {\n          for (let i4 = 0; i4 < len; i4++) {\n            const t5 = i4 / (len - 1);\n            newPoints.push(e.lrp(prevPoint, currentPoint, t5).concat(prevPoint[2]));\n          }\n        } else {\n          newPoints.push(currentPoint, currentPoint);\n        }\n      }\n    } else {\n      newPoints.push(currentPoint);\n    }\n    this.points = [...initialPoints, ...newPoints];\n    this.shiftedPoints = this.points.map((pt2) => e.add(pt2, delta).concat(pt2[2]));\n    this.lastAdjustedPoint = this.points[this.points.length - 1];\n  }\n  start = () => {\n    const currentPoint = this.app.originPoint;\n    const newAdjustedPoint = [0, 0, currentPoint[2] ?? 0.5];\n    this.points.push(newAdjustedPoint);\n    const topLeft = [Math.min(this.topLeft[0], currentPoint[0]), Math.min(this.topLeft[1], currentPoint[1])];\n    const delta = e.sub(topLeft, currentPoint);\n    this.topLeft = topLeft;\n    this.shiftedPoints = this.points.map((pt2) => e.toFixed(e.sub(pt2, delta)).concat(pt2[2]));\n    return {\n      document: {\n        pages: {\n          [this.app.currentPageId]: {\n            shapes: {\n              [this.shapeId]: {\n                point: this.topLeft,\n                points: this.shiftedPoints\n              }\n            }\n          }\n        },\n        pageStates: {\n          [this.app.currentPageId]: {\n            selectedIds: [this.shapeId]\n          }\n        }\n      }\n    };\n  };\n  update = () => {\n    const { shapeId } = this;\n    const { currentPoint, originPoint, shiftKey, zoom } = this.app;\n    if (!this.lockedDirection && this.points.length > 1) {\n      const delta = e.sub(currentPoint, originPoint);\n      if (e.len(delta) > 3 / zoom) {\n        this.lockedDirection = Math.abs(delta[0]) > Math.abs(delta[1]) ? \"horizontal\" : \"vertical\";\n      }\n    }\n    if (shiftKey) {\n      if (!this.isLocked && this.points.length > 2) {\n        if (!this.lockedDirection) {\n          const delta = e.sub(currentPoint, originPoint);\n          if (e.len(delta) > 3 / zoom) {\n            this.lockedDirection = Math.abs(delta[0]) > Math.abs(delta[1]) ? \"horizontal\" : \"vertical\";\n          }\n        }\n        this.isLocked = true;\n        const returning = [...this.lastAdjustedPoint];\n        if (this.lockedDirection === \"vertical\") {\n          returning[0] = 0;\n        } else {\n          returning[1] = 0;\n        }\n        this.points.push(returning.concat(currentPoint[2]));\n      }\n    } else if (this.isLocked) {\n      this.isLocked = false;\n    }\n    if (this.isLocked) {\n      if (this.lockedDirection === \"vertical\") {\n        currentPoint[0] = originPoint[0];\n      } else {\n        currentPoint[1] = originPoint[1];\n      }\n    }\n    const change = this.addPoint(currentPoint);\n    if (!change)\n      return;\n    return {\n      document: {\n        pages: {\n          [this.app.currentPageId]: {\n            shapes: {\n              [shapeId]: change\n            }\n          }\n        },\n        pageStates: {\n          [this.app.currentPageId]: {\n            selectedIds: [shapeId]\n          }\n        }\n      }\n    };\n  };\n  cancel = () => {\n    const { shapeId } = this;\n    const pageId = this.app.currentPageId;\n    return {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: {\n              [shapeId]: this.isExtending ? this.initialShape : void 0\n            }\n          }\n        },\n        pageStates: {\n          [pageId]: {\n            selectedIds: []\n          }\n        }\n      }\n    };\n  };\n  complete = () => {\n    const { shapeId } = this;\n    const pageId = this.app.currentPageId;\n    const shape = this.app.getShape(shapeId);\n    return {\n      id: \"create_draw\",\n      before: {\n        document: {\n          pages: {\n            [pageId]: {\n              shapes: {\n                [shapeId]: this.isExtending ? this.initialShape : void 0\n              }\n            }\n          },\n          pageStates: {\n            [pageId]: {\n              selectedIds: []\n            }\n          }\n        }\n      },\n      after: {\n        document: {\n          pages: {\n            [pageId]: {\n              shapes: {\n                [shapeId]: {\n                  ...shape,\n                  point: e.toFixed(shape.point),\n                  points: shape.points.map((pt2) => e.toFixed(pt2)),\n                  isComplete: true\n                }\n              }\n            }\n          },\n          pageStates: {\n            [this.app.currentPageId]: {\n              selectedIds: []\n            }\n          }\n        }\n      }\n    };\n  };\n  addPoint = (currentPoint) => {\n    const { originPoint } = this.app;\n    const newAdjustedPoint = e.toFixed(e.sub(currentPoint, originPoint)).concat(currentPoint[2]);\n    if (e.isEqual(this.lastAdjustedPoint, newAdjustedPoint))\n      return;\n    this.points.push(newAdjustedPoint);\n    this.lastAdjustedPoint = newAdjustedPoint;\n    const prevTopLeft = [...this.topLeft];\n    const topLeft = [Math.min(this.topLeft[0], currentPoint[0]), Math.min(this.topLeft[1], currentPoint[1])];\n    const delta = e.sub(topLeft, originPoint);\n    let points;\n    if (prevTopLeft[0] !== topLeft[0] || prevTopLeft[1] !== topLeft[1]) {\n      this.topLeft = topLeft;\n      points = this.points.map((pt2) => e.toFixed(e.sub(pt2, delta)).concat(pt2[2]));\n    } else {\n      points = [...this.shiftedPoints, e.sub(newAdjustedPoint, delta).concat(newAdjustedPoint[2])];\n    }\n    this.shiftedPoints = points;\n    return {\n      point: this.topLeft,\n      points\n    };\n  };\n};\n\n// src/components/Tldraw/state/sessions/EditSession/EditSession.ts\nvar EditSession = class extends BaseSession {\n  type = \"edit\" /* Edit */;\n  performanceMode = void 0;\n  initialShape;\n  initialSelectedIds;\n  currentPageId;\n  isCreating;\n  constructor(app, id, isCreating) {\n    super(app);\n    this.initialShape = app.getShape(id, app.currentPageId);\n    this.currentPageId = app.currentPageId;\n    this.isCreating = isCreating;\n    this.initialSelectedIds = [...app.selectedIds];\n  }\n  start = () => void 0;\n  update = () => void 0;\n  cancel = () => {\n    return {\n      document: {\n        pages: {\n          [this.currentPageId]: {\n            shapes: {\n              [this.initialShape.id]: this.isCreating ? void 0 : this.initialShape\n            }\n          }\n        },\n        pageStates: {\n          [this.currentPageId]: {\n            selectedIds: this.isCreating ? [] : this.initialSelectedIds,\n            editingId: void 0\n          }\n        }\n      }\n    };\n  };\n  complete = () => {\n    const shape = this.app.getShape(this.initialShape.id);\n    return {\n      id: \"edit\",\n      before: {\n        document: {\n          pages: {\n            [this.currentPageId]: {\n              shapes: {\n                [this.initialShape.id]: this.isCreating ? void 0 : this.initialShape\n              }\n            }\n          },\n          pageStates: {\n            [this.currentPageId]: {\n              selectedIds: this.isCreating ? [] : this.initialSelectedIds,\n              editingId: void 0\n            }\n          }\n        }\n      },\n      after: {\n        document: {\n          pages: {\n            [this.currentPageId]: {\n              shapes: {\n                [this.initialShape.id]: shape\n              }\n            }\n          },\n          pageStates: {\n            [this.currentPageId]: {\n              selectedIds: [shape.id],\n              editingId: void 0\n            }\n          }\n        }\n      }\n    };\n  };\n};\n\n// src/components/Tldraw/state/sessions/EraseSession/EraseSession.ts\nvar EraseSession = class extends BaseSession {\n  type = \"draw\" /* Draw */;\n  performanceMode = void 0;\n  status = \"creating\" /* Creating */;\n  isLocked;\n  lockedDirection;\n  erasedShapes = /* @__PURE__ */ new Set();\n  erasedBindings = /* @__PURE__ */ new Set();\n  initialSelectedShapes;\n  erasableShapes;\n  prevPoint;\n  prevEraseShapesSize = 0;\n  constructor(app) {\n    super(app);\n    this.prevPoint = [...app.originPoint];\n    this.initialSelectedShapes = this.app.selectedIds.map((id) => this.app.getShape(id));\n    this.erasableShapes = new Set(this.app.shapes.filter((shape) => !shape.isLocked));\n    this.interval = this.loop();\n  }\n  interval;\n  timestamp1 = 0;\n  timestamp2 = 0;\n  prevErasePoint = [];\n  loop = () => {\n    const now = Date.now();\n    const elapsed1 = now - this.timestamp1;\n    const elapsed2 = now - this.timestamp2;\n    const { eraseLine } = this.app.appState;\n    let next = [...eraseLine];\n    let didUpdate = false;\n    if (elapsed1 > 16 && this.prevErasePoint !== this.prevPoint) {\n      didUpdate = true;\n      next = [...eraseLine, this.prevPoint];\n      this.prevErasePoint = this.prevPoint;\n    }\n    if (elapsed2 > 32 && next.length > 1) {\n      didUpdate = true;\n      next.splice(0, Math.ceil(next.length * 0.1));\n      this.timestamp2 = now;\n    }\n    if (didUpdate) {\n      this.app.patchState(\n        {\n          appState: {\n            eraseLine: next\n          }\n        },\n        \"eraseline\"\n      );\n    }\n    this.interval = requestAnimationFrame(this.loop);\n  };\n  start = () => void 0;\n  update = () => {\n    const { page, shiftKey, originPoint, currentPoint, zoom } = this.app;\n    if (shiftKey) {\n      const delta = e.sub(currentPoint, originPoint);\n      if (!this.isLocked && e.len(delta) > 3 / zoom) {\n        if (!this.lockedDirection) {\n          const delta2 = e.sub(currentPoint, originPoint);\n          this.lockedDirection = Math.abs(delta2[0]) > Math.abs(delta2[1]) ? \"horizontal\" : \"vertical\";\n        }\n        this.isLocked = true;\n      }\n    } else if (this.isLocked) {\n      this.isLocked = false;\n    }\n    if (this.isLocked) {\n      if (this.lockedDirection === \"vertical\") {\n        currentPoint[0] = originPoint[0];\n      } else {\n        currentPoint[1] = originPoint[1];\n      }\n    }\n    const newPoint = e.toFixed(e.add(originPoint, e.sub(currentPoint, originPoint)));\n    const deletedShapeIds = /* @__PURE__ */ new Set([]);\n    this.erasableShapes.forEach((shape) => {\n      if (this.erasedShapes.has(shape))\n        return;\n      if (this.app.getShapeUtil(shape).hitTestLineSegment(shape, this.prevPoint, newPoint)) {\n        this.erasedShapes.add(shape);\n        deletedShapeIds.add(shape.id);\n        if (shape.children !== void 0) {\n          for (const childId of shape.children) {\n            this.erasedShapes.add(this.app.getShape(childId));\n            deletedShapeIds.add(childId);\n          }\n        }\n      }\n    });\n    Object.values(page.bindings).forEach((binding) => {\n      for (const id of [binding.toId, binding.fromId]) {\n        if (deletedShapeIds.has(id)) {\n          this.erasedBindings.add(binding);\n        }\n      }\n    });\n    this.erasedShapes.forEach((shape) => {\n      if (!this.app.getShape(shape.id)) {\n        this.erasedShapes.delete(shape);\n        this.erasableShapes.delete(shape);\n        deletedShapeIds.delete(shape.id);\n      }\n    });\n    const erasedShapes = [...this.erasedShapes.values()];\n    this.prevPoint = newPoint;\n    if (erasedShapes.length === this.prevEraseShapesSize) {\n      return;\n    }\n    this.prevEraseShapesSize = erasedShapes.length;\n    return {\n      document: {\n        pages: {\n          [page.id]: {\n            shapes: Object.fromEntries(erasedShapes.map((shape) => [shape.id, { isGhost: true }]))\n          }\n        }\n      }\n    };\n  };\n  cancel = () => {\n    const { page } = this.app;\n    cancelAnimationFrame(this.interval);\n    this.erasedShapes.forEach((shape) => {\n      if (!this.app.getShape(shape.id)) {\n        this.erasedShapes.delete(shape);\n        this.erasableShapes.delete(shape);\n      }\n    });\n    const erasedShapes = [...this.erasedShapes.values()];\n    return {\n      document: {\n        pages: {\n          [page.id]: {\n            shapes: Object.fromEntries(erasedShapes.map((shape) => [shape.id, { isGhost: false }]))\n          }\n        },\n        pageStates: {\n          [page.id]: {\n            selectedIds: this.initialSelectedShapes.map((shape) => shape.id)\n          }\n        }\n      },\n      appState: {\n        eraseLine: []\n      }\n    };\n  };\n  complete = () => {\n    const { page } = this.app;\n    cancelAnimationFrame(this.interval);\n    this.erasedShapes.forEach((shape) => {\n      if (!this.app.getShape(shape.id)) {\n        this.erasedShapes.delete(shape);\n        this.erasableShapes.delete(shape);\n      }\n    });\n    this.erasedBindings.forEach((binding) => {\n      if (!this.app.getBinding(binding.id)) {\n        this.erasedBindings.delete(binding);\n      }\n    });\n    const erasedShapes = [...this.erasedShapes.values()];\n    const erasedBindings = [...this.erasedBindings.values()];\n    const erasedShapeIds = new Set(erasedShapes.map((shape) => shape.id));\n    const erasedBindingIds = new Set(erasedBindings.map((binding) => binding.id));\n    const before = {\n      shapes: Object.fromEntries(erasedShapes.map((shape) => [shape.id, shape])),\n      bindings: Object.fromEntries(erasedBindings.map((binding) => [binding.id, binding]))\n    };\n    const after = {\n      shapes: Object.fromEntries(erasedShapes.map((shape) => [shape.id, void 0])),\n      bindings: Object.fromEntries(erasedBindings.map((binding) => [binding.id, void 0]))\n    };\n    this.app.shapes.forEach((shape) => {\n      if (shape.handles && !after.shapes[shape.id]) {\n        Object.values(shape.handles).forEach((handle) => {\n          if (handle.bindingId && erasedBindingIds.has(handle.bindingId)) {\n            before.shapes[shape.id] = {\n              ...before.shapes[shape.id],\n              handles: {\n                ...before.shapes[shape.id]?.handles,\n                [handle.id]: handle\n              }\n            };\n            if (!erasedShapeIds.has(shape.id)) {\n              after.shapes[shape.id] = {\n                ...after.shapes[shape.id],\n                handles: {\n                  ...after.shapes[shape.id]?.handles,\n                  [handle.id]: {\n                    ...handle,\n                    bindingId: void 0\n                  }\n                }\n              };\n            }\n          }\n        });\n      }\n    });\n    return {\n      id: \"erase\",\n      before: {\n        document: {\n          pages: {\n            [page.id]: before\n          },\n          pageStates: {\n            [page.id]: {\n              selectedIds: this.initialSelectedShapes.filter((shape) => !!this.app.getShape(shape.id)).map((shape) => shape.id)\n            }\n          }\n        },\n        appState: {\n          eraseLine: []\n        }\n      },\n      after: {\n        document: {\n          pages: {\n            [page.id]: after\n          },\n          pageStates: {\n            [page.id]: {\n              selectedIds: this.initialSelectedShapes.filter((shape) => !!this.app.getShape(shape.id)).filter((shape) => !erasedShapeIds.has(shape.id)).map((shape) => shape.id)\n            }\n          }\n        },\n        appState: {\n          eraseLine: []\n        }\n      }\n    };\n  };\n};\n\n// src/components/Tldraw/state/sessions/GridSession/GridSession.ts\nvar GridSession = class extends BaseSession {\n  type = \"grid\" /* Grid */;\n  performanceMode = void 0;\n  status = \"translating\" /* Translating */;\n  shape;\n  bounds;\n  initialSelectedIds;\n  initialSiblings;\n  grid = {};\n  columns = 1;\n  rows = 1;\n  isCopying = false;\n  constructor(app, id) {\n    super(app);\n    this.shape = this.app.getShape(id);\n    this.grid[\"0_0\"] = this.shape.id;\n    this.bounds = this.app.getShapeBounds(id);\n    this.initialSelectedIds = [...this.app.selectedIds];\n    if (this.shape.parentId !== this.app.currentPageId) {\n      this.initialSiblings = this.app.getShape(this.shape.parentId).children?.filter((id2) => id2 !== this.shape.id);\n    }\n  }\n  start = () => void 0;\n  update = () => {\n    const { currentPageId, altKey, shiftKey, currentPoint } = this.app;\n    const nextShapes = {};\n    const nextPageState = {};\n    const center = C3.getBoundsCenter(this.bounds);\n    const offset = e.sub(currentPoint, center);\n    if (shiftKey) {\n      if (Math.abs(offset[0]) < Math.abs(offset[1])) {\n        offset[0] = 0;\n      } else {\n        offset[1] = 0;\n      }\n    }\n    const gapX = this.bounds.width + 32;\n    const gapY = this.bounds.height + 32;\n    const columns = Math.ceil(offset[0] / gapX);\n    const rows = Math.ceil(offset[1] / gapY);\n    const minX = Math.min(columns, 0);\n    const minY = Math.min(rows, 0);\n    const maxX = Math.max(columns, 1);\n    const maxY = Math.max(rows, 1);\n    const inGrid = /* @__PURE__ */ new Set();\n    const isCopying = altKey;\n    if (isCopying !== this.isCopying) {\n      Object.values(this.grid).filter((id) => id !== this.shape.id).forEach((id) => nextShapes[id] = void 0);\n      this.grid = { \"0_0\": this.shape.id };\n      this.isCopying = isCopying;\n    }\n    for (let x5 = minX; x5 < maxX; x5++) {\n      for (let y6 = minY; y6 < maxY; y6++) {\n        const position = `${x5}_${y6}`;\n        inGrid.add(position);\n        if (this.grid[position])\n          continue;\n        if (x5 === 0 && y6 === 0)\n          continue;\n        const clone = this.getClone(e.add(this.shape.point, [x5 * gapX, y6 * gapY]), isCopying);\n        nextShapes[clone.id] = clone;\n        this.grid[position] = clone.id;\n      }\n    }\n    Object.entries(this.grid).forEach(([position, id]) => {\n      if (!inGrid.has(position)) {\n        nextShapes[id] = void 0;\n        delete this.grid[position];\n      }\n    });\n    if (Object.values(nextShapes).length === 0)\n      return;\n    if (this.initialSiblings) {\n      nextShapes[this.shape.parentId] = {\n        children: [...this.initialSiblings, ...Object.values(this.grid)]\n      };\n    }\n    return {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: nextShapes\n          }\n        },\n        pageStates: {\n          [currentPageId]: nextPageState\n        }\n      }\n    };\n  };\n  cancel = () => {\n    const { currentPageId } = this.app;\n    const nextShapes = {};\n    Object.values(this.grid).forEach((id) => {\n      nextShapes[id] = void 0;\n    });\n    nextShapes[this.shape.id] = { ...nextShapes[this.shape.id], point: this.shape.point };\n    if (this.initialSiblings) {\n      nextShapes[this.shape.parentId] = {\n        children: [...this.initialSiblings, this.shape.id]\n      };\n    }\n    return {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: nextShapes\n          }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: [this.shape.id]\n          }\n        }\n      }\n    };\n  };\n  complete = () => {\n    const { currentPageId } = this.app;\n    const beforeShapes = {};\n    const afterShapes = {};\n    const afterSelectedIds = [];\n    Object.values(this.grid).forEach((id) => {\n      beforeShapes[id] = void 0;\n      afterShapes[id] = this.app.getShape(id);\n      afterSelectedIds.push(id);\n    });\n    beforeShapes[this.shape.id] = this.shape;\n    if (this.initialSiblings) {\n      beforeShapes[this.shape.parentId] = {\n        children: [...this.initialSiblings, this.shape.id]\n      };\n      afterShapes[this.shape.parentId] = {\n        children: [...this.initialSiblings, ...Object.values(this.grid)]\n      };\n    }\n    if (afterSelectedIds.length === 1)\n      return;\n    return {\n      id: \"grid\",\n      before: {\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: beforeShapes\n            }\n          },\n          pageStates: {\n            [currentPageId]: {\n              selectedIds: [],\n              hoveredId: void 0\n            }\n          }\n        }\n      },\n      after: {\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: afterShapes\n            }\n          },\n          pageStates: {\n            [currentPageId]: {\n              selectedIds: afterSelectedIds,\n              hoveredId: void 0\n            }\n          }\n        }\n      }\n    };\n  };\n  getClone = (point, copy) => {\n    const clone = {\n      ...this.shape,\n      id: C3.uniqueId(),\n      point\n    };\n    if (!copy && clone.type === \"sticky\" /* Sticky */) {\n      clone.text = \"\";\n    }\n    return clone;\n  };\n};\n\n// src/components/Tldraw/state/sessions/HandleSession/HandleSession.ts\nvar HandleSession = class extends BaseSession {\n  type = \"handle\" /* Handle */;\n  performanceMode = void 0;\n  status = \"translatingHandle\" /* TranslatingHandle */;\n  commandId;\n  topLeft;\n  shiftKey = false;\n  initialShape;\n  handleId;\n  constructor(app, shapeId, handleId, commandId = \"move_handle\") {\n    super(app);\n    const { originPoint } = app;\n    this.topLeft = [...originPoint];\n    this.handleId = handleId;\n    this.initialShape = this.app.getShape(shapeId);\n    this.commandId = commandId;\n  }\n  start = () => void 0;\n  update = () => {\n    const {\n      initialShape,\n      app: { currentPageId, currentPoint }\n    } = this;\n    const shape = this.app.getShape(initialShape.id);\n    if (shape.isLocked)\n      return void 0;\n    const handles = shape.handles;\n    const handleId = this.handleId;\n    const delta = e.sub(currentPoint, handles[handleId].point);\n    const handleChanges = {\n      [handleId]: {\n        ...handles[handleId],\n        point: e.sub(e.add(handles[handleId].point, delta), shape.point)\n      }\n    };\n    const change = TLDR.getShapeUtil(shape).onHandleChange?.(shape, handleChanges);\n    if (!change)\n      return;\n    return {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: {\n              [shape.id]: change\n            }\n          }\n        }\n      }\n    };\n  };\n  cancel = () => {\n    const {\n      initialShape,\n      app: { currentPageId }\n    } = this;\n    return {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: {\n              [initialShape.id]: initialShape\n            }\n          }\n        }\n      }\n    };\n  };\n  complete = () => {\n    const {\n      initialShape,\n      app: { currentPageId }\n    } = this;\n    return {\n      id: this.commandId,\n      before: {\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: {\n                [initialShape.id]: initialShape\n              }\n            }\n          }\n        }\n      },\n      after: {\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: {\n                [initialShape.id]: TLDR.onSessionComplete(this.app.getShape(this.initialShape.id))\n              }\n            }\n          }\n        }\n      }\n    };\n  };\n};\n\n// src/components/Tldraw/state/sessions/RotateSession/RotateSession.ts\nvar RotateSession = class extends BaseSession {\n  type = \"rotate\" /* Rotate */;\n  status = \"transforming\" /* Transforming */;\n  performanceMode = void 0;\n  delta = [0, 0];\n  commonBoundsCenter;\n  initialAngle;\n  initialShapes;\n  changes = {};\n  constructor(app) {\n    super(app);\n    const {\n      app: { currentPageId, pageState, originPoint }\n    } = this;\n    const initialShapes = TLDR.getSelectedBranchSnapshot(app.state, currentPageId).filter((shape) => !shape.isLocked);\n    if (initialShapes.length === 0) {\n      throw new Error(\"No selected shapes!\");\n    }\n    if (app.rotationInfo.selectedIds === pageState.selectedIds) {\n      if (app.rotationInfo.center === void 0) {\n        throw new Error(\"We should have a center for rotation!\");\n      }\n      this.commonBoundsCenter = app.rotationInfo.center;\n    } else {\n      this.commonBoundsCenter = C3.getBoundsCenter(C3.getCommonBounds(initialShapes.map(TLDR.getBounds)));\n      app.rotationInfo.selectedIds = pageState.selectedIds;\n      app.rotationInfo.center = this.commonBoundsCenter;\n    }\n    this.initialShapes = initialShapes.filter((shape) => shape.children === void 0).map((shape) => {\n      return {\n        shape,\n        center: this.app.getShapeUtil(shape).getCenter(shape)\n      };\n    });\n    this.initialAngle = e.angle(this.commonBoundsCenter, originPoint);\n  }\n  start = () => void 0;\n  update = () => {\n    const {\n      commonBoundsCenter,\n      initialShapes,\n      app: { currentPageId, currentPoint, shiftKey }\n    } = this;\n    const shapes = {};\n    let directionDelta = e.angle(commonBoundsCenter, currentPoint) - this.initialAngle;\n    if (shiftKey) {\n      directionDelta = C3.snapAngleToSegments(directionDelta, 24);\n    }\n    initialShapes.forEach(({ center, shape }) => {\n      const { rotation = 0 } = shape;\n      let shapeDelta = 0;\n      if (shiftKey) {\n        const snappedRotation = C3.snapAngleToSegments(rotation, 24);\n        shapeDelta = snappedRotation - rotation;\n      }\n      const change = TLDR.getRotatedShapeMutation(shape, center, commonBoundsCenter, shiftKey ? directionDelta + shapeDelta : directionDelta);\n      if (change) {\n        shapes[shape.id] = change;\n      }\n    });\n    this.changes = shapes;\n    return {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes\n          }\n        }\n      }\n    };\n  };\n  cancel = () => {\n    const {\n      initialShapes,\n      app: { currentPageId }\n    } = this;\n    const shapes = {};\n    initialShapes.forEach(({ shape }) => shapes[shape.id] = shape);\n    return {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes\n          }\n        }\n      }\n    };\n  };\n  complete = () => {\n    const {\n      initialShapes,\n      app: { currentPageId }\n    } = this;\n    const beforeShapes = {};\n    const afterShapes = this.changes;\n    initialShapes.forEach(({ shape: { id, point, rotation, handles } }) => {\n      beforeShapes[id] = { point, rotation, handles };\n    });\n    return {\n      id: \"rotate\",\n      before: {\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: beforeShapes\n            }\n          }\n        }\n      },\n      after: {\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: afterShapes\n            }\n          }\n        }\n      }\n    };\n  };\n};\n\n// src/components/Tldraw/state/sessions/TransformSession/TransformSession.ts\nvar TransformSession = class extends BaseSession {\n  constructor(app, transformType = He.BottomRight, isCreate = false) {\n    super(app);\n    this.transformType = transformType;\n    this.isCreate = isCreate;\n    this.initialSelectedIds = [...this.app.selectedIds];\n    this.app.rotationInfo.selectedIds = [...this.initialSelectedIds];\n    this.initialShapes = TLDR.getSelectedBranchSnapshot(this.app.state, this.app.currentPageId).filter((shape) => !shape.isLocked);\n    this.initialShapeIds = this.initialShapes.map((shape) => shape.id);\n    this.hasUnlockedShapes = this.initialShapes.length > 0;\n    this.isAllAspectRatioLocked = this.initialShapes.every((shape) => shape.isAspectRatioLocked || TLDR.getShapeUtil(shape).isAspectRatioLocked);\n    const shapesBounds = Object.fromEntries(this.initialShapes.map((shape) => [shape.id, TLDR.getBounds(shape)]));\n    const boundsArr = Object.values(shapesBounds);\n    this.initialCommonBounds = C3.getCommonBounds(boundsArr);\n    const initialInnerBounds = C3.getBoundsFromPoints(boundsArr.map(C3.getBoundsCenter));\n    this.shapeBounds = this.initialShapes.map((shape) => {\n      const initialShapeBounds = shapesBounds[shape.id];\n      const ic = C3.getBoundsCenter(initialShapeBounds);\n      const ix = (ic[0] - initialInnerBounds.minX) / initialInnerBounds.width;\n      const iy = (ic[1] - initialInnerBounds.minY) / initialInnerBounds.height;\n      return {\n        initialShape: shape,\n        initialShapeBounds,\n        transformOrigin: [ix, iy]\n      };\n    });\n  }\n  type = \"transform\" /* Transform */;\n  performanceMode = void 0;\n  status = \"transforming\" /* Transforming */;\n  scaleX = 1;\n  scaleY = 1;\n  initialShapes;\n  initialShapeIds;\n  initialSelectedIds;\n  shapeBounds;\n  hasUnlockedShapes;\n  isAllAspectRatioLocked;\n  initialCommonBounds;\n  snapInfo = { state: \"empty\" };\n  prevPoint = [0, 0];\n  speed = 1;\n  start = () => {\n    this.snapInfo = {\n      state: \"ready\",\n      bounds: this.app.shapes.filter((shape) => !this.initialShapeIds.includes(shape.id)).map((shape) => C3.getBoundsWithCenter(TLDR.getRotatedBounds(shape)))\n    };\n    return void 0;\n  };\n  update = () => {\n    const {\n      transformType,\n      shapeBounds,\n      initialCommonBounds,\n      isAllAspectRatioLocked,\n      app: {\n        currentPageId,\n        pageState: { camera },\n        viewport,\n        currentPoint,\n        previousPoint,\n        originPoint,\n        shiftKey,\n        altKey,\n        metaKey,\n        currentGrid,\n        settings: { isSnapping, showGrid }\n      }\n    } = this;\n    const shapes = {};\n    const delta = altKey ? e.mul(e.sub(currentPoint, originPoint), 2) : e.sub(currentPoint, originPoint);\n    let newBounds = C3.getTransformedBoundingBox(initialCommonBounds, transformType, delta, 0, shiftKey || isAllAspectRatioLocked);\n    if (altKey) {\n      newBounds = {\n        ...newBounds,\n        ...C3.centerBounds(newBounds, C3.getBoundsCenter(initialCommonBounds))\n      };\n    }\n    if (showGrid) {\n      newBounds = {\n        ...newBounds,\n        ...C3.snapBoundsToGrid(newBounds, currentGrid)\n      };\n    }\n    const speed = e.dist(currentPoint, previousPoint);\n    const speedChange = speed - this.speed;\n    this.speed = this.speed + speedChange * (speedChange > 1 ? 0.5 : 0.15);\n    let snapLines = [];\n    if ((isSnapping && !metaKey || !isSnapping && metaKey) && this.speed * camera.zoom < SLOW_SPEED && this.snapInfo.state === \"ready\") {\n      const snapResult = C3.getSnapPoints(\n        C3.getBoundsWithCenter(newBounds),\n        this.snapInfo.bounds.filter((bounds) => C3.boundsContain(viewport, bounds) || C3.boundsCollide(viewport, bounds)),\n        SNAP_DISTANCE / camera.zoom\n      );\n      if (snapResult) {\n        snapLines = snapResult.snapLines;\n        newBounds = C3.getTransformedBoundingBox(\n          initialCommonBounds,\n          transformType,\n          e.sub(delta, snapResult.offset),\n          0,\n          shiftKey || isAllAspectRatioLocked\n        );\n      }\n    }\n    this.scaleX = newBounds.scaleX;\n    this.scaleY = newBounds.scaleY;\n    shapeBounds.forEach(({ initialShape, initialShapeBounds, transformOrigin }) => {\n      let newShapeBounds = C3.getRelativeTransformedBoundingBox(newBounds, initialCommonBounds, initialShapeBounds, this.scaleX < 0, this.scaleY < 0);\n      if (showGrid) {\n        newShapeBounds = C3.snapBoundsToGrid(newShapeBounds, currentGrid);\n      }\n      const afterShape = TLDR.transform(this.app.getShape(initialShape.id), newShapeBounds, {\n        type: this.transformType,\n        initialShape,\n        scaleX: this.scaleX,\n        scaleY: this.scaleY,\n        transformOrigin\n      });\n      shapes[initialShape.id] = afterShape;\n    });\n    return {\n      appState: {\n        snapLines\n      },\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes\n          }\n        }\n      }\n    };\n  };\n  cancel = () => {\n    const {\n      shapeBounds,\n      app: { currentPageId }\n    } = this;\n    const shapes = {};\n    if (this.isCreate) {\n      shapeBounds.forEach((shape) => shapes[shape.initialShape.id] = void 0);\n    } else {\n      shapeBounds.forEach((shape) => shapes[shape.initialShape.id] = shape.initialShape);\n    }\n    return {\n      appState: {\n        snapLines: []\n      },\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes\n          }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: this.isCreate ? [] : shapeBounds.map((shape) => shape.initialShape.id)\n          }\n        }\n      }\n    };\n  };\n  complete = () => {\n    const {\n      isCreate,\n      shapeBounds,\n      hasUnlockedShapes,\n      app: { currentPageId }\n    } = this;\n    if (!hasUnlockedShapes)\n      return;\n    if (this.isCreate && e.dist(this.app.originPoint, this.app.currentPoint) < 2) {\n      return this.cancel();\n    }\n    const beforeShapes = {};\n    const afterShapes = {};\n    let beforeSelectedIds;\n    let afterSelectedIds;\n    if (isCreate) {\n      beforeSelectedIds = [];\n      afterSelectedIds = [];\n      shapeBounds.forEach(({ initialShape }) => {\n        beforeShapes[initialShape.id] = void 0;\n        afterShapes[initialShape.id] = this.app.getShape(initialShape.id);\n      });\n    } else {\n      beforeSelectedIds = this.initialSelectedIds;\n      afterSelectedIds = this.initialSelectedIds;\n      shapeBounds.forEach(({ initialShape }) => {\n        beforeShapes[initialShape.id] = initialShape;\n        afterShapes[initialShape.id] = this.app.getShape(initialShape.id);\n      });\n    }\n    return {\n      id: \"transform\",\n      before: {\n        appState: {\n          snapLines: []\n        },\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: beforeShapes\n            }\n          },\n          pageStates: {\n            [currentPageId]: {\n              selectedIds: beforeSelectedIds,\n              hoveredId: void 0,\n              editingId: void 0\n            }\n          }\n        }\n      },\n      after: {\n        appState: {\n          snapLines: []\n        },\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: afterShapes\n            }\n          },\n          pageStates: {\n            [currentPageId]: {\n              selectedIds: afterSelectedIds,\n              hoveredId: void 0,\n              editingId: void 0\n            }\n          }\n        }\n      }\n    };\n  };\n};\n\n// src/components/Tldraw/state/sessions/TransformSingleSession/TransformSingleSession.ts\nvar TransformSingleSession = class extends BaseSession {\n  type = \"transformSingle\" /* TransformSingle */;\n  status = \"transforming\" /* Transforming */;\n  performanceMode = void 0;\n  transformType;\n  scaleX = 1;\n  scaleY = 1;\n  isCreate;\n  initialShape;\n  initialShapeBounds;\n  initialCommonBounds;\n  snapInfo = { state: \"empty\" };\n  prevPoint = [0, 0];\n  speed = 1;\n  constructor(app, id, transformType, isCreate = false) {\n    super(app);\n    this.isCreate = isCreate;\n    this.transformType = transformType;\n    const shape = this.app.getShape(id);\n    this.initialShape = shape;\n    this.initialShapeBounds = TLDR.getBounds(shape);\n    this.initialCommonBounds = TLDR.getRotatedBounds(shape);\n    this.app.rotationInfo.selectedIds = [shape.id];\n  }\n  start = () => {\n    this.snapInfo = {\n      state: \"ready\",\n      bounds: this.app.shapes.filter((shape) => shape.id !== this.initialShape.id).map((shape) => C3.getBoundsWithCenter(TLDR.getRotatedBounds(shape)))\n    };\n    return void 0;\n  };\n  update = () => {\n    const {\n      transformType,\n      initialShape,\n      initialShapeBounds,\n      app: {\n        settings: { isSnapping, showGrid },\n        currentPageId,\n        pageState: { camera },\n        viewport,\n        currentPoint,\n        previousPoint,\n        originPoint,\n        currentGrid,\n        shiftKey,\n        altKey,\n        metaKey\n      }\n    } = this;\n    if (initialShape.isLocked)\n      return void 0;\n    const shapes = {};\n    const delta = altKey ? e.mul(e.sub(currentPoint, originPoint), 2) : e.sub(currentPoint, originPoint);\n    const shape = this.app.getShape(initialShape.id);\n    const utils = TLDR.getShapeUtil(shape);\n    let newBounds = C3.getTransformedBoundingBox(\n      initialShapeBounds,\n      transformType,\n      delta,\n      shape.rotation,\n      shiftKey || shape.isAspectRatioLocked || utils.isAspectRatioLocked\n    );\n    if (altKey) {\n      newBounds = {\n        ...newBounds,\n        ...C3.centerBounds(newBounds, C3.getBoundsCenter(initialShapeBounds))\n      };\n    }\n    if (showGrid) {\n      newBounds = {\n        ...newBounds,\n        ...C3.snapBoundsToGrid(newBounds, currentGrid)\n      };\n    }\n    const speed = e.dist(currentPoint, previousPoint);\n    const speedChange = speed - this.speed;\n    this.speed = this.speed + speedChange * (speedChange > 1 ? 0.5 : 0.15);\n    let snapLines = [];\n    if ((isSnapping && !metaKey || !isSnapping && metaKey) && !initialShape.rotation && this.speed * camera.zoom < SLOW_SPEED && this.snapInfo.state === \"ready\") {\n      const snapResult = C3.getSnapPoints(\n        C3.getBoundsWithCenter(newBounds),\n        this.snapInfo.bounds.filter((bounds) => C3.boundsContain(viewport, bounds) || C3.boundsCollide(viewport, bounds)),\n        SNAP_DISTANCE / camera.zoom\n      );\n      if (snapResult) {\n        snapLines = snapResult.snapLines;\n        newBounds = C3.getTransformedBoundingBox(\n          initialShapeBounds,\n          transformType,\n          e.sub(delta, snapResult.offset),\n          shape.rotation,\n          shiftKey || shape.isAspectRatioLocked || utils.isAspectRatioLocked\n        );\n      }\n    }\n    const afterShape = TLDR.getShapeUtil(shape).transformSingle(shape, newBounds, {\n      initialShape,\n      type: this.transformType,\n      scaleX: newBounds.scaleX,\n      scaleY: newBounds.scaleY,\n      transformOrigin: [0.5, 0.5]\n    });\n    if (afterShape) {\n      shapes[shape.id] = afterShape;\n    }\n    if (showGrid && afterShape && afterShape.point) {\n      afterShape.point = e.snap(afterShape.point, currentGrid);\n    }\n    return {\n      appState: {\n        snapLines\n      },\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes\n          }\n        }\n      }\n    };\n  };\n  cancel = () => {\n    const {\n      initialShape,\n      app: { currentPageId }\n    } = this;\n    const shapes = {};\n    if (this.isCreate) {\n      shapes[initialShape.id] = void 0;\n    } else {\n      shapes[initialShape.id] = initialShape;\n    }\n    return {\n      appState: {\n        snapLines: []\n      },\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes\n          }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: this.isCreate ? [] : [initialShape.id]\n          }\n        }\n      }\n    };\n  };\n  complete = () => {\n    const {\n      initialShape,\n      app: { currentPageId }\n    } = this;\n    if (initialShape.isLocked)\n      return;\n    if (this.isCreate && e.dist(this.app.originPoint, this.app.currentPoint) < 2) {\n      return this.cancel();\n    }\n    const beforeShapes = {};\n    const afterShapes = {};\n    beforeShapes[initialShape.id] = this.isCreate ? void 0 : initialShape;\n    afterShapes[initialShape.id] = TLDR.onSessionComplete(this.app.getShape(initialShape.id));\n    return {\n      id: \"transform_single\",\n      before: {\n        appState: {\n          snapLines: []\n        },\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: beforeShapes\n            }\n          },\n          pageStates: {\n            [currentPageId]: {\n              selectedIds: this.isCreate ? [] : [initialShape.id],\n              editingId: void 0,\n              hoveredId: void 0\n            }\n          }\n        }\n      },\n      after: {\n        appState: {\n          snapLines: []\n        },\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: afterShapes\n            }\n          },\n          pageStates: {\n            [currentPageId]: {\n              selectedIds: [initialShape.id],\n              editingId: void 0,\n              hoveredId: void 0\n            }\n          }\n        }\n      }\n    };\n  };\n};\n\n// src/components/Tldraw/state/sessions/TranslateSession/TranslateSession.ts\nvar TranslateSession = class extends BaseSession {\n  performanceMode = void 0;\n  type = \"translate\" /* Translate */;\n  status = \"translating\" /* Translating */;\n  delta = [0, 0];\n  prev = [0, 0];\n  prevPoint = [0, 0];\n  speed = 1;\n  cloneInfo = {\n    state: \"empty\"\n  };\n  snapInfo = {\n    state: \"empty\"\n  };\n  snapLines = [];\n  isCloning = false;\n  isCreate;\n  link;\n  initialIds;\n  hasUnlockedShapes;\n  initialSelectedIds;\n  initialCommonBounds;\n  initialShapes;\n  initialParentChildren;\n  bindingsToDelete;\n  constructor(app, isCreate = false, link = false) {\n    super(app);\n    this.isCreate = isCreate;\n    this.link = link;\n    const { currentPageId, selectedIds, page } = this.app;\n    this.initialSelectedIds = [...selectedIds];\n    const selectedShapes = (link ? TLDR.getLinkedShapeIds(this.app.state, currentPageId, link, false) : selectedIds).map((id) => this.app.getShape(id)).filter((shape) => !shape.isLocked);\n    const selectedShapeIds = new Set(selectedShapes.map((shape) => shape.id));\n    this.hasUnlockedShapes = selectedShapes.length > 0;\n    this.initialShapes = [\n      ...new Set(\n        selectedShapes.filter((shape) => !selectedShapeIds.has(shape.parentId)).flatMap((shape) => {\n          return shape.children ? [shape, ...shape.children.map((childId) => this.app.getShape(childId))] : [shape];\n        })\n      ).values()\n    ];\n    this.initialIds = new Set(this.initialShapes.map((shape) => shape.id));\n    this.bindingsToDelete = [];\n    Object.values(page.bindings).filter((binding) => this.initialIds.has(binding.fromId) || this.initialIds.has(binding.toId)).forEach((binding) => {\n      if (this.initialIds.has(binding.fromId) && !this.initialIds.has(binding.toId)) {\n        this.bindingsToDelete.push(binding);\n      }\n    });\n    this.initialParentChildren = {};\n    this.initialShapes.map((s5) => s5.parentId).filter((id) => id !== page.id).forEach((id) => {\n      this.initialParentChildren[id] = this.app.getShape(id).children;\n    });\n    this.initialCommonBounds = C3.getCommonBounds(this.initialShapes.map(TLDR.getRotatedBounds));\n    this.app.rotationInfo.selectedIds = [...this.app.selectedIds];\n  }\n  start = () => {\n    const {\n      bindingsToDelete,\n      initialIds,\n      app: { currentPageId, page }\n    } = this;\n    const allBounds = [];\n    const otherBounds = [];\n    Object.values(page.shapes).forEach((shape) => {\n      const bounds = C3.getBoundsWithCenter(TLDR.getRotatedBounds(shape));\n      allBounds.push(bounds);\n      if (!initialIds.has(shape.id)) {\n        otherBounds.push(bounds);\n      }\n    });\n    this.snapInfo = {\n      state: \"ready\",\n      bounds: allBounds,\n      others: otherBounds\n    };\n    if (bindingsToDelete.length === 0)\n      return;\n    const nextBindings = {};\n    const nextShapes = {};\n    bindingsToDelete.forEach((binding) => {\n      nextBindings[binding.id] = void 0;\n      const fromShape = this.app.getShape(binding.fromId);\n      nextShapes[binding.fromId] = {\n        handles: {\n          ...fromShape.handles,\n          [binding.handleId]: {\n            ...fromShape.handles[binding.handleId],\n            bindingId: void 0\n          }\n        }\n      };\n    });\n    return {\n      document: {\n        pages: {\n          [currentPageId]: {\n            bindings: nextBindings,\n            shapes: nextShapes\n          }\n        }\n      }\n    };\n  };\n  update = () => {\n    const {\n      initialParentChildren,\n      initialShapes,\n      initialCommonBounds,\n      bindingsToDelete,\n      app: {\n        pageState: { camera },\n        settings: { isSnapping, showGrid },\n        currentPageId,\n        viewport,\n        selectedIds,\n        currentPoint,\n        previousPoint,\n        originPoint,\n        altKey,\n        shiftKey,\n        metaKey,\n        currentGrid\n      }\n    } = this;\n    const nextBindings = {};\n    const nextShapes = {};\n    const nextPageState = {};\n    let delta = e.sub(currentPoint, originPoint);\n    let didChangeCloning = false;\n    if (!this.isCreate) {\n      if (altKey && !this.isCloning) {\n        this.isCloning = true;\n        didChangeCloning = true;\n      } else if (!altKey && this.isCloning) {\n        this.isCloning = false;\n        didChangeCloning = true;\n      }\n    }\n    if (shiftKey) {\n      if (Math.abs(delta[0]) < Math.abs(delta[1])) {\n        delta[0] = 0;\n      } else {\n        delta[1] = 0;\n      }\n    }\n    const speed = e.dist(currentPoint, previousPoint);\n    const change = speed - this.speed;\n    this.speed = this.speed + change * (change > 1 ? 0.5 : 0.15);\n    this.snapLines = [];\n    if ((isSnapping && !metaKey || !isSnapping && metaKey) && this.speed * camera.zoom < SLOW_SPEED && this.snapInfo.state === \"ready\") {\n      const snapResult = C3.getSnapPoints(\n        C3.getBoundsWithCenter(\n          showGrid ? C3.snapBoundsToGrid(C3.translateBounds(initialCommonBounds, delta), currentGrid) : C3.translateBounds(initialCommonBounds, delta)\n        ),\n        (this.isCloning ? this.snapInfo.bounds : this.snapInfo.others).filter((bounds) => {\n          return C3.boundsContain(viewport, bounds) || C3.boundsCollide(viewport, bounds);\n        }),\n        SNAP_DISTANCE / camera.zoom\n      );\n      if (snapResult) {\n        this.snapLines = snapResult.snapLines;\n        delta = e.sub(delta, snapResult.offset);\n      }\n    }\n    this.prev = delta;\n    if (this.isCloning) {\n      if (didChangeCloning) {\n        if (this.cloneInfo.state === \"empty\") {\n          this.createCloneInfo();\n        }\n        if (this.cloneInfo.state === \"empty\") {\n          throw Error;\n        }\n        const { clones, clonedBindings } = this.cloneInfo;\n        this.isCloning = true;\n        bindingsToDelete.forEach((binding) => nextBindings[binding.id] = binding);\n        initialShapes.forEach((shape) => nextShapes[shape.id] = { point: shape.point });\n        clones.forEach((clone) => {\n          nextShapes[clone.id] = { ...clone };\n          if (clone.parentId !== currentPageId && !selectedIds.includes(clone.parentId)) {\n            const children = nextShapes[clone.parentId]?.children || initialParentChildren[clone.parentId];\n            if (!children.includes(clone.id)) {\n              nextShapes[clone.parentId] = {\n                ...nextShapes[clone.parentId],\n                children: [...children, clone.id]\n              };\n            }\n          }\n        });\n        for (const binding of clonedBindings) {\n          nextBindings[binding.id] = binding;\n        }\n        nextPageState.selectedIds = clones.map((clone) => clone.id);\n        clones.forEach((clone) => {\n          nextShapes[clone.id] = {\n            ...clone,\n            point: showGrid ? e.snap(e.toFixed(e.add(clone.point, delta)), currentGrid) : e.toFixed(e.add(clone.point, delta))\n          };\n        });\n      } else {\n        if (this.cloneInfo.state === \"empty\")\n          throw Error;\n        const { clones } = this.cloneInfo;\n        clones.forEach((clone) => {\n          nextShapes[clone.id] = {\n            point: showGrid ? e.snap(e.toFixed(e.add(clone.point, delta)), currentGrid) : e.toFixed(e.add(clone.point, delta))\n          };\n        });\n      }\n    } else {\n      if (didChangeCloning) {\n        if (this.cloneInfo.state === \"empty\")\n          throw Error;\n        const { clones, clonedBindings } = this.cloneInfo;\n        this.isCloning = false;\n        bindingsToDelete.forEach((binding) => nextBindings[binding.id] = void 0);\n        clones.forEach((clone) => {\n          if (clone.parentId !== currentPageId) {\n            nextShapes[clone.parentId] = {\n              ...nextShapes[clone.parentId],\n              children: initialParentChildren[clone.parentId]\n            };\n          }\n        });\n        clones.forEach((clone) => nextShapes[clone.id] = void 0);\n        initialShapes.forEach((shape) => {\n          nextShapes[shape.id] = {\n            point: showGrid ? e.snap(e.toFixed(e.add(shape.point, delta)), currentGrid) : e.toFixed(e.add(shape.point, delta))\n          };\n        });\n        for (const binding of clonedBindings) {\n          nextBindings[binding.id] = void 0;\n        }\n        nextPageState.selectedIds = initialShapes.map((shape) => shape.id);\n      } else {\n        initialShapes.forEach((shape) => {\n          nextShapes[shape.id] = {\n            point: showGrid ? e.snap(e.toFixed(e.add(shape.point, delta)), currentGrid) : e.toFixed(e.add(shape.point, delta))\n          };\n        });\n      }\n    }\n    return {\n      appState: {\n        snapLines: this.snapLines\n      },\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: nextShapes,\n            bindings: nextBindings\n          }\n        },\n        pageStates: {\n          [currentPageId]: nextPageState\n        }\n      }\n    };\n  };\n  cancel = () => {\n    const {\n      initialShapes,\n      initialSelectedIds,\n      bindingsToDelete,\n      app: { currentPageId }\n    } = this;\n    const nextBindings = {};\n    const nextShapes = {};\n    const nextPageState = {\n      editingId: void 0,\n      hoveredId: void 0\n    };\n    if (this.isCreate) {\n      initialShapes.forEach(({ id }) => nextShapes[id] = void 0);\n      nextPageState.selectedIds = [];\n    } else {\n      initialShapes.forEach(\n        ({ id, point, handles }) => nextShapes[id] = handles ? { ...nextShapes[id], point, handles } : { ...nextShapes[id], point }\n      );\n      nextPageState.selectedIds = initialSelectedIds;\n      bindingsToDelete.forEach((binding) => {\n        nextBindings[binding.id] = binding;\n      });\n    }\n    if (this.cloneInfo.state === \"ready\") {\n      const { clones, clonedBindings } = this.cloneInfo;\n      clones.forEach((clone) => nextShapes[clone.id] = void 0);\n      clonedBindings.forEach((binding) => nextBindings[binding.id] = void 0);\n    }\n    return {\n      appState: {\n        snapLines: []\n      },\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: nextShapes,\n            bindings: nextBindings\n          }\n        },\n        pageStates: {\n          [currentPageId]: nextPageState\n        }\n      }\n    };\n  };\n  complete = () => {\n    const {\n      initialShapes,\n      initialParentChildren,\n      bindingsToDelete,\n      app: { currentPageId }\n    } = this;\n    const beforeBindings = {};\n    const beforeShapes = {};\n    const afterBindings = {};\n    const afterShapes = {};\n    if (this.isCloning) {\n      if (this.cloneInfo.state === \"empty\") {\n        this.createCloneInfo();\n      }\n      if (this.cloneInfo.state !== \"ready\")\n        throw Error;\n      const { clones, clonedBindings } = this.cloneInfo;\n      clones.forEach((clone) => {\n        beforeShapes[clone.id] = void 0;\n        afterShapes[clone.id] = this.app.getShape(clone.id);\n        if (clone.parentId !== currentPageId) {\n          beforeShapes[clone.parentId] = {\n            ...beforeShapes[clone.parentId],\n            children: initialParentChildren[clone.parentId]\n          };\n          afterShapes[clone.parentId] = {\n            ...afterShapes[clone.parentId],\n            children: this.app.getShape(clone.parentId).children\n          };\n        }\n      });\n      clonedBindings.forEach((binding) => {\n        beforeBindings[binding.id] = void 0;\n        afterBindings[binding.id] = this.app.getBinding(binding.id);\n      });\n    } else {\n      initialShapes.forEach((shape) => {\n        beforeShapes[shape.id] = this.isCreate ? void 0 : {\n          ...beforeShapes[shape.id],\n          point: shape.point\n        };\n        afterShapes[shape.id] = {\n          ...afterShapes[shape.id],\n          ...this.isCreate ? this.app.getShape(shape.id) : { point: this.app.getShape(shape.id).point }\n        };\n      });\n    }\n    bindingsToDelete.forEach((binding) => {\n      beforeBindings[binding.id] = binding;\n      beforeShapes[binding.fromId] = {\n        ...beforeShapes[binding.fromId],\n        id: binding.fromId,\n        handles: {\n          ...beforeShapes[binding.fromId]?.handles,\n          [binding.handleId]: {\n            ...beforeShapes[binding.fromId]?.handles?.[binding.handleId],\n            bindingId: binding.id\n          }\n        }\n      };\n      afterShapes[binding.fromId] = {\n        ...afterShapes[binding.fromId],\n        id: binding.fromId,\n        handles: {\n          ...afterShapes[binding.fromId].handles,\n          [binding.handleId]: {\n            ...afterShapes[binding.fromId]?.handles?.[binding.handleId],\n            bindingId: void 0\n          }\n        }\n      };\n    });\n    bindingsToDelete.forEach((binding) => afterBindings[binding.id] = void 0);\n    return {\n      id: \"translate\",\n      before: {\n        appState: {\n          snapLines: []\n        },\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: beforeShapes,\n              bindings: beforeBindings\n            }\n          },\n          pageStates: {\n            [currentPageId]: {\n              selectedIds: this.isCreate ? [] : [...this.initialSelectedIds]\n            }\n          }\n        }\n      },\n      after: {\n        appState: {\n          snapLines: []\n        },\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: afterShapes,\n              bindings: afterBindings\n            }\n          },\n          pageStates: {\n            [currentPageId]: {\n              selectedIds: [...this.app.selectedIds]\n            }\n          }\n        }\n      }\n    };\n  };\n  createCloneInfo = () => {\n    const {\n      initialShapes,\n      initialParentChildren,\n      app: { selectedIds, currentPageId, page }\n    } = this;\n    const cloneMap = {};\n    const clonedBindingsMap = {};\n    const clonedBindings = [];\n    const clones = [];\n    initialShapes.forEach((shape) => {\n      const newId = C3.uniqueId();\n      initialParentChildren[newId] = initialParentChildren[shape.id];\n      cloneMap[shape.id] = newId;\n      const clone = {\n        ...C3.deepClone(shape),\n        id: newId,\n        parentId: shape.parentId,\n        childIndex: TLDR.getChildIndexAbove(this.app.state, shape.id, currentPageId)\n      };\n      clones.push(clone);\n    });\n    clones.forEach((clone) => {\n      if (clone.children !== void 0) {\n        clone.children = clone.children.map((childId) => cloneMap[childId]);\n      }\n    });\n    clones.forEach((clone) => {\n      if (selectedIds.includes(clone.parentId)) {\n        clone.parentId = cloneMap[clone.parentId];\n      }\n    });\n    const clonedShapeIds = new Set(Object.keys(cloneMap));\n    Object.values(page.bindings).filter((binding) => clonedShapeIds.has(binding.fromId) || clonedShapeIds.has(binding.toId)).forEach((binding) => {\n      if (clonedShapeIds.has(binding.fromId) && clonedShapeIds.has(binding.toId)) {\n        const cloneId = C3.uniqueId();\n        const cloneBinding = {\n          ...C3.deepClone(binding),\n          id: cloneId,\n          fromId: cloneMap[binding.fromId] || binding.fromId,\n          toId: cloneMap[binding.toId] || binding.toId\n        };\n        clonedBindingsMap[binding.id] = cloneId;\n        clonedBindings.push(cloneBinding);\n      }\n    });\n    clones.forEach((clone) => {\n      if (clone.handles && clone.handles) {\n        for (const id in clone.handles) {\n          const handle = clone.handles[id];\n          handle.bindingId = handle.bindingId ? clonedBindingsMap[handle.bindingId] : void 0;\n        }\n      }\n    });\n    clones.forEach((clone) => {\n      if (page.shapes[clone.id]) {\n        throw new Error(\"uh oh, we didn't clone correctly\");\n      }\n    });\n    this.cloneInfo = {\n      state: \"ready\",\n      clones,\n      cloneMap,\n      clonedBindings\n    };\n  };\n};\n\n// src/components/Tldraw/state/sessions/index.ts\nvar sessions = {\n  [\"arrow\" /* Arrow */]: ArrowSession,\n  [\"brush\" /* Brush */]: BrushSession,\n  [\"draw\" /* Draw */]: DrawSession,\n  [\"erase\" /* Erase */]: EraseSession,\n  [\"handle\" /* Handle */]: HandleSession,\n  [\"rotate\" /* Rotate */]: RotateSession,\n  [\"transform\" /* Transform */]: TransformSession,\n  [\"transformSingle\" /* TransformSingle */]: TransformSingleSession,\n  [\"translate\" /* Translate */]: TranslateSession,\n  [\"grid\" /* Grid */]: GridSession,\n  [\"edit\" /* Edit */]: EditSession\n};\nvar getSession = (type) => {\n  return sessions[type];\n};\n\n// src/components/Tldraw/state/tools/BaseTool.ts\nvar BaseTool = class extends TDEventHandler {\n  constructor(app) {\n    super();\n    this.app = app;\n  }\n  type = \"select\";\n  previous;\n  status = \"idle\" /* Idle */;\n  setStatus = (status) => {\n    this.status = status;\n    this.app.setStatus(this.status);\n  };\n  onEnter = () => {\n    this.setStatus(\"idle\" /* Idle */);\n  };\n  onExit = () => {\n    this.setStatus(\"idle\" /* Idle */);\n  };\n  onCancel = () => {\n    if (this.status === \"idle\" /* Idle */) {\n      this.app.selectTool(\"select\");\n    } else {\n      this.setStatus(\"idle\" /* Idle */);\n    }\n    this.app.cancelSession();\n  };\n  getNextChildIndex = () => {\n    const {\n      shapes,\n      appState: { currentPageId }\n    } = this.app;\n    return shapes.length === 0 ? 1 : shapes.filter((shape) => shape.parentId === currentPageId).sort((a7, b6) => b6.childIndex - a7.childIndex)[0].childIndex + 1;\n  };\n  onPinchStart = () => {\n    this.app.cancelSession();\n    this.setStatus(\"pinching\" /* Pinching */);\n  };\n  onPinchEnd = () => {\n    if (C3.isMobileSafari()) {\n      this.app.undoSelect();\n    }\n    this.setStatus(\"idle\" /* Idle */);\n  };\n  onPinch = (info, e5) => {\n    if (this.status !== \"pinching\")\n      return;\n    if (isNaN(info.delta[0]) || isNaN(info.delta[1]))\n      return;\n    this.app.pinchZoom(info.point, info.delta, info.delta[2]);\n    this.onPointerMove?.(info, e5);\n  };\n  onKeyDown = (key) => {\n    if (key === \"Escape\") {\n      this.onCancel();\n      return;\n    }\n    if (key === \"Meta\" || key === \"Control\" || key === \"Alt\") {\n      this.app.updateSession();\n    }\n  };\n  onKeyUp = (key) => {\n    if (key === \"Meta\" || key === \"Control\" || key === \"Alt\") {\n      this.app.updateSession();\n    }\n  };\n  onPointerMove = () => {\n    if (this.status === \"creating\" /* Creating */) {\n      this.app.updateSession();\n    }\n  };\n  onPointerUp = () => {\n    if (this.status === \"creating\" /* Creating */) {\n      this.app.completeSession();\n      const { isToolLocked } = this.app.appState;\n      if (!isToolLocked) {\n        this.app.selectTool(\"select\");\n      }\n    }\n    this.setStatus(\"idle\" /* Idle */);\n  };\n};\n\n// src/components/Tldraw/state/tools/ArrowTool/ArrowTool.ts\nvar ArrowTool = class extends BaseTool {\n  type = \"arrow\" /* Arrow */;\n  onPointerDown = () => {\n    if (this.status !== \"idle\" /* Idle */)\n      return;\n    const {\n      currentPoint,\n      currentGrid,\n      settings: { showGrid },\n      appState: { currentPageId, currentStyle }\n    } = this.app;\n    const childIndex = this.getNextChildIndex();\n    const id = C3.uniqueId();\n    const newShape = Arrow.create({\n      id,\n      parentId: currentPageId,\n      childIndex,\n      point: showGrid ? p.snap(currentPoint, currentGrid) : currentPoint,\n      style: { ...currentStyle }\n    });\n    this.app.patchCreate([newShape]);\n    this.app.startSession(\"arrow\" /* Arrow */, newShape.id, \"end\", true);\n    this.setStatus(\"creating\" /* Creating */);\n  };\n};\n\n// src/components/Tldraw/state/tools/DrawTool/DrawTool.ts\nvar DrawTool = class extends BaseTool {\n  type = \"draw\" /* Draw */;\n  lastShapeId;\n  onEnter = () => {\n    this.lastShapeId = void 0;\n  };\n  onCancel = () => {\n    switch (this.status) {\n      case \"idle\" /* Idle */: {\n        this.app.selectTool(\"select\");\n        break;\n      }\n      default: {\n        this.setStatus(\"idle\" /* Idle */);\n        break;\n      }\n    }\n    this.app.cancelSession();\n  };\n  onPointerDown = (info) => {\n    if (this.status !== \"idle\" /* Idle */)\n      return;\n    if (this.app.readOnly)\n      return;\n    const {\n      currentPoint,\n      appState: { currentPageId, currentStyle }\n    } = this.app;\n    const previous = this.lastShapeId && this.app.getShape(this.lastShapeId);\n    if (info.shiftKey && previous) {\n      this.app.startSession(\"draw\" /* Draw */, previous.id);\n      this.setStatus(\"extending\" /* Extending */);\n    } else {\n      const childIndex = this.getNextChildIndex();\n      const id = C3.uniqueId();\n      const newShape = Draw.create({\n        id,\n        parentId: currentPageId,\n        childIndex,\n        point: currentPoint,\n        style: { ...currentStyle }\n      });\n      this.lastShapeId = id;\n      this.app.patchCreate([newShape]);\n      this.app.startSession(\"draw\" /* Draw */, id);\n      this.setStatus(\"creating\" /* Creating */);\n    }\n  };\n  onPointerMove = () => {\n    if (this.app.readOnly)\n      return;\n    switch (this.status) {\n      case \"extending\" /* Extending */:\n      case \"creating\" /* Creating */: {\n        this.app.updateSession();\n      }\n    }\n  };\n  onPointerUp = () => {\n    this.app.completeSession();\n    this.setStatus(\"idle\" /* Idle */);\n  };\n};\n\n// src/components/Tldraw/state/tools/EllipseTool/EllipseTool.ts\nvar EllipseTool = class extends BaseTool {\n  type = \"ellipse\" /* Ellipse */;\n  onPointerDown = () => {\n    if (this.app.readOnly)\n      return;\n    if (this.status !== \"idle\" /* Idle */)\n      return;\n    const {\n      currentPoint,\n      currentGrid,\n      settings: { showGrid },\n      appState: { currentPageId, currentStyle }\n    } = this.app;\n    const childIndex = this.getNextChildIndex();\n    const id = C3.uniqueId();\n    const newShape = Ellipse.create({\n      id,\n      parentId: currentPageId,\n      childIndex,\n      point: showGrid ? p.snap(currentPoint, currentGrid) : currentPoint,\n      style: { ...currentStyle }\n    });\n    this.app.patchCreate([newShape]);\n    this.app.startSession(\"transformSingle\" /* TransformSingle */, newShape.id, He.BottomRight, true);\n    this.setStatus(\"creating\" /* Creating */);\n  };\n};\n\n// src/components/Tldraw/state/tools/EraseTool/EraseTool.ts\nvar EraseTool = class extends BaseTool {\n  type = \"erase\";\n  status = \"idle\" /* Idle */;\n  onPointerDown = () => {\n    if (this.app.readOnly)\n      return;\n    if (this.status !== \"idle\" /* Idle */)\n      return;\n    this.setStatus(\"pointing\" /* Pointing */);\n  };\n  onPointerMove = (info) => {\n    if (this.app.readOnly)\n      return;\n    switch (this.status) {\n      case \"pointing\" /* Pointing */: {\n        if (p.dist(info.origin, info.point) > DEAD_ZONE) {\n          this.app.startSession(\"erase\" /* Erase */);\n          this.app.updateSession();\n          this.setStatus(\"erasing\" /* Erasing */);\n        }\n        break;\n      }\n      case \"erasing\" /* Erasing */: {\n        this.app.updateSession();\n      }\n    }\n  };\n  onPointerUp = () => {\n    if (this.app.readOnly)\n      return;\n    switch (this.status) {\n      case \"pointing\" /* Pointing */: {\n        const shapeIdsAtPoint = this.app.shapes.filter((shape) => !shape.isLocked).filter((shape) => this.app.getShapeUtil(shape).hitTestPoint(shape, this.app.currentPoint)).flatMap((shape) => shape.children ? [shape.id, ...shape.children] : shape.id);\n        this.app.delete(shapeIdsAtPoint);\n        break;\n      }\n      case \"erasing\" /* Erasing */: {\n        this.app.completeSession();\n      }\n    }\n    this.setStatus(\"idle\" /* Idle */);\n  };\n  onCancel = () => {\n    if (this.status === \"idle\" /* Idle */) {\n      if (this.previous) {\n        this.app.selectTool(this.previous);\n      } else {\n        this.app.selectTool(\"select\");\n      }\n    } else {\n      this.setStatus(\"idle\" /* Idle */);\n    }\n    this.app.cancelSession();\n  };\n};\n\n// src/components/Tldraw/state/tools/LineTool/LineTool.ts\nvar LineTool = class extends BaseTool {\n  type = \"line\" /* Line */;\n  onPointerDown = () => {\n    if (this.app.readOnly)\n      return;\n    if (this.status !== \"idle\" /* Idle */)\n      return;\n    const {\n      currentPoint,\n      currentGrid,\n      settings: { showGrid },\n      appState: { currentPageId, currentStyle }\n    } = this.app;\n    const childIndex = this.getNextChildIndex();\n    const id = C3.uniqueId();\n    const newShape = Arrow.create({\n      id,\n      parentId: currentPageId,\n      childIndex,\n      point: showGrid ? p.snap(currentPoint, currentGrid) : currentPoint,\n      decorations: {\n        start: void 0,\n        end: void 0\n      },\n      style: { ...currentStyle }\n    });\n    this.app.patchCreate([newShape]);\n    this.app.startSession(\"arrow\" /* Arrow */, newShape.id, \"end\", true);\n    this.setStatus(\"creating\" /* Creating */);\n  };\n};\n\n// src/components/Tldraw/state/tools/RectangleTool/RectangleTool.ts\nvar RectangleTool = class extends BaseTool {\n  type = \"rectangle\" /* Rectangle */;\n  onPointerDown = () => {\n    if (this.app.readOnly)\n      return;\n    if (this.status !== \"idle\" /* Idle */)\n      return;\n    const {\n      currentPoint,\n      currentGrid,\n      settings: { showGrid },\n      appState: { currentPageId, currentStyle }\n    } = this.app;\n    const childIndex = this.getNextChildIndex();\n    const id = C3.uniqueId();\n    const newShape = Rectangle.create({\n      id,\n      parentId: currentPageId,\n      childIndex,\n      point: showGrid ? p.snap(currentPoint, currentGrid) : currentPoint,\n      style: { ...currentStyle }\n    });\n    this.app.patchCreate([newShape]);\n    this.app.startSession(\"transformSingle\" /* TransformSingle */, newShape.id, He.BottomRight, true);\n    this.setStatus(\"creating\" /* Creating */);\n  };\n};\n\n// src/components/Tldraw/state/tools/SelectTool/SelectTool.ts\nvar SelectTool = class extends BaseTool {\n  type = \"select\";\n  pointedId;\n  selectedGroupId;\n  pointedHandleId;\n  pointedBoundsHandle;\n  pointedLinkHandleId;\n  deselect(id) {\n    this.app.select(...this.app.selectedIds.filter((oid) => oid !== id));\n  }\n  select(id) {\n    this.app.select(id);\n  }\n  pushSelect(id) {\n    const shape = this.app.getShape(id);\n    this.app.select(...this.app.selectedIds.filter((oid) => oid !== shape.parentId), id);\n  }\n  selectNone() {\n    this.app.selectNone();\n  }\n  onEnter = () => {\n    this.setStatus(\"idle\" /* Idle */);\n  };\n  onExit = () => {\n    this.setStatus(\"idle\" /* Idle */);\n  };\n  clonePaint = (point) => {\n    if (this.app.selectedIds.length === 0)\n      return;\n    const shapes = this.app.selectedIds.map((id) => this.app.getShape(id));\n    const bounds = C3.expandBounds(C3.getCommonBounds(shapes.map(TLDR.getBounds)), 16);\n    const center = C3.getBoundsCenter(bounds);\n    const size = [bounds.width, bounds.height];\n    const gridPoint = [\n      center[0] + size[0] * Math.floor((point[0] + size[0] / 2 - center[0]) / size[0]),\n      center[1] + size[1] * Math.floor((point[1] + size[1] / 2 - center[1]) / size[1])\n    ];\n    const centeredBounds = C3.centerBounds(bounds, gridPoint);\n    const hit = this.app.shapes.some((shape) => TLDR.getShapeUtil(shape).hitTestBounds(shape, centeredBounds));\n    if (!hit) {\n      this.app.duplicate(this.app.selectedIds, gridPoint);\n    }\n  };\n  getShapeClone = (id, side) => {\n    const shape = this.app.getShape(id);\n    const utils = TLDR.getShapeUtil(shape);\n    if (utils.canClone) {\n      const bounds = utils.getBounds(shape);\n      const center = utils.getCenter(shape);\n      let point = {\n        top: [bounds.minX, bounds.minY - (bounds.height + CLONING_DISTANCE)],\n        right: [bounds.maxX + CLONING_DISTANCE, bounds.minY],\n        bottom: [bounds.minX, bounds.maxY + CLONING_DISTANCE],\n        left: [bounds.minX - (bounds.width + CLONING_DISTANCE), bounds.minY],\n        topLeft: [bounds.minX - (bounds.width + CLONING_DISTANCE), bounds.minY - (bounds.height + CLONING_DISTANCE)],\n        topRight: [bounds.maxX + CLONING_DISTANCE, bounds.minY - (bounds.height + CLONING_DISTANCE)],\n        bottomLeft: [bounds.minX - (bounds.width + CLONING_DISTANCE), bounds.maxY + CLONING_DISTANCE],\n        bottomRight: [bounds.maxX + CLONING_DISTANCE, bounds.maxY + CLONING_DISTANCE]\n      }[side];\n      if (shape.rotation !== 0) {\n        const newCenter = p.add(point, [bounds.width / 2, bounds.height / 2]);\n        const rotatedCenter = p.rotWith(newCenter, center, shape.rotation || 0);\n        point = p.sub(rotatedCenter, [bounds.width / 2, bounds.height / 2]);\n      }\n      const id2 = C3.uniqueId();\n      const clone = {\n        ...shape,\n        id: id2,\n        point\n      };\n      if (clone.type === \"sticky\" /* Sticky */) {\n        clone.text = \"\";\n      }\n      return clone;\n    }\n  };\n  onCancel = () => {\n    if (this.app.session) {\n      this.app.cancelSession();\n    } else {\n      this.selectNone();\n    }\n    this.setStatus(\"idle\" /* Idle */);\n  };\n  onKeyDown = (key, info, e5) => {\n    switch (key) {\n      case \"Escape\": {\n        this.onCancel();\n        break;\n      }\n      case \"Tab\": {\n        if (this.app.readOnly)\n          return;\n        if (!this.app.pageState.editingId && this.status === \"idle\" /* Idle */ && this.app.selectedIds.length === 1) {\n          const [selectedId] = this.app.selectedIds;\n          const clonedShape = this.getShapeClone(selectedId, \"right\");\n          if (clonedShape) {\n            this.app.createShapes(clonedShape);\n            this.setStatus(\"idle\" /* Idle */);\n            if (clonedShape.type === \"sticky\" /* Sticky */) {\n              this.app.select(clonedShape.id);\n              this.app.setEditingId(clonedShape.id);\n            }\n          }\n        }\n        break;\n      }\n      case \"Meta\":\n      case \"Control\":\n      case \"Alt\": {\n        this.app.updateSession();\n        break;\n      }\n      case \"Enter\": {\n        if (this.app.readOnly)\n          return;\n        const { pageState } = this.app;\n        if (pageState.selectedIds.length === 1 && !pageState.editingId) {\n          this.app.setEditingId(pageState.selectedIds[0]);\n          e5.preventDefault();\n        }\n      }\n    }\n  };\n  onKeyUp = (key, info) => {\n    if (this.status === \"clonePainting\" /* ClonePainting */ && !(info.altKey && info.shiftKey)) {\n      this.setStatus(\"idle\" /* Idle */);\n      return;\n    }\n    if (key === \"Meta\" || key === \"Control\" || key === \"Alt\") {\n      this.app.updateSession();\n    }\n  };\n  onPointerMove = () => {\n    const { originPoint, currentPoint } = this.app;\n    if (this.app.readOnly && this.app.isPointing) {\n      if (this.app.session) {\n        this.app.updateSession();\n      } else {\n        if (p.dist(originPoint, currentPoint) > DEAD_ZONE) {\n          this.app.startSession(\"brush\" /* Brush */);\n          this.setStatus(\"brushing\" /* Brushing */);\n        }\n      }\n      return;\n    }\n    switch (this.status) {\n      case \"pointingBoundsHandle\" /* PointingBoundsHandle */: {\n        if (!this.pointedBoundsHandle)\n          throw new Error(\"No pointed bounds handle\");\n        if (p.dist(originPoint, currentPoint) > DEAD_ZONE) {\n          if (this.pointedBoundsHandle === \"rotate\") {\n            this.setStatus(\"rotating\" /* Rotating */);\n            this.app.startSession(\"rotate\" /* Rotate */);\n          } else if (this.pointedBoundsHandle === \"center\" || this.pointedBoundsHandle === \"left\" || this.pointedBoundsHandle === \"right\") {\n            this.setStatus(\"translating\" /* Translating */);\n            this.app.startSession(\"translate\" /* Translate */, false, this.pointedBoundsHandle);\n          } else {\n            this.setStatus(\"transforming\" /* Transforming */);\n            const idsToTransform = this.app.selectedIds.flatMap((id) => TLDR.getDocumentBranch(this.app.state, id, this.app.currentPageId));\n            if (idsToTransform.length === 1) {\n              this.app.startSession(\"transformSingle\" /* TransformSingle */, idsToTransform[0], this.pointedBoundsHandle);\n            } else {\n              this.app.startSession(\"transform\" /* Transform */, this.pointedBoundsHandle);\n            }\n          }\n          this.app.updateSession();\n        }\n        break;\n      }\n      case \"pointingCanvas\" /* PointingCanvas */: {\n        if (p.dist(originPoint, currentPoint) > DEAD_ZONE) {\n          this.app.startSession(\"brush\" /* Brush */);\n          this.setStatus(\"brushing\" /* Brushing */);\n        }\n        break;\n      }\n      case \"pointingClone\" /* PointingClone */: {\n        if (p.dist(originPoint, currentPoint) > DEAD_ZONE) {\n          this.setStatus(\"translatingClone\" /* TranslatingClone */);\n          this.app.startSession(\"translate\" /* Translate */);\n          this.app.updateSession();\n        }\n        break;\n      }\n      case \"pointingBounds\" /* PointingBounds */: {\n        if (p.dist(originPoint, currentPoint) > DEAD_ZONE) {\n          this.setStatus(\"translating\" /* Translating */);\n          this.app.startSession(\"translate\" /* Translate */);\n          this.app.updateSession();\n        }\n        break;\n      }\n      case \"pointingHandle\" /* PointingHandle */: {\n        if (!this.pointedHandleId)\n          throw new Error(\"No pointed handle\");\n        if (p.dist(originPoint, currentPoint) > DEAD_ZONE) {\n          this.setStatus(\"translatingHandle\" /* TranslatingHandle */);\n          const selectedShape = this.app.getShape(this.app.selectedIds[0]);\n          if (selectedShape) {\n            if (this.pointedHandleId === \"bend\") {\n              this.app.startSession(\"handle\" /* Handle */, selectedShape.id, this.pointedHandleId);\n              this.app.updateSession();\n            } else {\n              this.app.startSession(\"arrow\" /* Arrow */, selectedShape.id, this.pointedHandleId, false);\n              this.app.updateSession();\n            }\n          }\n        }\n        break;\n      }\n      case \"clonePainting\" /* ClonePainting */: {\n        this.clonePaint(currentPoint);\n        break;\n      }\n      default: {\n        if (this.app.session) {\n          this.app.updateSession();\n          break;\n        }\n      }\n    }\n  };\n  onPointerDown = (info, e5) => {\n    if (info.target === \"canvas\" && this.status === \"idle\" /* Idle */) {\n      const { currentPoint } = this.app;\n      if (info.spaceKey && e5.buttons === 1)\n        return;\n      if (this.status === \"idle\" /* Idle */ && info.altKey && info.shiftKey) {\n        this.setStatus(\"clonePainting\" /* ClonePainting */);\n        this.clonePaint(currentPoint);\n        return;\n      }\n      if (!info.shiftKey) {\n        this.app.onShapeBlur();\n        if (info.altKey && this.app.selectedIds.length > 0) {\n          this.app.duplicate(this.app.selectedIds, currentPoint);\n          return;\n        }\n        this.selectNone();\n      }\n      this.setStatus(\"pointingCanvas\" /* PointingCanvas */);\n    }\n  };\n  onPointerUp = (info) => {\n    if (this.status === \"translatingClone\" /* TranslatingClone */ || this.status === \"pointingClone\" /* PointingClone */) {\n      if (this.pointedId) {\n        this.app.completeSession();\n        this.app.setEditingId(this.pointedId);\n      }\n      this.setStatus(\"idle\" /* Idle */);\n      this.pointedId = void 0;\n      return;\n    }\n    if (this.status === \"pointingBounds\" /* PointingBounds */) {\n      if (info.target === \"bounds\") {\n        this.selectNone();\n      } else if (this.app.isSelected(info.target)) {\n        if (info.shiftKey) {\n          if (this.pointedId !== info.target) {\n            this.deselect(info.target);\n          }\n        } else {\n          if (this.pointedId !== info.target && this.app.selectedIds.length > 1) {\n            this.select(info.target);\n          }\n        }\n      } else if (this.pointedId === info.target) {\n        if (this.app.getShape(info.target).isLocked)\n          return;\n        if (info.shiftKey) {\n          this.pushSelect(info.target);\n        } else {\n          this.select(info.target);\n        }\n      }\n    }\n    this.setStatus(\"idle\" /* Idle */);\n    this.pointedBoundsHandle = void 0;\n    this.pointedHandleId = void 0;\n    this.pointedId = void 0;\n    if (this.app.session?.type === \"edit\" /* Edit */) {\n      return;\n    }\n    this.app.completeSession();\n  };\n  onDoubleClickCanvas = () => {\n    if (this.app.readOnly)\n      return;\n  };\n  onPointShape = (info, e5) => {\n    if (info.spaceKey && e5.buttons === 1)\n      return;\n    if (this.app.getShape(info.target).isLocked)\n      return;\n    const { editingId, hoveredId } = this.app.pageState;\n    if (editingId && info.target !== editingId) {\n      this.app.onShapeBlur();\n    }\n    if ((this.status === \"idle\" /* Idle */ || this.status === \"pointingBounds\" /* PointingBounds */) && info.metaKey && info.shiftKey && hoveredId) {\n      this.pointedId = hoveredId;\n      if (this.app.isSelected(hoveredId)) {\n        this.deselect(hoveredId);\n      } else {\n        this.pushSelect(hoveredId);\n        this.setStatus(\"pointingBounds\" /* PointingBounds */);\n      }\n      return;\n    }\n    if (this.status === \"pointingBounds\" /* PointingBounds */) {\n      const { parentId } = this.app.getShape(info.target);\n      this.pointedId = parentId === this.app.currentPageId ? info.target : parentId;\n      return;\n    }\n    if (this.status === \"idle\" /* Idle */) {\n      this.setStatus(\"pointingBounds\" /* PointingBounds */);\n      if (info.metaKey) {\n        if (!info.shiftKey) {\n          this.selectNone();\n        }\n        this.app.startSession(\"brush\" /* Brush */);\n        this.setStatus(\"brushing\" /* Brushing */);\n        return;\n      }\n      let shapeIdToSelect;\n      const { parentId } = this.app.getShape(info.target);\n      if (parentId === this.app.currentPageId) {\n        shapeIdToSelect = info.target;\n        this.selectedGroupId = void 0;\n      } else {\n        if (parentId === this.selectedGroupId) {\n          shapeIdToSelect = info.target;\n        } else {\n          shapeIdToSelect = parentId;\n          this.selectedGroupId = void 0;\n        }\n      }\n      if (!this.app.isSelected(shapeIdToSelect)) {\n        this.pointedId = shapeIdToSelect;\n        if (info.shiftKey) {\n          this.pushSelect(shapeIdToSelect);\n        } else {\n          this.select(shapeIdToSelect);\n        }\n      }\n    }\n  };\n  onDoubleClickShape = (info) => {\n    if (this.app.readOnly)\n      return;\n    const shape = this.app.getShape(info.target);\n    if (shape.isLocked) {\n      this.app.select(info.target);\n      return;\n    }\n    if (TLDR.getShapeUtil(shape.type).canEdit && (shape.parentId === this.app.currentPageId || shape.parentId === this.selectedGroupId)) {\n      this.app.setEditingId(info.target);\n    }\n    if (shape.parentId !== this.app.currentPageId) {\n      this.selectedGroupId = shape.parentId;\n    }\n    this.app.select(info.target);\n  };\n  onRightPointShape = (info) => {\n    if (!this.app.isSelected(info.target)) {\n      this.app.select(info.target);\n    }\n  };\n  onHoverShape = (info) => {\n    this.app.setHoveredId(info.target);\n  };\n  onUnhoverShape = (info) => {\n    const { currentPageId: oldCurrentPageId } = this.app;\n    requestAnimationFrame(() => {\n      if (oldCurrentPageId === this.app.currentPageId && this.app.pageState.hoveredId === info.target) {\n        this.app.setHoveredId();\n      }\n    });\n  };\n  onPointBounds = (info) => {\n    if (info.metaKey) {\n      if (!info.shiftKey) {\n        this.selectNone();\n      }\n      this.app.startSession(\"brush\" /* Brush */);\n      this.setStatus(\"brushing\" /* Brushing */);\n      return;\n    }\n    this.setStatus(\"pointingBounds\" /* PointingBounds */);\n  };\n  onRightPointBounds = (info, e5) => {\n    e5.stopPropagation();\n  };\n  onReleaseBounds = () => {\n    if (this.status === \"translating\" /* Translating */ || this.status === \"brushing\" /* Brushing */) {\n      this.app.completeSession();\n    }\n    this.setStatus(\"idle\" /* Idle */);\n  };\n  onPointBoundsHandle = (info) => {\n    this.pointedBoundsHandle = info.target;\n    this.setStatus(\"pointingBoundsHandle\" /* PointingBoundsHandle */);\n  };\n  onDoubleClickBoundsHandle = (info) => {\n    switch (info.target) {\n      case \"center\":\n      case \"left\":\n      case \"right\": {\n        this.app.select(...TLDR.getLinkedShapeIds(this.app.state, this.app.currentPageId, info.target, info.shiftKey));\n        break;\n      }\n      default: {\n        if (this.app.selectedIds.length === 1) {\n          this.app.resetBounds(this.app.selectedIds);\n          const shape = this.app.getShape(this.app.selectedIds[0]);\n          if (\"label\" in shape) {\n            this.app.setEditingId(shape.id);\n          }\n        }\n      }\n    }\n  };\n  onReleaseBoundsHandle = () => {\n    this.setStatus(\"idle\" /* Idle */);\n  };\n  onPointHandle = (info) => {\n    this.pointedHandleId = info.target;\n    this.setStatus(\"pointingHandle\" /* PointingHandle */);\n  };\n  onDoubleClickHandle = (info) => {\n    if (info.target === \"bend\") {\n      const { selectedIds } = this.app;\n      if (selectedIds.length !== 1)\n        return;\n      const shape = this.app.getShape(selectedIds[0]);\n      if (TLDR.getShapeUtil(shape.type).canEdit && (shape.parentId === this.app.currentPageId || shape.parentId === this.selectedGroupId)) {\n        this.app.setEditingId(shape.id);\n      }\n      return;\n    }\n    this.app.toggleDecoration(info.target);\n  };\n  onReleaseHandle = () => {\n    this.setStatus(\"idle\" /* Idle */);\n  };\n  onShapeClone = (info) => {\n    const selectedShapeId = this.app.selectedIds[0];\n    const clonedShape = this.getShapeClone(selectedShapeId, info.target);\n    if (info.target === \"left\" || info.target === \"right\" || info.target === \"top\" || info.target === \"bottom\") {\n      if (clonedShape) {\n        this.app.createShapes(clonedShape);\n        this.pointedId = clonedShape.id;\n        this.setStatus(\"pointingClone\" /* PointingClone */);\n      }\n    } else {\n      this.setStatus(\"gridCloning\" /* GridCloning */);\n      this.app.startSession(\"grid\" /* Grid */, selectedShapeId);\n    }\n  };\n};\n\n// src/components/Tldraw/state/tools/StickyTool/StickyTool.ts\nvar StickyTool = class extends BaseTool {\n  type = \"sticky\" /* Sticky */;\n  shapeId;\n  onPointerDown = () => {\n    if (this.app.readOnly)\n      return;\n    if (this.status === \"creating\" /* Creating */) {\n      this.setStatus(\"idle\" /* Idle */);\n      if (!this.app.appState.isToolLocked) {\n        this.app.selectTool(\"select\");\n      }\n      return;\n    }\n    if (this.status === \"idle\" /* Idle */) {\n      const {\n        currentPoint,\n        currentGrid,\n        settings: { showGrid },\n        appState: { currentPageId, currentStyle }\n      } = this.app;\n      const childIndex = this.getNextChildIndex();\n      const id = C3.uniqueId();\n      this.shapeId = id;\n      const newShape = Sticky.create({\n        id,\n        parentId: currentPageId,\n        childIndex,\n        point: showGrid ? p.snap(currentPoint, currentGrid) : currentPoint,\n        style: { ...currentStyle }\n      });\n      const bounds = Sticky.getBounds(newShape);\n      newShape.point = p.sub(newShape.point, [bounds.width / 2, bounds.height / 2]);\n      this.app.patchCreate([newShape]);\n      this.app.startSession(\"translate\" /* Translate */);\n      this.setStatus(\"creating\" /* Creating */);\n    }\n  };\n  onPointerUp = () => {\n    if (this.app.readOnly)\n      return;\n    if (this.status === \"creating\" /* Creating */) {\n      this.setStatus(\"idle\" /* Idle */);\n      this.app.completeSession();\n      this.app.selectTool(\"select\");\n      this.app.setEditingId(this.shapeId);\n    }\n  };\n};\n\n// src/components/Tldraw/state/tools/TextTool/TextTool.ts\nvar TextTool = class extends BaseTool {\n  type = \"text\" /* Text */;\n  stopEditingShape = () => {\n    this.setStatus(\"idle\" /* Idle */);\n    if (!this.app.appState.isToolLocked) {\n      this.app.selectTool(\"select\");\n    }\n  };\n  onKeyUp = () => {\n  };\n  onKeyDown = () => {\n  };\n  onPointerDown = () => {\n    if (this.status === \"creating\" /* Creating */) {\n      this.stopEditingShape();\n      return;\n    }\n    if (this.status === \"idle\" /* Idle */) {\n      const {\n        currentPoint,\n        currentGrid,\n        settings: { showGrid }\n      } = this.app;\n      this.app.createTextShapeAtPoint(showGrid ? p.snap(currentPoint, currentGrid) : currentPoint, void 0, true);\n      this.setStatus(\"creating\" /* Creating */);\n    }\n  };\n  onPointerUp = () => {\n  };\n  onPointShape = (info) => {\n    if (this.app.readOnly)\n      return;\n    const shape = this.app.getShape(info.target);\n    if (shape.type === \"text\" /* Text */) {\n      this.setStatus(\"idle\" /* Idle */);\n      this.app.setEditingId(shape.id);\n    }\n  };\n  onShapeBlur = () => {\n    if (this.app.readOnly)\n      return;\n    this.stopEditingShape();\n  };\n};\n\n// src/components/Tldraw/state/tools/TriangleTool/TriangleTool.ts\nvar TriangleTool = class extends BaseTool {\n  type = \"triangle\" /* Triangle */;\n  onPointerDown = () => {\n    if (this.app.readOnly)\n      return;\n    if (this.status !== \"idle\" /* Idle */)\n      return;\n    const {\n      currentPoint,\n      currentGrid,\n      settings: { showGrid },\n      appState: { currentPageId, currentStyle }\n    } = this.app;\n    const childIndex = this.getNextChildIndex();\n    const id = C3.uniqueId();\n    const newShape = Triangle.create({\n      id,\n      parentId: currentPageId,\n      childIndex,\n      point: showGrid ? p.snap(currentPoint, currentGrid) : currentPoint,\n      style: { ...currentStyle }\n    });\n    this.app.patchCreate([newShape]);\n    this.app.startSession(\"transformSingle\" /* TransformSingle */, newShape.id, He.BottomRight, true);\n    this.setStatus(\"creating\" /* Creating */);\n  };\n};\n\n// src/components/Tldraw/state/TldrawApp.ts\nvar uuid = C3.uniqueId();\nvar _TldrawApp = class extends StateManager {\n  callbacks = {};\n  tools = {\n    select: new SelectTool(this),\n    erase: new EraseTool(this),\n    [\"text\" /* Text */]: new TextTool(this),\n    [\"draw\" /* Draw */]: new DrawTool(this),\n    [\"ellipse\" /* Ellipse */]: new EllipseTool(this),\n    [\"rectangle\" /* Rectangle */]: new RectangleTool(this),\n    [\"triangle\" /* Triangle */]: new TriangleTool(this),\n    [\"line\" /* Line */]: new LineTool(this),\n    [\"arrow\" /* Arrow */]: new ArrowTool(this),\n    [\"sticky\" /* Sticky */]: new StickyTool(this)\n  };\n  currentTool = this.tools.select;\n  session;\n  readOnly = false;\n  isDirty = false;\n  isCreating = false;\n  originPoint = [0, 0];\n  currentPoint = [0, 0];\n  previousPoint = [0, 0];\n  shiftKey = false;\n  altKey = false;\n  metaKey = false;\n  ctrlKey = false;\n  spaceKey = false;\n  isPointing = false;\n  isForcePanning = false;\n  isErasingWithPen = false;\n  isPastePrevented = false;\n  editingStartTime = -1;\n  fileSystemHandle = null;\n  viewport = C3.getBoundsFromPoints([\n    [0, 0],\n    [100, 100]\n  ]);\n  rendererBounds = C3.getBoundsFromPoints([\n    [0, 0],\n    [100, 100]\n  ]);\n  selectHistory = {\n    stack: [[]],\n    pointer: 0\n  };\n  clipboard;\n  rotationInfo = {\n    selectedIds: [],\n    center: [0, 0]\n  };\n  constructor(id, callbacks = {}) {\n    super(_TldrawApp.defaultState, id, _TldrawApp.version, (prev, next, prevVersion) => {\n      return migrate(\n        {\n          ...next,\n          document: { ...next.document, ...prev.document, version: prevVersion }\n        },\n        _TldrawApp.version\n      );\n    });\n    this.callbacks = callbacks;\n  }\n  migrate = (state) => {\n    return migrate(state, _TldrawApp.version);\n  };\n  onReady = () => {\n    this.loadDocument(this.document);\n    try {\n      this.patchState({\n        ...migrate(this.state, _TldrawApp.version),\n        appState: {\n          status: \"idle\" /* Idle */\n        }\n      });\n    } catch (error) {\n      console.error(\"The data appears to be corrupted. Resetting!\", error);\n      localStorage.setItem(this.document.id + \"_corrupted\", JSON.stringify(this.document));\n      this.patchState({\n        ..._TldrawApp.defaultState,\n        appState: {\n          ..._TldrawApp.defaultState.appState,\n          status: \"idle\" /* Idle */\n        }\n      });\n    }\n    this.callbacks.onMount?.(this);\n  };\n  cleanup = (state, prev) => {\n    const next = { ...state };\n    if (next.document !== prev.document) {\n      Object.entries(next.document.pages).forEach(([pageId, page]) => {\n        if (page === void 0) {\n          delete next.document.pages[pageId];\n          delete next.document.pageStates[pageId];\n          return;\n        }\n        const prevPage = prev.document.pages[pageId];\n        const changedShapes = {};\n        if (!prevPage || page.shapes !== prevPage.shapes || page.bindings !== prevPage.bindings) {\n          page.shapes = { ...page.shapes };\n          page.bindings = { ...page.bindings };\n          const groupsToUpdate = /* @__PURE__ */ new Set();\n          Object.entries(page.shapes).forEach(([id, shape]) => {\n            let parentId;\n            if (shape) {\n              parentId = shape.parentId;\n            } else {\n              parentId = prevPage?.shapes[id]?.parentId;\n              delete page.shapes[id];\n            }\n            if (page.id === next.appState.currentPageId && prevPage?.shapes[id] !== shape) {\n              changedShapes[id] = shape;\n            }\n            if (parentId && parentId !== pageId) {\n              const group = page.shapes[parentId];\n              if (group !== void 0) {\n                groupsToUpdate.add(page.shapes[parentId]);\n              }\n            }\n          });\n          Object.keys(page.bindings).forEach((id) => {\n            if (!page.bindings[id]) {\n              delete page.bindings[id];\n            }\n          });\n          next.document.pages[pageId] = page;\n          const bindingsToUpdate = TLDR.getRelatedBindings(next, Object.keys(changedShapes), pageId);\n          const visitedShapes = /* @__PURE__ */ new Set();\n          bindingsToUpdate.forEach((binding) => {\n            if (!page.bindings[binding.id]) {\n              return;\n            }\n            const toShape = page.shapes[binding.toId];\n            const fromShape = page.shapes[binding.fromId];\n            if (!(toShape && fromShape)) {\n              delete next.document.pages[pageId].bindings[binding.id];\n              return;\n            }\n            if (visitedShapes.has(fromShape)) {\n              return;\n            }\n            const fromDelta = TLDR.updateArrowBindings(page, fromShape);\n            visitedShapes.add(fromShape);\n            if (fromDelta) {\n              const nextShape = {\n                ...fromShape,\n                ...fromDelta\n              };\n              page.shapes[fromShape.id] = nextShape;\n            }\n          });\n          groupsToUpdate.forEach((group) => {\n            if (!group)\n              throw new Error(\"no group!\");\n            const children = group.children.filter((id) => page.shapes[id] !== void 0);\n            const commonBounds = C3.getCommonBounds(\n              children.map((id) => page.shapes[id]).filter(Boolean).map((shape) => TLDR.getRotatedBounds(shape))\n            );\n            page.shapes[group.id] = {\n              ...group,\n              point: [commonBounds.minX, commonBounds.minY],\n              size: [commonBounds.width, commonBounds.height],\n              children\n            };\n          });\n        }\n        const nextPageState = {\n          ...next.document.pageStates[pageId]\n        };\n        if (!nextPageState.brush) {\n          delete nextPageState.brush;\n        }\n        if (nextPageState.hoveredId && !page.shapes[nextPageState.hoveredId]) {\n          delete nextPageState.hoveredId;\n        }\n        if (nextPageState.bindingId && !page.bindings[nextPageState.bindingId]) {\n          TLDR.warn(`Could not find the binding of ${pageId}`);\n          delete nextPageState.bindingId;\n        }\n        if (nextPageState.editingId && !page.shapes[nextPageState.editingId]) {\n          TLDR.warn(\"Could not find the editing shape!\");\n          delete nextPageState.editingId;\n        }\n        next.document.pageStates[pageId] = nextPageState;\n      });\n    }\n    Object.keys(next.document.assets ?? {}).forEach((id) => {\n      if (!next.document.assets?.[id]) {\n        delete next.document.assets?.[id];\n      }\n    });\n    if (this.readOnly) {\n      next.document.pages = prev.document.pages;\n    }\n    return next;\n  };\n  onPatch = (state, patch, id) => {\n    this.callbacks.onPatch?.(this, patch, id);\n  };\n  onCommand = (state, command, id) => {\n    this.clearSelectHistory();\n    this.isDirty = true;\n    this.callbacks.onCommand?.(this, command, id);\n  };\n  onReplace = () => {\n    this.clearSelectHistory();\n    this.isDirty = false;\n  };\n  onUndo = () => {\n    this.rotationInfo.selectedIds = [...this.selectedIds];\n    this.callbacks.onUndo?.(this);\n  };\n  onRedo = () => {\n    this.rotationInfo.selectedIds = [...this.selectedIds];\n    this.callbacks.onRedo?.(this);\n  };\n  onPersist = (state, patch) => {\n    this.callbacks.onPersist?.(this);\n  };\n  prevSelectedIds = this.selectedIds;\n  onStateDidChange = (_state, id) => {\n    this.callbacks.onChange?.(this, id);\n  };\n  preventPaste = () => {\n    if (this.isPastePrevented)\n      return;\n    const prevent = (event) => event.stopImmediatePropagation();\n    const enable = () => {\n      setTimeout(() => {\n        document.removeEventListener(\"paste\", prevent, { capture: true });\n        this.isPastePrevented = false;\n      }, 50);\n    };\n    document.addEventListener(\"paste\", prevent, { capture: true });\n    window.addEventListener(\"pointerup\", enable, { once: true });\n    this.isPastePrevented = true;\n  };\n  setStatus(status) {\n    return this.patchState(\n      {\n        appState: { status }\n      },\n      `set_status:${status}`\n    );\n  }\n  updateBounds = (bounds) => {\n    this.rendererBounds = bounds;\n    const { point, zoom } = this.camera;\n    this.updateViewport(point, zoom);\n    if (!this.readOnly && this.session) {\n      this.session.update();\n    }\n  };\n  updateViewport = (point, zoom) => {\n    const { width, height } = this.rendererBounds;\n    const [minX, minY] = e.sub(e.div([0, 0], zoom), point);\n    const [maxX, maxY] = e.sub(e.div([width, height], zoom), point);\n    this.viewport = {\n      minX,\n      minY,\n      maxX,\n      maxY,\n      height: maxX - minX,\n      width: maxY - minY\n    };\n  };\n  setEditingId = (id, isCreating = false) => {\n    if (this.readOnly)\n      return;\n    if (id) {\n      this.startSession(\"edit\" /* Edit */, id, isCreating);\n    } else {\n      if (!this.pageState.editingId)\n        return;\n      this.completeSession();\n    }\n    this.editingStartTime = performance.now();\n    this.patchState(\n      {\n        document: {\n          pageStates: {\n            [this.currentPageId]: {\n              editingId: id\n            }\n          }\n        }\n      },\n      `set_editing_id`\n    );\n  };\n  setHoveredId = (id) => {\n    this.patchState(\n      {\n        document: {\n          pageStates: {\n            [this.currentPageId]: {\n              hoveredId: id\n            }\n          }\n        }\n      },\n      `set_hovered_id`\n    );\n  };\n  setSetting = (name, value) => {\n    if (this.session)\n      return this;\n    const patch = {\n      settings: {\n        [name]: typeof value === \"function\" ? value(this.settings[name]) : value\n      }\n    };\n    this.patchState(patch, `settings:${name}`);\n    this.persist(patch);\n    return this;\n  };\n  toggleFocusMode = () => {\n    if (this.session)\n      return this;\n    const patch = {\n      settings: {\n        isFocusMode: !this.settings.isFocusMode\n      }\n    };\n    this.patchState(patch, `settings:toggled_focus_mode`);\n    this.persist(patch);\n    return this;\n  };\n  togglePenMode = () => {\n    if (this.session)\n      return this;\n    const patch = {\n      settings: {\n        isPenMode: !this.settings.isPenMode\n      }\n    };\n    this.patchState(patch, `settings:toggled_pen_mode`);\n    this.persist(patch);\n    return this;\n  };\n  toggleZoomSnap = () => {\n    if (this.session)\n      return this;\n    const patch = { settings: { isZoomSnap: !this.settings.isZoomSnap } };\n    this.patchState(patch, `settings:toggled_zoom_snap`);\n    this.persist(patch);\n    return this;\n  };\n  toggleDebugMode = () => {\n    if (this.session)\n      return this;\n    const patch = { settings: { isDebugMode: !this.settings.isDebugMode } };\n    this.patchState(patch, `settings:toggled_debug`);\n    this.persist(patch);\n    return this;\n  };\n  setMenuOpen = (isOpen) => {\n    const patch = { appState: { isMenuOpen: isOpen } };\n    this.patchState(patch, \"ui:toggled_menu_opened\");\n    this.persist(patch);\n    return this;\n  };\n  setIsLoading = (isLoading) => {\n    const patch = { appState: { isLoading } };\n    this.patchState(patch, \"ui:toggled_is_loading\");\n    this.persist(patch);\n    return this;\n  };\n  setMouseInBound = (mouseInBound) => {\n    const patch = { appState: { mouseInBound } };\n    this.patchState(patch, \"ui:toggled_mouse_in_bound\");\n    return this;\n  };\n  setDisableAssets = (disableAssets) => {\n    this.patchState({ appState: { disableAssets } }, \"ui:toggled_disable_images\");\n    return this;\n  };\n  get isMenuOpen() {\n    return this.appState.isMenuOpen;\n  }\n  get isMouseInBound() {\n    return this.appState.mouseInBound;\n  }\n  get isLoading() {\n    return this.appState.isLoading;\n  }\n  get disableAssets() {\n    return this.appState.disableAssets;\n  }\n  toggleGrid = () => {\n    if (this.session)\n      return this;\n    const patch = { settings: { showGrid: !this.settings.showGrid } };\n    this.patchState(patch, \"settings:toggled_grid\");\n    this.persist(patch);\n    return this;\n  };\n  selectTool = (type) => {\n    if (this.readOnly || this.session)\n      return this;\n    this.isPointing = false;\n    const tool = this.tools[type];\n    if (tool === this.currentTool) {\n      this.patchState({\n        appState: {\n          isToolLocked: false\n        }\n      });\n      return this;\n    }\n    this.currentTool.onExit();\n    tool.previous = this.currentTool.type;\n    this.currentTool = tool;\n    this.currentTool.onEnter();\n    return this.patchState(\n      {\n        appState: {\n          activeTool: type,\n          isToolLocked: false\n        }\n      },\n      `selected_tool:${type}`\n    );\n  };\n  toggleToolLock = () => {\n    if (this.session)\n      return this;\n    return this.patchState(\n      {\n        appState: {\n          isToolLocked: !this.appState.isToolLocked\n        }\n      },\n      `toggled_tool_lock`\n    );\n  };\n  resetDocument = () => {\n    if (this.session)\n      return this;\n    this.session = void 0;\n    this.currentTool = this.tools.select;\n    const doc = _TldrawApp.defaultDocument;\n    doc.pages.page.name = \"Page 1\";\n    this.resetHistory().clearSelectHistory().loadDocument(_TldrawApp.defaultDocument).persist({});\n    return this;\n  };\n  updateDocument = (document2, reason = \"updated_document\") => {\n    const prevState = this.state;\n    const nextState = {\n      ...prevState,\n      document: {\n        ...prevState.document,\n        assets: document2.assets\n      }\n    };\n    if (!document2.pages[this.currentPageId]) {\n      nextState.appState = {\n        ...prevState.appState,\n        currentPageId: Object.keys(document2.pages)[0]\n      };\n    }\n    let i4 = 1;\n    for (const nextPage of Object.values(document2.pages)) {\n      if (nextPage !== prevState.document.pages[nextPage.id]) {\n        nextState.document.pages[nextPage.id] = nextPage;\n        if (!nextPage.name) {\n          nextState.document.pages[nextPage.id].name = `Page ${i4 + 1}`;\n          i4++;\n        }\n      }\n    }\n    for (const nextPageState of Object.values(document2.pageStates)) {\n      if (nextPageState !== prevState.document.pageStates[nextPageState.id]) {\n        nextState.document.pageStates[nextPageState.id] = nextPageState;\n        const nextPage = document2.pages[nextPageState.id];\n        const keysToCheck = [\"bindingId\", \"editingId\", \"hoveredId\", \"pointedId\"];\n        for (const key of keysToCheck) {\n          if (!nextPage.shapes[key]) {\n            nextPageState[key] = void 0;\n          }\n        }\n        nextPageState.selectedIds = nextPageState.selectedIds.filter((id) => !!document2.pages[nextPage.id].shapes[id]);\n      }\n    }\n    return this.replaceState(migrate(nextState, nextState.document.version || 0), `${reason}:${document2.id}`);\n  };\n  loadDocument = (document2) => {\n    this.setIsLoading(true);\n    this.selectNone();\n    this.resetHistory();\n    this.clearSelectHistory();\n    this.session = void 0;\n    const state = {\n      ..._TldrawApp.defaultState,\n      settings: {\n        ...this.state.settings\n      },\n      document: document2,\n      appState: {\n        ..._TldrawApp.defaultState.appState,\n        ...this.state.appState,\n        currentPageId: Object.keys(document2.pages)[0],\n        disableAssets: this.disableAssets\n      }\n    };\n    this.replaceState(migrate(state, _TldrawApp.version), \"loaded_document\");\n    const { point, zoom } = this.camera;\n    this.updateViewport(point, zoom);\n    this.setIsLoading(false);\n    return this;\n  };\n  openAsset = async () => {\n    if (!this.disableAssets)\n      try {\n        const file = await openAssetsFromFileSystem();\n        if (Array.isArray(file)) {\n          await this.addMediaFromFiles(file, this.centerPoint);\n        } else {\n          if (!file)\n            return;\n          await this.addMediaFromFiles([file]);\n        }\n      } catch (error) {\n        console.error(error);\n      } finally {\n        await this.persist({});\n      }\n  };\n  getAppState = () => {\n    return this.appState;\n  };\n  getPage = (pageId = this.currentPageId) => {\n    return TLDR.getPage(this.state, pageId || this.currentPageId);\n  };\n  getShapes = (pageId = this.currentPageId) => {\n    return TLDR.getShapes(this.state, pageId || this.currentPageId);\n  };\n  getBindings = (pageId = this.currentPageId) => {\n    return TLDR.getBindings(this.state, pageId || this.currentPageId);\n  };\n  getShape = (id, pageId = this.currentPageId) => {\n    return TLDR.getShape(this.state, id, pageId);\n  };\n  getShapeBounds = (id, pageId = this.currentPageId) => {\n    return TLDR.getBounds(this.getShape(id, pageId));\n  };\n  getBinding = (id, pageId = this.currentPageId) => {\n    return TLDR.getBinding(this.state, id, pageId);\n  };\n  getPageState = (pageId = this.currentPageId) => {\n    return TLDR.getPageState(this.state, pageId || this.currentPageId);\n  };\n  getPagePoint = (point, pageId = this.currentPageId) => {\n    const { camera } = this.getPageState(pageId);\n    return e.sub(e.div(point, camera.zoom), camera.point);\n  };\n  get history() {\n    return this.stack.slice(0, this.pointer + 1);\n  }\n  set history(commands) {\n    this.replaceHistory(commands);\n  }\n  get document() {\n    return this.state.document;\n  }\n  get settings() {\n    return this.state.settings;\n  }\n  get appState() {\n    return this.state.appState;\n  }\n  get currentPageId() {\n    return this.state.appState.currentPageId;\n  }\n  get page() {\n    return this.state.document.pages[this.currentPageId];\n  }\n  get shapes() {\n    return Object.values(this.page.shapes);\n  }\n  get bindings() {\n    return Object.values(this.page.bindings);\n  }\n  get assets() {\n    return Object.values(this.document.assets);\n  }\n  get pageState() {\n    return this.state.document.pageStates[this.currentPageId];\n  }\n  get camera() {\n    return this.pageState.camera;\n  }\n  get zoom() {\n    return this.pageState.camera.zoom;\n  }\n  get selectedIds() {\n    return this.pageState.selectedIds;\n  }\n  createPage = (id, name) => {\n    if (this.readOnly)\n      return this;\n    const { width, height } = this.rendererBounds;\n    return this.setState(createPage(this, [-width / 2, -height / 2], id, name));\n  };\n  changePage = (pageId) => {\n    return this.setState(changePage(this, pageId));\n  };\n  movePage = (pageId, index2) => {\n    if (this.readOnly)\n      return this;\n    return this.setState(movePage(this, pageId, index2));\n  };\n  renamePage = (pageId, name) => {\n    if (this.readOnly)\n      return this;\n    return this.setState(renamePage(this, pageId, name));\n  };\n  duplicatePage = (pageId) => {\n    if (this.readOnly)\n      return this;\n    return this.setState(duplicatePage(this, pageId));\n  };\n  deletePage = (pageId) => {\n    if (this.readOnly)\n      return this;\n    if (Object.values(this.document.pages).length <= 1)\n      return this;\n    return this.setState(deletePage(this, pageId || this.currentPageId));\n  };\n  cut = (ids = this.selectedIds, event) => {\n    event?.preventDefault();\n    this.copy(ids, event);\n    if (!this.readOnly) {\n      this.delete(ids);\n    }\n    return this;\n  };\n  copy = (ids = this.selectedIds, event) => {\n    event?.preventDefault();\n    event?.stopPropagation();\n    this.clipboard = this.getContent(ids);\n    const jsonString = JSON.stringify({\n      type: \"tldr/clipboard\",\n      ...this.clipboard\n    });\n    const tldrawString = `<tldraw>${jsonString}</tldraw>`;\n    if (event) {\n      event.clipboardData?.setData(\"text/html\", tldrawString);\n    }\n    if (navigator.clipboard && window.ClipboardItem) {\n      void navigator.clipboard.write([\n        new ClipboardItem({\n          \"text/html\": new Blob([tldrawString], { type: \"text/html\" })\n        })\n      ]);\n    }\n    return this;\n  };\n  paste = async (point, event) => {\n    event?.preventDefault();\n    event?.stopPropagation();\n    if (this.readOnly)\n      return;\n    const filesToPaste = [];\n    const shapesToCreate = [];\n    let clipboardData;\n    const getSvgFromText = async (text) => {\n      const div = document.createElement(\"div\");\n      div.innerHTML = text;\n      const svg = div.firstChild;\n      svg.style.setProperty(\"background-color\", \"transparent\");\n      const imageBlob = await TLDR.getImageForSvg(svg, \"svg\" /* SVG */, {\n        scale: 1,\n        quality: 1\n      });\n      if (imageBlob) {\n        const file = new File([imageBlob], \"image.svg\");\n        filesToPaste.push(file);\n      } else {\n        getShapeFromText(text);\n      }\n    };\n    const getShapeFromText = (text) => {\n      const pagePoint = this.getPagePoint(point ?? this.centerPoint, this.currentPageId);\n      const isMultiline = text.includes(\"\\n\");\n      shapesToCreate.push(\n        TLDR.getShapeUtil(\"text\" /* Text */).getShape({\n          id: C3.uniqueId(),\n          type: \"text\" /* Text */,\n          parentId: this.appState.currentPageId,\n          text: TLDR.normalizeText(text.trim()),\n          point: pagePoint,\n          style: {\n            ...this.appState.currentStyle,\n            textAlign: isMultiline ? \"start\" /* Start */ : this.appState.currentStyle.textAlign\n          }\n        })\n      );\n    };\n    const getShapeFromHtml = (html) => {\n      try {\n        const maybeJson = html.match(/<tldraw>(.*)<\\/tldraw>/)?.[1];\n        if (!maybeJson)\n          return;\n        const json = JSON.parse(maybeJson);\n        if (json.type === \"tldr/clipboard\") {\n          clipboardData = json;\n          return;\n        } else {\n          throw new Error(\"Not tldraw data!\");\n        }\n      } catch {\n        getShapeFromText(html);\n      }\n    };\n    if (event !== void 0) {\n      const items = [...event.clipboardData?.items ?? []];\n      await Promise.all(\n        items.map(async (item) => {\n          const { type, kind } = item;\n          switch (kind) {\n            case \"string\": {\n              const str = await new Promise((resolve) => item.getAsString(resolve));\n              switch (type) {\n                case \"text/html\": {\n                  if (str.match(/<tldraw>(.*)<\\/tldraw>/)?.[1]) {\n                    getShapeFromHtml(str);\n                  }\n                  break;\n                }\n                case \"text/plain\": {\n                  if (str.startsWith(\"<svg\")) {\n                    await getSvgFromText(str);\n                  } else {\n                    getShapeFromText(str);\n                  }\n                  break;\n                }\n              }\n              break;\n            }\n            case \"file\": {\n              const file = item.getAsFile();\n              if (file)\n                filesToPaste.push(file);\n              break;\n            }\n          }\n        })\n      );\n    }\n    if (clipboardData) {\n      this.insertContent(clipboardData, { point, select: true });\n      return this;\n    }\n    if (filesToPaste.length > 0) {\n      this.addMediaFromFiles(filesToPaste, point);\n      return this;\n    }\n    if (shapesToCreate.length > 0) {\n      const pagePoint = this.getPagePoint(point ?? this.centerPoint, this.currentPageId);\n      const currentPoint = e.add(pagePoint, [0, 0]);\n      shapesToCreate.forEach((shape, i4) => {\n        const bounds = TLDR.getBounds(shape);\n        if (i4 === 0) {\n          currentPoint[0] -= bounds.width / 2;\n          currentPoint[1] -= bounds.height / 2;\n        }\n        shape.point = [...currentPoint];\n        currentPoint[0] += bounds.width;\n      });\n      this.createShapes(...shapesToCreate);\n      return this;\n    }\n    if (this.clipboard) {\n      this.insertContent(this.clipboard);\n    }\n    return this;\n  };\n  getSvg = async (ids = this.selectedIds.length > 0 ? this.selectedIds : Object.keys(this.page.shapes)) => {\n    if (ids.length === 0)\n      return;\n    const svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n    const defs = document.createElementNS(\"http://www.w3.org/2000/svg\", \"defs\");\n    const style = document.createElementNS(\"http://www.w3.org/2000/svg\", \"style\");\n    if (typeof window !== \"undefined\") {\n      window.focus();\n    }\n    defs.append(style);\n    svg.append(defs);\n    const shapes = ids.map((id) => this.getShape(id, this.currentPageId)).sort((a7, b6) => a7.childIndex - b6.childIndex);\n    const commonBounds = C3.getCommonBounds(shapes.map(TLDR.getRotatedBounds));\n    const getSvgElementForShape = (shape) => {\n      const util = TLDR.getShapeUtil(shape);\n      const bounds = util.getBounds(shape);\n      const elm = util.getSvgElement(shape);\n      if (!elm)\n        return;\n      if (shape.type === \"image\" /* Image */) {\n        elm.setAttribute(\"xlink:href\", this.document.assets[shape.assetId].src);\n      }\n      elm.setAttribute(\n        \"transform\",\n        `translate(${(SVG_EXPORT_PADDING + shape.point[0] - commonBounds.minX).toFixed(2)}, ${(SVG_EXPORT_PADDING + shape.point[1] - commonBounds.minY).toFixed(\n          2\n        )}) rotate(${((shape.rotation || 0) * 180 / Math.PI).toFixed(2)}, ${(bounds.width / 2).toFixed(2)}, ${(bounds.height / 2).toFixed(2)})`\n      );\n      return elm;\n    };\n    shapes.forEach((shape) => {\n      if (shape.children?.length) {\n        const g6 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n        shape.children.forEach((childId) => {\n          const shape2 = this.getShape(childId, this.currentPageId);\n          const elm2 = getSvgElementForShape(shape2);\n          if (elm2) {\n            g6.append(elm2);\n          }\n        });\n        svg.append(g6);\n        return;\n      }\n      const elm = getSvgElementForShape(shape);\n      if (elm) {\n        svg.append(elm);\n      }\n    });\n    svg.setAttribute(\"viewBox\", [0, 0, commonBounds.width + SVG_EXPORT_PADDING * 2, commonBounds.height + SVG_EXPORT_PADDING * 2].join(\" \"));\n    svg.setAttribute(\"width\", (commonBounds.width + SVG_EXPORT_PADDING * 2).toString());\n    svg.setAttribute(\"height\", (commonBounds.height + SVG_EXPORT_PADDING * 2).toString());\n    const exportBackground = this.settings.exportBackground;\n    const darkBackground = \"#212529\";\n    const lightBackground = \"rgb(248, 249, 250)\";\n    switch (exportBackground) {\n      case \"dark\" /* Dark */: {\n        svg.style.setProperty(\"background-color\", darkBackground);\n        break;\n      }\n      case \"auto\" /* Auto */:\n      case \"light\" /* Light */: {\n        svg.style.setProperty(\"background-color\", lightBackground);\n        break;\n      }\n      case \"transparent\" /* Transparent */:\n      default: {\n        svg.style.setProperty(\"background-color\", \"transparent\");\n        break;\n      }\n    }\n    svg.querySelectorAll(\".tl-fill-hitarea, .tl-stroke-hitarea, .tl-binding-indicator\").forEach((elm) => elm.remove());\n    return svg;\n  };\n  copySvg = async (ids = this.selectedIds.length > 0 ? this.selectedIds : Object.keys(this.page.shapes)) => {\n    if (ids.length === 0)\n      return;\n    const svg = await this.getSvg(ids);\n    if (!svg)\n      return;\n    const svgString = TLDR.getSvgString(svg, 1);\n    this.clipboard = this.getContent(ids);\n    const tldrawString = JSON.stringify({\n      type: \"tldr/clipboard\",\n      ...this.clipboard\n    });\n    if (navigator.clipboard && window.ClipboardItem) {\n      navigator.clipboard.write([\n        new ClipboardItem({\n          \"text/html\": new Blob([tldrawString], { type: \"text/html\" }),\n          \"text/plain\": new Blob([svgString], { type: \"text/plain\" })\n        })\n      ]);\n    }\n    return svgString;\n  };\n  getContent = (ids) => {\n    const page = this.getPage(this.currentPageId);\n    if (ids && ids.length === 0)\n      return;\n    if (!ids)\n      ids = this.selectedIds;\n    if (ids.length === 0)\n      ids = Object.keys(page.shapes);\n    if (ids.length === 0)\n      return;\n    const shapes = ids.map((id) => page.shapes[id]).flatMap((shape) => [shape, ...(shape.children ?? []).map((childId) => page.shapes[childId])]).map(deepCopy);\n    const idsSet = new Set(shapes.map((s5) => s5.id));\n    shapes.forEach((shape) => {\n      if (shape.parentId === this.currentPageId) {\n        shape.parentId = \"currentPageId\";\n      }\n    });\n    const bindings = Object.values(page.bindings).filter((binding) => {\n      if (idsSet.has(binding.fromId) || idsSet.has(binding.toId)) {\n        return true;\n      }\n      if (idsSet.has(binding.fromId)) {\n        const shape = shapes.find((s5) => s5.id === binding.fromId);\n        const handles = shape.handles;\n        if (handles) {\n          Object.values(handles).forEach((handle) => {\n            if (handle.bindingId === binding.id) {\n              handle.bindingId = void 0;\n            }\n          });\n        }\n      }\n      if (idsSet.has(binding.toId)) {\n        const shape = shapes.find((s5) => s5.id === binding.toId);\n        const handles = shape.handles;\n        if (handles) {\n          Object.values(handles).forEach((handle) => {\n            if (handle.bindingId === binding.id) {\n              handle.bindingId = void 0;\n            }\n          });\n        }\n      }\n      return false;\n    }).map(deepCopy);\n    const assets = [\n      ...new Set(\n        shapes.map((shape) => {\n          if (!shape.assetId)\n            return;\n          return this.document.assets[shape.assetId];\n        }).filter(Boolean).map(deepCopy)\n      )\n    ];\n    return { shapes, bindings, assets };\n  };\n  copyJson = (ids = this.selectedIds) => {\n    const content = this.getContent(ids);\n    if (content) {\n      TLDR.copyStringToClipboard(JSON.stringify(content));\n    }\n    return this;\n  };\n  exportJson = (ids = this.selectedIds) => {\n    const content = this.getContent(ids);\n    if (content) {\n      const blob = new Blob([JSON.stringify(content)], { type: \"application/json\" });\n      const url = URL.createObjectURL(blob);\n      const link = document.createElement(\"a\");\n      link.href = url;\n      link.download = `export.json`;\n      link.click();\n    }\n    return this;\n  };\n  insertContent = (content, opts = {}) => {\n    return this.setState(insertContent(this, content, opts), \"insert_content\");\n  };\n  getImage = async (format = \"png\" /* PNG */, opts = {}) => {\n    const { ids = this.selectedIds.length > 0 ? this.selectedIds : Object.keys(this.page.shapes) } = opts;\n    const svg = await this.getSvg(ids);\n    if (!svg)\n      return;\n    if (format === \"svg\" /* SVG */) {\n      const svgString = TLDR.getSvgString(svg, 1);\n      const blob = new Blob([svgString], { type: \"image/svg+xml\" });\n      return blob;\n    }\n    const imageBlob = await TLDR.getImageForSvg(svg, format, opts);\n    if (!imageBlob)\n      return;\n    return imageBlob;\n  };\n  copyImage = async (format = \"png\" /* PNG */, opts = {}) => {\n    if (format === \"svg\" /* SVG */) {\n      await this.copySvg(opts.ids);\n      return;\n    }\n    if (!(navigator.clipboard && window.ClipboardItem)) {\n      console.warn(\"Sorry, your browser does not support copying images.\");\n      return;\n    }\n    const blob = await this.getImage(format, opts);\n    if (!blob)\n      return;\n    await navigator.clipboard.write([\n      new ClipboardItem({\n        [blob.type]: blob\n      })\n    ]);\n  };\n  exportImage = async (format = \"png\" /* PNG */, opts = {}) => {\n    const { pageId = this.currentPageId } = opts;\n    const blob = await this.getImage(format, opts);\n    if (!blob)\n      return;\n    const name = this.document.pages[pageId].name ?? \"export\";\n    if (this.callbacks.onExport) {\n      await this.callbacks.onExport(this, {\n        name,\n        type: format,\n        blob\n      });\n    } else {\n      const url = URL.createObjectURL(blob);\n      const link = document.createElement(\"a\");\n      link.href = url;\n      link.download = `${name}.${format}`;\n      link.click();\n    }\n  };\n  setCamera = (point, zoom, reason) => {\n    this.updateViewport(point, zoom);\n    this.patchState(\n      {\n        document: {\n          pageStates: {\n            [this.currentPageId]: { camera: { point, zoom } }\n          }\n        }\n      },\n      reason\n    );\n    return this;\n  };\n  resetCamera = () => {\n    return this.setCamera(this.centerPoint, 1, `reset_camera`);\n  };\n  pan = (delta) => {\n    const { camera } = this.pageState;\n    return this.setCamera(e.toFixed(e.sub(camera.point, delta)), camera.zoom, `panned`);\n  };\n  pinchZoom = (point, delta, zoom) => {\n    const { camera } = this.pageState;\n    const nextPoint = e.sub(camera.point, e.div(delta, camera.zoom));\n    const nextZoom = zoom;\n    const p0 = e.sub(e.div(point, camera.zoom), nextPoint);\n    const p1 = e.sub(e.div(point, nextZoom), nextPoint);\n    return this.setCamera(e.toFixed(e.add(nextPoint, e.sub(p1, p0))), nextZoom, `pinch_zoomed`);\n  };\n  zoomTo = (next, center = this.centerPoint) => {\n    const { zoom, point } = this.camera;\n    const p0 = e.sub(e.div(center, zoom), point);\n    const p1 = e.sub(e.div(center, next), point);\n    return this.setCamera(e.toFixed(e.add(point, e.sub(p1, p0))), next, `zoomed_camera`);\n  };\n  zoomIn = () => {\n    const i4 = Math.round(this.camera.zoom * 100 / 25);\n    const nextZoom = TLDR.getCameraZoom((i4 + 1) * 0.25);\n    return this.zoomTo(nextZoom);\n  };\n  zoomOut = () => {\n    const i4 = Math.round(this.camera.zoom * 100 / 25);\n    const nextZoom = TLDR.getCameraZoom((i4 - 1) * 0.25);\n    return this.zoomTo(nextZoom);\n  };\n  zoomToFit = () => {\n    const {\n      shapes,\n      pageState: { camera }\n    } = this;\n    if (shapes.length === 0)\n      return this;\n    const { rendererBounds } = this;\n    const commonBounds = C3.getCommonBounds(shapes.map(TLDR.getBounds));\n    let zoom = TLDR.getCameraZoom(\n      Math.min((rendererBounds.width - FIT_TO_SCREEN_PADDING) / commonBounds.width, (rendererBounds.height - FIT_TO_SCREEN_PADDING) / commonBounds.height)\n    );\n    zoom = camera.zoom === zoom || camera.zoom < 1 ? Math.min(1, zoom) : zoom;\n    const mx = (rendererBounds.width - commonBounds.width * zoom) / 2 / zoom;\n    const my = (rendererBounds.height - commonBounds.height * zoom) / 2 / zoom;\n    return this.setCamera(e.toFixed(e.sub([mx, my], [commonBounds.minX, commonBounds.minY])), zoom, `zoomed_to_fit`);\n  };\n  zoomToSelection = () => {\n    if (this.selectedIds.length === 0)\n      return this;\n    const { rendererBounds } = this;\n    const selectedBounds = TLDR.getSelectedBounds(this.state);\n    let zoom = TLDR.getCameraZoom(\n      Math.min((rendererBounds.width - FIT_TO_SCREEN_PADDING) / selectedBounds.width, (rendererBounds.height - FIT_TO_SCREEN_PADDING) / selectedBounds.height)\n    );\n    zoom = this.camera.zoom === zoom || this.camera.zoom < 1 ? Math.min(1, zoom) : zoom;\n    const mx = (rendererBounds.width - selectedBounds.width * zoom) / 2 / zoom;\n    const my = (rendererBounds.height - selectedBounds.height * zoom) / 2 / zoom;\n    return this.setCamera(e.toFixed(e.sub([mx, my], [selectedBounds.minX, selectedBounds.minY])), zoom, `zoomed_to_selection`);\n  };\n  zoomToContent = () => {\n    const shapes = this.shapes;\n    const pageState = this.pageState;\n    if (shapes.length === 0)\n      return this;\n    const { rendererBounds } = this;\n    const { zoom } = pageState.camera;\n    const commonBounds = C3.getCommonBounds(shapes.map(TLDR.getBounds));\n    const mx = (rendererBounds.width - commonBounds.width * zoom) / 2 / zoom;\n    const my = (rendererBounds.height - commonBounds.height * zoom) / 2 / zoom;\n    return this.setCamera(e.toFixed(e.sub([mx, my], [commonBounds.minX, commonBounds.minY])), this.camera.zoom, `zoomed_to_content`);\n  };\n  resetZoom = () => {\n    return this.zoomTo(1);\n  };\n  zoomBy = C3.throttle((delta, center) => {\n    const { zoom } = this.camera;\n    const nextZoom = TLDR.getCameraZoom(zoom - delta * zoom);\n    return this.zoomTo(nextZoom, center);\n  }, 16);\n  clearSelectHistory = () => {\n    this.selectHistory.pointer = 0;\n    this.selectHistory.stack = [this.selectedIds];\n    return this;\n  };\n  addToSelectHistory = (ids) => {\n    if (this.selectHistory.pointer < this.selectHistory.stack.length) {\n      this.selectHistory.stack = this.selectHistory.stack.slice(0, this.selectHistory.pointer + 1);\n    }\n    this.selectHistory.pointer++;\n    this.selectHistory.stack.push(ids);\n    return this;\n  };\n  setSelectedIds = (ids, push = false) => {\n    const nextIds = push ? [...this.pageState.selectedIds, ...ids] : [...ids];\n    return this.patchState(\n      {\n        appState: {\n          activeTool: \"select\"\n        },\n        document: {\n          pageStates: {\n            [this.currentPageId]: {\n              selectedIds: nextIds\n            }\n          }\n        }\n      },\n      `selected`\n    );\n  };\n  undoSelect = () => {\n    if (this.selectHistory.pointer > 0) {\n      this.selectHistory.pointer--;\n      this.setSelectedIds(this.selectHistory.stack[this.selectHistory.pointer]);\n    }\n    return this;\n  };\n  redoSelect = () => {\n    if (this.selectHistory.pointer < this.selectHistory.stack.length - 1) {\n      this.selectHistory.pointer++;\n      this.setSelectedIds(this.selectHistory.stack[this.selectHistory.pointer]);\n    }\n    return this;\n  };\n  select = (...ids) => {\n    ids.forEach((id) => {\n      if (!this.page.shapes[id]) {\n        throw new Error(`That shape does not exist on page ${this.currentPageId}`);\n      }\n    });\n    this.setSelectedIds(ids);\n    this.addToSelectHistory(ids);\n    return this;\n  };\n  selectAll = (pageId = this.currentPageId) => {\n    if (this.session)\n      return this;\n    this.setSelectedIds(\n      Object.values(this.document.pages[pageId].shapes).filter((shape) => shape.parentId === pageId).map((shape) => shape.id)\n    );\n    this.addToSelectHistory(this.selectedIds);\n    this.selectTool(\"select\");\n    return this;\n  };\n  selectNone = () => {\n    this.setSelectedIds([]);\n    this.addToSelectHistory(this.selectedIds);\n    return this;\n  };\n  startSession = (type, ...args) => {\n    if (this.readOnly && type !== \"brush\" /* Brush */)\n      return this;\n    if (this.session) {\n      TLDR.warn(`Already in a session! (${this.session.constructor.name})`);\n      this.cancelSession();\n    }\n    const Session = getSession(type);\n    this.session = new Session(this, ...args);\n    const result = this.session.start();\n    if (result) {\n      this.patchState(result, `session:start_${this.session.constructor.name}`);\n    }\n    this.callbacks.onSessionStart?.(this, this.session.constructor.name);\n    return this;\n  };\n  updateSession = () => {\n    const { session } = this;\n    if (!session)\n      return this;\n    const patch = session.update();\n    if (!patch)\n      return this;\n    return this.patchState(patch, `session:${session?.constructor.name}`);\n  };\n  cancelSession = () => {\n    const { session } = this;\n    if (!session)\n      return this;\n    this.session = void 0;\n    const result = session.cancel();\n    if (result) {\n      this.patchState(result, `session:cancel:${session.constructor.name}`);\n    }\n    this.setEditingId();\n    this.callbacks.onSessionEnd?.(this, session.constructor.name);\n    return this;\n  };\n  completeSession = () => {\n    const { session } = this;\n    if (!session)\n      return this;\n    this.session = void 0;\n    const result = session.complete();\n    if (result === void 0) {\n      this.isCreating = false;\n      this.patchState(\n        {\n          appState: {\n            status: \"idle\" /* Idle */\n          },\n          document: {\n            pageStates: {\n              [this.currentPageId]: {\n                editingId: void 0,\n                bindingId: void 0,\n                hoveredId: void 0\n              }\n            }\n          }\n        },\n        `session:complete:${session.constructor.name}`\n      );\n    } else if (\"after\" in result) {\n      if (this.isCreating) {\n        result.before = {\n          appState: {\n            ...result.before.appState,\n            status: \"idle\" /* Idle */\n          },\n          document: {\n            pages: {\n              [this.currentPageId]: {\n                shapes: Object.fromEntries(this.selectedIds.map((id) => [id, void 0]))\n              }\n            },\n            pageStates: {\n              [this.currentPageId]: {\n                selectedIds: [],\n                editingId: null,\n                bindingId: null,\n                hoveredId: null\n              }\n            }\n          }\n        };\n        if (this.appState.isToolLocked) {\n          const pageState = result.after?.document?.pageStates?.[this.currentPageId] || {};\n          pageState.selectedIds = [];\n        }\n        this.isCreating = false;\n      }\n      result.after.appState = {\n        ...result.after.appState,\n        status: \"idle\" /* Idle */\n      };\n      result.after.document = {\n        ...result.after.document,\n        pageStates: {\n          ...result.after.document?.pageStates,\n          [this.currentPageId]: {\n            ...(result.after.document?.pageStates || {})[this.currentPageId],\n            editingId: null\n          }\n        }\n      };\n      this.setState(result, `session:complete:${session.constructor.name}`);\n    } else {\n      this.patchState(\n        {\n          ...result,\n          appState: {\n            ...result.appState,\n            status: \"idle\" /* Idle */\n          },\n          document: {\n            ...result.document,\n            pageStates: {\n              [this.currentPageId]: {\n                ...result.document?.pageStates?.[this.currentPageId],\n                editingId: null\n              }\n            }\n          }\n        },\n        `session:complete:${session.constructor.name}`\n      );\n    }\n    this.callbacks.onSessionEnd?.(this, session.constructor.name);\n    return this;\n  };\n  createShapes = (...shapes) => {\n    if (shapes.length === 0)\n      return this;\n    return this.create(\n      shapes.map((shape) => {\n        return TLDR.getShapeUtil(shape.type).create({\n          parentId: this.currentPageId,\n          ...shape\n        });\n      })\n    );\n  };\n  updateShapes = (...shapes) => {\n    const pageShapes = this.document.pages[this.currentPageId].shapes;\n    const shapesToUpdate = shapes.filter((shape) => pageShapes[shape.id]);\n    if (shapesToUpdate.length === 0)\n      return this;\n    return this.setState(updateShapes(this, shapesToUpdate, this.currentPageId), \"updated_shapes\");\n  };\n  createTextShapeAtPoint(point, id, patch) {\n    const {\n      shapes,\n      appState: { currentPageId, currentStyle }\n    } = this;\n    const childIndex = shapes.length === 0 ? 1 : shapes.filter((shape) => shape.parentId === currentPageId).sort((a7, b6) => b6.childIndex - a7.childIndex)[0].childIndex + 1;\n    const Text2 = shapeUtils[\"text\" /* Text */];\n    const newShape = Text2.create({\n      id: id || C3.uniqueId(),\n      parentId: currentPageId,\n      childIndex,\n      point,\n      style: { ...currentStyle }\n    });\n    const bounds = Text2.getBounds(newShape);\n    newShape.point = e.sub(newShape.point, [bounds.width / 2, bounds.height / 2]);\n    if (patch) {\n      this.patchCreate([TLDR.getShapeUtil(newShape.type).create(newShape)]);\n    } else {\n      this.createShapes(newShape);\n    }\n    this.setEditingId(newShape.id, true);\n    return this;\n  }\n  getImageShapeAtPoint(id, type, point, size, assetId) {\n    const {\n      shapes,\n      appState: { currentPageId, currentStyle }\n    } = this;\n    const childIndex = shapes.length === 0 ? 1 : shapes.filter((shape) => shape.parentId === currentPageId).sort((a7, b6) => b6.childIndex - a7.childIndex)[0].childIndex + 1;\n    const Shape = shapeUtils[type];\n    if (size[0] > this.viewport.width) {\n      const r5 = size[1] / size[0];\n      size[0] = this.viewport.width - FIT_TO_SCREEN_PADDING / this.camera.zoom * 2;\n      size[1] = size[0] * r5;\n      if (size[1] < 32 || size[1] < 32) {\n        size[1] = 32;\n        size[0] = size[1] / r5;\n      }\n    } else if (size[1] > this.viewport.height) {\n      const r5 = size[0] / size[1];\n      size[1] = this.viewport.height - FIT_TO_SCREEN_PADDING / this.camera.zoom * 2;\n      size[0] = size[1] * r5;\n      if (size[1] < 32 || size[1] < 32) {\n        size[0] = 32;\n        size[1] = size[0] / r5;\n      }\n    }\n    const newShape = Shape.create({\n      id,\n      parentId: currentPageId,\n      childIndex,\n      point,\n      size,\n      style: { ...currentStyle },\n      assetId\n    });\n    return newShape;\n  }\n  create = (shapes = [], bindings = []) => {\n    if (shapes.length === 0)\n      return this;\n    return this.setState(createShapes(this, shapes, bindings));\n  };\n  patchCreate = (shapes = [], bindings = []) => {\n    if (shapes.length === 0)\n      return this;\n    return this.patchState(createShapes(this, shapes, bindings).after);\n  };\n  delete = (ids = this.selectedIds) => {\n    if (ids.length === 0)\n      return this;\n    if (this.session)\n      return this;\n    const drawCommand = deleteShapes(this, ids);\n    if (this.callbacks.onAssetDelete && drawCommand.before.document?.assets && drawCommand.after.document?.assets) {\n      const beforeAssetIds = Object.keys(drawCommand.before.document.assets).filter((k6) => !!drawCommand.before.document.assets[k6]);\n      const afterAssetIds = new Set(Object.keys(drawCommand.after.document.assets).filter((k6) => !!drawCommand.after.document.assets[k6]));\n      const intersection = beforeAssetIds.filter((x5) => !afterAssetIds.has(x5));\n      intersection.forEach((id) => this.callbacks.onAssetDelete(this, id));\n    }\n    return this.setState(drawCommand);\n  };\n  deleteAll = () => {\n    this.selectAll();\n    this.delete();\n    return this;\n  };\n  style = (style, ids = this.selectedIds) => {\n    return this.setState(styleShapes(this, ids, style));\n  };\n  align = (type, ids = this.selectedIds) => {\n    if (ids.length < 2)\n      return this;\n    return this.setState(alignShapes(this, ids, type));\n  };\n  distribute = (direction, ids = this.selectedIds) => {\n    if (ids.length < 3)\n      return this;\n    return this.setState(distributeShapes(this, ids, direction));\n  };\n  stretch = (direction, ids = this.selectedIds) => {\n    if (ids.length < 2)\n      return this;\n    return this.setState(stretchShapes(this, ids, direction));\n  };\n  flipHorizontal = (ids = this.selectedIds) => {\n    if (ids.length === 0)\n      return this;\n    return this.setState(flipShapes(this, ids, \"horizontal\" /* Horizontal */));\n  };\n  flipVertical = (ids = this.selectedIds) => {\n    if (ids.length === 0)\n      return this;\n    return this.setState(flipShapes(this, ids, \"vertical\" /* Vertical */));\n  };\n  moveToPage = (toPageId, fromPageId = this.currentPageId, ids = this.selectedIds) => {\n    if (ids.length === 0)\n      return this;\n    const { rendererBounds } = this;\n    this.setState(moveShapesToPage(this, ids, rendererBounds, fromPageId, toPageId));\n    return this;\n  };\n  moveToBack = (ids = this.selectedIds) => {\n    if (ids.length === 0)\n      return this;\n    return this.setState(reorderShapes(this, ids, \"toBack\" /* ToBack */));\n  };\n  moveBackward = (ids = this.selectedIds) => {\n    if (ids.length === 0)\n      return this;\n    return this.setState(reorderShapes(this, ids, \"backward\" /* Backward */));\n  };\n  moveForward = (ids = this.selectedIds) => {\n    if (ids.length === 0)\n      return this;\n    return this.setState(reorderShapes(this, ids, \"forward\" /* Forward */));\n  };\n  moveToFront = (ids = this.selectedIds) => {\n    if (ids.length === 0)\n      return this;\n    return this.setState(reorderShapes(this, ids, \"toFront\" /* ToFront */));\n  };\n  nudge = (delta, isMajor = false, ids = this.selectedIds) => {\n    if (ids.length === 0)\n      return this;\n    const size = isMajor ? this.settings.showGrid ? this.currentGrid * 4 : 10 : this.settings.showGrid ? this.currentGrid : 1;\n    return this.setState(translateShapes(this, ids, e.mul(delta, size)));\n  };\n  duplicate = (ids = this.selectedIds, point) => {\n    if (this.readOnly)\n      return this;\n    if (ids.length === 0)\n      return this;\n    return this.setState(duplicateShapes(this, ids, point));\n  };\n  resetBounds = (ids = this.selectedIds) => {\n    const command = resetBounds(this, ids, this.currentPageId);\n    return this.setState(resetBounds(this, ids, this.currentPageId), command.id);\n  };\n  toggleHidden = (ids = this.selectedIds) => {\n    if (ids.length === 0)\n      return this;\n    return this.setState(toggleShapeProp(this, ids, \"isHidden\"));\n  };\n  toggleLocked = (ids = this.selectedIds) => {\n    if (ids.length === 0)\n      return this;\n    return this.setState(toggleShapeProp(this, ids, \"isLocked\"));\n  };\n  toggleAspectRatioLocked = (ids = this.selectedIds) => {\n    if (ids.length === 0)\n      return this;\n    return this.setState(toggleShapeProp(this, ids, \"isAspectRatioLocked\"));\n  };\n  toggleDecoration = (handleId, ids = this.selectedIds) => {\n    if (ids.length === 0 || !(handleId === \"start\" || handleId === \"end\"))\n      return this;\n    return this.setState(toggleShapesDecoration(this, ids, handleId));\n  };\n  setShapeProps = (props, ids = this.selectedIds) => {\n    return this.setState(setShapesProps(this, ids, props));\n  };\n  rotate = (delta = Math.PI * -0.5, ids = this.selectedIds) => {\n    if (ids.length === 0)\n      return this;\n    const change = rotateShapes(this, ids, delta);\n    if (!change)\n      return this;\n    return this.setState(change);\n  };\n  group = (ids = this.selectedIds, groupId = C3.uniqueId(), pageId = this.currentPageId) => {\n    if (this.readOnly)\n      return this;\n    if (ids.length === 1 && this.getShape(ids[0], pageId).type === \"group\" /* Group */) {\n      return this.ungroup(ids, pageId);\n    }\n    if (ids.length < 2)\n      return this;\n    const command = groupShapes(this, ids, groupId, pageId);\n    if (!command)\n      return this;\n    return this.setState(command);\n  };\n  ungroup = (ids = this.selectedIds, pageId = this.currentPageId) => {\n    if (this.readOnly)\n      return this;\n    const groups = ids.map((id) => this.getShape(id, pageId)).filter((shape) => shape.type === \"group\" /* Group */);\n    if (groups.length === 0)\n      return this;\n    const command = ungroupShapes(this, ids, groups, pageId);\n    if (!command) {\n      return this;\n    }\n    return this.setState(command);\n  };\n  cancel = () => {\n    this.currentTool.onCancel?.();\n    return this;\n  };\n  addMediaFromFiles = async (files, point = this.centerPoint) => {\n    this.setIsLoading(true);\n    const shapesToCreate = [];\n    const pagePoint = this.getPagePoint(point);\n    for (const file of files) {\n      const id = C3.uniqueId();\n      const extension = file.name.match(/\\.[\\da-z]+$/i);\n      if (!extension)\n        throw new Error(\"No extension\");\n      const isImage = IMAGE_EXTENSIONS.includes(extension[0].toLowerCase());\n      if (!isImage)\n        throw new Error(\"Wrong extension\");\n      const shapeType = \"image\" /* Image */;\n      const assetType = \"image\" /* Image */;\n      let src;\n      try {\n        if (this.callbacks.onAssetCreate) {\n          const result = await this.callbacks.onAssetCreate(this, file, id);\n          if (!result)\n            throw new Error(\"Asset creation callback returned false\");\n          src = result;\n        } else {\n          src = await fileToBase64(file);\n        }\n        if (typeof src === \"string\") {\n          let size = [0, 0];\n          if (isImage) {\n            if (extension[0] == \".svg\") {\n              let viewBox;\n              const svgString = await fileToText(file);\n              const viewBoxAttribute = this.getViewboxFromSVG(svgString);\n              if (viewBoxAttribute) {\n                viewBox = viewBoxAttribute.split(\" \");\n                size[0] = Number.parseFloat(viewBox[2]);\n                size[1] = Number.parseFloat(viewBox[3]);\n              }\n            }\n            if (e.isEqual(size, [0, 0])) {\n              size = await getImageSizeFromSrc(src);\n            }\n          }\n          const match = Object.values(this.document.assets).find((asset) => asset.type === assetType && asset.src === src);\n          let assetId;\n          if (match) {\n            assetId = match.id;\n          } else {\n            assetId = id;\n            const asset = {\n              id: assetId,\n              type: assetType,\n              name: file.name,\n              src,\n              size\n            };\n            this.patchState({\n              document: {\n                assets: {\n                  [assetId]: asset\n                }\n              }\n            });\n          }\n          shapesToCreate.push(this.getImageShapeAtPoint(id, shapeType, point, size, assetId));\n        }\n      } catch (error) {\n        console.warn(error);\n      }\n    }\n    if (shapesToCreate.length > 0) {\n      const currentPoint = e.add(pagePoint, [0, 0]);\n      shapesToCreate.forEach((shape, i4) => {\n        const bounds = TLDR.getBounds(shape);\n        if (i4 === 0) {\n          currentPoint[0] -= bounds.width / 2;\n          currentPoint[1] -= bounds.height / 2;\n        }\n        shape.point = [...currentPoint];\n        currentPoint[0] += bounds.width;\n      });\n      const commonBounds = C3.getCommonBounds(shapesToCreate.map(TLDR.getBounds));\n      this.createShapes(...shapesToCreate);\n      if (!C3.boundsContain(this.viewport, commonBounds)) {\n        this.zoomToSelection();\n        if (this.zoom > 1) {\n          this.resetZoom();\n        }\n      }\n    }\n    this.setIsLoading(false);\n    return this;\n  };\n  getViewboxFromSVG = (svgStr) => {\n    const viewBoxRegex = /.*?viewBox=[\"'](-?[\\d.]+[ ,]+-?(?:[\\d.]+[ ,]){2}[\\d.]+)[\"']/;\n    if (typeof svgStr === \"string\") {\n      const matches = svgStr.match(viewBoxRegex);\n      return matches && matches.length >= 2 ? matches[1] : null;\n    }\n    this.setIsLoading(false);\n    return null;\n  };\n  onKeyDown = (key, info, e5) => {\n    switch (e5.key) {\n      case \"/\": {\n        if (this.status === \"idle\" && !this.pageState.editingId) {\n          const { shiftKey, metaKey, altKey, ctrlKey, spaceKey } = this;\n          this.onPointerDown(\n            {\n              target: \"canvas\",\n              pointerId: 0,\n              origin: info.point,\n              point: info.point,\n              delta: [0, 0],\n              pressure: 0.5,\n              shiftKey,\n              ctrlKey,\n              metaKey,\n              altKey,\n              spaceKey\n            },\n            {\n              shiftKey,\n              altKey,\n              ctrlKey,\n              pointerId: 0,\n              clientX: info.point[0],\n              clientY: info.point[1]\n            }\n          );\n        }\n        break;\n      }\n      case \"Escape\": {\n        this.cancel();\n        break;\n      }\n      case \"Meta\": {\n        this.metaKey = true;\n        break;\n      }\n      case \"Alt\": {\n        this.altKey = true;\n        break;\n      }\n      case \"Control\": {\n        this.ctrlKey = true;\n        break;\n      }\n      case \" \": {\n        this.isForcePanning = true;\n        this.spaceKey = true;\n        break;\n      }\n    }\n    this.currentTool.onKeyDown?.(key, info, e5);\n    return this;\n  };\n  onKeyUp = (key, info, e5) => {\n    if (!info)\n      return;\n    switch (e5.key) {\n      case \"/\": {\n        const { currentPoint, shiftKey, metaKey, altKey, ctrlKey, spaceKey } = this;\n        this.onPointerUp(\n          {\n            target: \"canvas\",\n            pointerId: 0,\n            origin: currentPoint,\n            point: currentPoint,\n            delta: [0, 0],\n            pressure: 0.5,\n            shiftKey,\n            ctrlKey,\n            metaKey,\n            altKey,\n            spaceKey\n          },\n          {\n            shiftKey,\n            altKey,\n            ctrlKey,\n            pointerId: 0,\n            clientX: currentPoint[0],\n            clientY: currentPoint[1]\n          }\n        );\n        break;\n      }\n      case \"Meta\": {\n        this.metaKey = false;\n        break;\n      }\n      case \"Alt\": {\n        this.altKey = false;\n        break;\n      }\n      case \"Control\": {\n        this.ctrlKey = false;\n        break;\n      }\n      case \" \": {\n        this.isForcePanning = false;\n        this.spaceKey = false;\n        break;\n      }\n    }\n    this.currentTool.onKeyUp?.(key, info, e5);\n  };\n  refreshBoundingBoxes = () => {\n    const force = this.shapes.map((shape) => {\n      return [\n        shape.id,\n        {\n          point: [...shape.point],\n          ...\"label\" in shape && { label: \"\" }\n        }\n      ];\n    });\n    const restore = this.shapes.map((shape) => {\n      return [\n        shape.id,\n        {\n          point: [...shape.point],\n          ...\"label\" in shape && { label: shape.label }\n        }\n      ];\n    });\n    clearPrevSize();\n    this.patchState({\n      document: {\n        pages: {\n          [this.currentPageId]: {\n            shapes: Object.fromEntries(force)\n          }\n        }\n      }\n    });\n    this.patchState({\n      document: {\n        pages: {\n          [this.currentPageId]: {\n            shapes: Object.fromEntries(restore)\n          }\n        }\n      }\n    });\n  };\n  onDragOver = (e5) => {\n    e5.preventDefault();\n  };\n  onDrop = async (e5) => {\n    e5.preventDefault();\n    if (this.disableAssets)\n      return this;\n    if (e5.dataTransfer.files?.length) {\n      this.addMediaFromFiles(Object.values(e5.dataTransfer.files), [e5.clientX, e5.clientY]);\n    }\n    return this;\n  };\n  onPinchStart = (info, e5) => {\n    this.currentTool.onPinchStart?.(info, e5);\n  };\n  onPinchEnd = (info, e5) => this.currentTool.onPinchEnd?.(info, e5);\n  onPinch = (info, e5) => this.currentTool.onPinch?.(info, e5);\n  onPan = (info, e5) => {\n    if (this.appState.status === \"pinching\")\n      return;\n    const delta = e.div(info.delta, this.camera.zoom);\n    const prev = this.camera.point;\n    const next = e.sub(prev, delta);\n    if (e.isEqual(next, prev))\n      return;\n    this.pan(delta);\n    if (!this.isForcePanning)\n      this.onPointerMove(info, e5);\n    if (isLinux && this.isForcePanning)\n      this.preventPaste();\n  };\n  onZoom = (info, e5) => {\n    if (this.state.appState.status !== \"idle\" /* Idle */)\n      return;\n    const delta = info.delta[2] / 50;\n    this.zoomBy(delta, info.point);\n    this.onPointerMove(info, e5);\n  };\n  updateInputs = (info) => {\n    this.currentPoint = this.getPagePoint(info.point).concat(info.pressure);\n    this.shiftKey = info.shiftKey;\n    this.altKey = info.altKey;\n    this.ctrlKey = info.ctrlKey;\n    this.metaKey = info.metaKey;\n  };\n  onPointerMove = (info, e5) => {\n    this.previousPoint = this.currentPoint;\n    this.updateInputs(info, e5);\n    if (this.isForcePanning && this.isPointing) {\n      this.onPan?.({ ...info, delta: e.neg(info.delta) }, e5);\n      return;\n    }\n    this.currentTool.onPointerMove?.(info, e5);\n  };\n  onPointerDown = (info, e5) => {\n    if (e5.buttons === 4) {\n      this.isForcePanning = true;\n    } else if (this.isPointing) {\n      return;\n    }\n    this.isPointing = true;\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);\n    this.updateInputs(info, e5);\n    if (this.isForcePanning)\n      return;\n    if (this.currentTool.type === \"draw\" /* Draw */ && e5.pointerType === \"pen\" && e5.button === 5) {\n      this.selectTool(\"erase\");\n      this.isErasingWithPen = true;\n    }\n    this.currentTool.onPointerDown?.(info, e5);\n  };\n  onPointerUp = (info, e5) => {\n    this.isPointing = false;\n    if (!this.shiftKey)\n      this.isForcePanning = false;\n    this.updateInputs(info, e5);\n    this.currentTool.onPointerUp?.(info, e5);\n    if (this.isErasingWithPen && e5.pointerType === \"pen\" && e5.button === 5) {\n      this.selectTool(\"draw\" /* Draw */);\n      this.isErasingWithPen = false;\n    }\n  };\n  onPointCanvas = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onPointCanvas?.(info, e5);\n  };\n  onDoubleClickCanvas = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onDoubleClickCanvas?.(info, e5);\n  };\n  onRightPointCanvas = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onRightPointCanvas?.(info, e5);\n  };\n  onDragCanvas = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onDragCanvas?.(info, e5);\n  };\n  onReleaseCanvas = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onReleaseCanvas?.(info, e5);\n  };\n  onPointShape = (info, e5) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);\n    this.updateInputs(info, e5);\n    this.currentTool.onPointShape?.(info, e5);\n  };\n  onReleaseShape = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onReleaseShape?.(info, e5);\n  };\n  onDoubleClickShape = (info, e5) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);\n    this.updateInputs(info, e5);\n    this.currentTool.onDoubleClickShape?.(info, e5);\n  };\n  onRightPointShape = (info, e5) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);\n    this.updateInputs(info, e5);\n    this.currentTool.onRightPointShape?.(info, e5);\n  };\n  onDragShape = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onDragShape?.(info, e5);\n  };\n  onHoverShape = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onHoverShape?.(info, e5);\n  };\n  onUnhoverShape = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onUnhoverShape?.(info, e5);\n  };\n  onPointBounds = (info, e5) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);\n    this.updateInputs(info, e5);\n    this.currentTool.onPointBounds?.(info, e5);\n  };\n  onDoubleClickBounds = (info, e5) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);\n    this.updateInputs(info, e5);\n    this.currentTool.onDoubleClickBounds?.(info, e5);\n  };\n  onRightPointBounds = (info, e5) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);\n    this.updateInputs(info, e5);\n    this.currentTool.onRightPointBounds?.(info, e5);\n  };\n  onDragBounds = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onDragBounds?.(info, e5);\n  };\n  onHoverBounds = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onHoverBounds?.(info, e5);\n  };\n  onUnhoverBounds = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onUnhoverBounds?.(info, e5);\n  };\n  onReleaseBounds = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onReleaseBounds?.(info, e5);\n  };\n  onPointBoundsHandle = (info, e5) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);\n    this.updateInputs(info, e5);\n    this.currentTool.onPointBoundsHandle?.(info, e5);\n  };\n  onDoubleClickBoundsHandle = (info, e5) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);\n    this.updateInputs(info, e5);\n    this.currentTool.onDoubleClickBoundsHandle?.(info, e5);\n    if (this.selectedIds.length !== 1)\n      return;\n    const shape = this.getShape(this.selectedIds[0]);\n    if (shape.type === \"image\" /* Image */) {\n      const asset = this.document.assets[shape.assetId];\n      const util = TLDR.getShapeUtil(shape);\n      const centerA = util.getCenter(shape);\n      const centerB = util.getCenter({ ...shape, size: asset.size });\n      const delta = e.sub(centerB, centerA);\n      this.updateShapes({\n        id: shape.id,\n        point: e.sub(shape.point, delta),\n        size: asset.size\n      });\n    }\n  };\n  onRightPointBoundsHandle = (info, e5) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);\n    this.updateInputs(info, e5);\n    this.currentTool.onRightPointBoundsHandle?.(info, e5);\n  };\n  onDragBoundsHandle = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onDragBoundsHandle?.(info, e5);\n  };\n  onHoverBoundsHandle = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onHoverBoundsHandle?.(info, e5);\n  };\n  onUnhoverBoundsHandle = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onUnhoverBoundsHandle?.(info, e5);\n  };\n  onReleaseBoundsHandle = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onReleaseBoundsHandle?.(info, e5);\n  };\n  onPointHandle = (info, e5) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);\n    this.updateInputs(info, e5);\n    this.currentTool.onPointHandle?.(info, e5);\n  };\n  onDoubleClickHandle = (info, e5) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);\n    this.updateInputs(info, e5);\n    this.currentTool.onDoubleClickHandle?.(info, e5);\n  };\n  onRightPointHandle = (info, e5) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);\n    this.updateInputs(info, e5);\n    this.currentTool.onRightPointHandle?.(info, e5);\n  };\n  onDragHandle = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onDragHandle?.(info, e5);\n  };\n  onHoverHandle = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onHoverHandle?.(info, e5);\n  };\n  onUnhoverHandle = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onUnhoverHandle?.(info, e5);\n  };\n  onReleaseHandle = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onReleaseHandle?.(info, e5);\n  };\n  onShapeChange = (shape) => {\n    const pageShapes = this.document.pages[this.currentPageId].shapes;\n    const shapeToUpdate = { ...pageShapes[shape.id], ...shape };\n    const patch = updateShapes(this, [shapeToUpdate], this.currentPageId).after;\n    return this.patchState(patch, \"patched_shapes\");\n  };\n  onShapeBlur = () => {\n    if (performance.now() - this.editingStartTime < 50)\n      return;\n    const { editingId } = this.pageState;\n    const { isToolLocked } = this.getAppState();\n    if (editingId) {\n      const shape = this.getShape(editingId);\n      this.setEditingId();\n      if (shape.type === \"text\" /* Text */) {\n        if (shape.text.trim().length <= 0) {\n          this.patchState(deleteShapes(this, [editingId]).after, \"delete_empty_text\");\n        } else if (!isToolLocked) {\n          this.select(editingId);\n        }\n      }\n    }\n    this.currentTool.onShapeBlur?.();\n  };\n  onShapeClone = (info, e5) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);\n    this.updateInputs(info, e5);\n    this.currentTool.onShapeClone?.(info, e5);\n  };\n  onRenderCountChange = (ids) => {\n    const appState = this.getAppState();\n    if (appState.isEmptyCanvas && ids.length > 0) {\n      this.patchState(\n        {\n          appState: {\n            isEmptyCanvas: false\n          }\n        },\n        \"empty_canvas:false\"\n      );\n    } else if (!appState.isEmptyCanvas && ids.length <= 0) {\n      this.patchState(\n        {\n          appState: {\n            isEmptyCanvas: true\n          }\n        },\n        \"empty_canvas:true\"\n      );\n    }\n  };\n  onError = () => {\n  };\n  isSelected(id) {\n    return this.selectedIds.includes(id);\n  }\n  serializeImage(id) {\n    const image = document.getElementById(id + \"_image\");\n    if (image) {\n      const canvas = document.createElement(\"canvas\");\n      canvas.width = image.width;\n      canvas.height = image.height;\n      canvas.getContext(\"2d\").drawImage(image, 0, 0);\n      return canvas.toDataURL(\"image/png\");\n    } else\n      throw new Error(\"Image with id \" + id + \" not found\");\n  }\n  patchAssets(assets) {\n    this.document.assets = {\n      ...this.document.assets,\n      ...assets\n    };\n  }\n  get status() {\n    return this.appState.status;\n  }\n  get centerPoint() {\n    const { width, height } = this.rendererBounds;\n    return e.toFixed([width / 2, height / 2]);\n  }\n  get currentGrid() {\n    const { zoom } = this.camera;\n    if (zoom < 0.15) {\n      return GRID_SIZE * 16;\n    } else if (zoom < 1) {\n      return GRID_SIZE * 4;\n    } else {\n      return GRID_SIZE * 1;\n    }\n  }\n  getShapeUtil = TLDR.getShapeUtil;\n};\nvar TldrawApp = _TldrawApp;\n__publicField(TldrawApp, \"version\", 15.5);\n__publicField(TldrawApp, \"defaultDocument\", {\n  id: \"doc\",\n  name: \"New Document\",\n  version: _TldrawApp.version,\n  pages: {\n    page: {\n      id: \"page\",\n      name: \"Page 1\",\n      childIndex: 1,\n      shapes: {},\n      bindings: {}\n    }\n  },\n  pageStates: {\n    page: {\n      id: \"page\",\n      selectedIds: [],\n      camera: {\n        point: [0, 0],\n        zoom: 1\n      }\n    }\n  },\n  assets: {}\n});\n__publicField(TldrawApp, \"defaultState\", {\n  settings: {\n    isCadSelectMode: false,\n    isPenMode: false,\n    isZoomSnap: false,\n    isFocusMode: false,\n    isSnapping: false,\n    isDebugMode: false,\n    isReadonlyMode: false,\n    keepStyleMenuOpen: false,\n    nudgeDistanceLarge: 16,\n    nudgeDistanceSmall: 1,\n    showRotateHandles: true,\n    showBindingHandles: true,\n    showCloneHandles: false,\n    showGrid: false,\n    language: \"en\",\n    dockPosition: \"bottom\",\n    exportBackground: \"transparent\" /* Transparent */\n  },\n  appState: {\n    activeTool: \"select\",\n    currentPageId: \"page\",\n    currentStyle: defaultStyle,\n    disableAssets: false,\n    eraseLine: [],\n    hoveredId: void 0,\n    isEmptyCanvas: false,\n    isLoading: false,\n    isMenuOpen: false,\n    isToolLocked: false,\n    mouseInBound: false,\n    snapLines: [],\n    status: \"idle\" /* Idle */\n  },\n  document: _TldrawApp.defaultDocument\n});\n__publicField(TldrawApp, \"assetSrc\", \"tldraw-assets.json\");\n\n// src/components/Tldraw/state/tools/index.ts\nvar tools = {\n  select: SelectTool,\n  erase: EraseTool,\n  [\"text\" /* Text */]: TextTool,\n  [\"draw\" /* Draw */]: DrawTool,\n  [\"ellipse\" /* Ellipse */]: EllipseTool,\n  [\"rectangle\" /* Rectangle */]: RectangleTool,\n  [\"triangle\" /* Triangle */]: TriangleTool,\n  [\"line\" /* Line */]: LineTool,\n  [\"arrow\" /* Arrow */]: ArrowTool,\n  [\"sticky\" /* Sticky */]: StickyTool\n};\n\n// src/components/Tldraw/Tldraw.tsx\nvar import_jsx_runtime66 = require(\"react/jsx-runtime\");\nfunction Tldraw({\n  id,\n  document: document2,\n  currentPageId,\n  autofocus = true,\n  showMenu = true,\n  showPages = true,\n  showTools = true,\n  showZoom = true,\n  showStyles = true,\n  showUI = true,\n  readOnly = false,\n  disableAssets = false,\n  components,\n  onMount,\n  onChange,\n  onOpenMedia,\n  onUndo,\n  onRedo,\n  onPersist,\n  onPatch,\n  onCommand,\n  onChangePage,\n  onAssetCreate,\n  onAssetDelete,\n  onAssetUpload,\n  onSessionStart,\n  onSessionEnd,\n  onExport,\n  hideCursors\n}) {\n  const [sId, setSId] = React49.useState(id);\n  const [app, setApp] = React49.useState(() => {\n    const app2 = new TldrawApp(id, {\n      onMount,\n      onChange,\n      onOpenMedia,\n      onUndo,\n      onRedo,\n      onPersist,\n      onPatch,\n      onCommand,\n      onChangePage,\n      onAssetDelete,\n      onAssetCreate,\n      onAssetUpload,\n      onSessionStart,\n      onSessionEnd\n    });\n    return app2;\n  });\n  const [onCancel, setOnCancel] = React49.useState(null);\n  const [onYes, setOnYes] = React49.useState(null);\n  const [onNo, setOnNo] = React49.useState(null);\n  const [dialogState, setDialogState] = React49.useState(null);\n  const openDialog = React49.useCallback((dialogState2, onYes2, onNo2, onCancel2) => {\n    setDialogState(() => dialogState2);\n    setOnCancel(() => onCancel2);\n    setOnYes(() => onYes2);\n    setOnNo(() => onNo2);\n  }, []);\n  React49.useLayoutEffect(() => {\n    if (id === sId)\n      return;\n    const newApp = new TldrawApp(id, {\n      onMount,\n      onChange,\n      onOpenMedia,\n      onUndo,\n      onRedo,\n      onPersist,\n      onPatch,\n      onCommand,\n      onChangePage,\n      onAssetDelete,\n      onAssetCreate,\n      onAssetUpload,\n      onExport,\n      onSessionStart,\n      onSessionEnd\n    });\n    setSId(id);\n    setApp(newApp);\n  }, [sId, id]);\n  React49.useEffect(() => {\n    if (document2 == void 0)\n      return;\n    if (document2.id === app.document.id) {\n      app.updateDocument(document2);\n    } else {\n      app.loadDocument(document2);\n    }\n  }, [document2, app]);\n  React49.useEffect(() => {\n    app.setDisableAssets(disableAssets);\n  }, [app, disableAssets]);\n  React49.useEffect(() => {\n    if (!currentPageId)\n      return;\n    app.changePage(currentPageId);\n  }, [currentPageId, app]);\n  React49.useEffect(() => {\n    app.readOnly = readOnly;\n    if (!readOnly) {\n      app.selectNone();\n      app.cancelSession();\n      app.setEditingId();\n    }\n  }, [app, readOnly]);\n  React49.useEffect(() => {\n    app.callbacks = {\n      onMount,\n      onChange,\n      onOpenMedia,\n      onUndo,\n      onRedo,\n      onPersist,\n      onPatch,\n      onCommand,\n      onChangePage,\n      onAssetDelete,\n      onAssetCreate,\n      onAssetUpload,\n      onExport,\n      onSessionStart,\n      onSessionEnd\n    };\n  }, [\n    onMount,\n    onChange,\n    onOpenMedia,\n    onUndo,\n    onRedo,\n    onPersist,\n    onPatch,\n    onCommand,\n    onChangePage,\n    onAssetDelete,\n    onAssetCreate,\n    onAssetUpload,\n    onExport,\n    onSessionStart,\n    onSessionEnd\n  ]);\n  React49.useLayoutEffect(() => {\n    if (typeof window === \"undefined\")\n      return;\n    if (!window.document?.fonts)\n      return;\n    function refreshBoundingBoxes() {\n      app.refreshBoundingBoxes();\n    }\n    window.document.fonts.addEventListener(\"loadingdone\", refreshBoundingBoxes);\n    return () => {\n      window.document.fonts.removeEventListener(\"loadingdone\", refreshBoundingBoxes);\n    };\n  }, [app]);\n  return /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(TldrawContext.Provider, { value: app, children: /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(AlertDialogContext.Provider, { value: { onYes, onCancel, onNo, dialogState, setDialogState, openDialog }, children: /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(\n    InnerTldraw,\n    {\n      id: sId,\n      autofocus,\n      showPages,\n      showMenu,\n      showStyles,\n      showZoom,\n      showTools,\n      showUI,\n      readOnly,\n      components,\n      hideCursors\n    },\n    sId || \"Tldraw\"\n  ) }) });\n}\nvar InnerTldraw = React49.memo(function InnerTldraw2({\n  id,\n  autofocus,\n  showPages,\n  showMenu,\n  showZoom,\n  showStyles,\n  showTools,\n  readOnly,\n  showUI,\n  components,\n  hideCursors\n}) {\n  const app = useTldrawApp();\n  const [dialogContainer, setDialogContainer] = React49.useState(null);\n  const rWrapper = React49.useRef(null);\n  const state = app.useStore();\n  const { document: document2, settings, appState } = state;\n  const isSelecting = state.appState.activeTool === \"select\";\n  const page = document2.pages[appState.currentPageId];\n  const pageState = document2.pageStates[page.id];\n  const assets = document2.assets;\n  const { selectedIds } = pageState;\n  const isHideBoundsShape = selectedIds.length === 1 && page.shapes[selectedIds[0]] && TLDR.getShapeUtil(page.shapes[selectedIds[0]].type).hideBounds;\n  const isHideResizeHandlesShape = selectedIds.length === 1 && page.shapes[selectedIds[0]] && TLDR.getShapeUtil(page.shapes[selectedIds[0]].type).hideResizeHandles;\n  const showDashedBrush = settings.isCadSelectMode ? !appState.selectByContain : appState.selectByContain;\n  const theme = React49.useMemo(() => {\n    const { selectByContain } = appState;\n    const { isCadSelectMode } = settings;\n    const brushBase = isCadSelectMode ? selectByContain ? \"0, 89, 242\" : \"51, 163, 23\" : \"0,0,0\";\n    return {\n      brushFill: `rgba(${brushBase}, ${isCadSelectMode ? 0.08 : 0.05})`,\n      brushStroke: `rgba(${brushBase}, ${isCadSelectMode ? 0.4 : 0.25})`,\n      brushDashStroke: `rgba(${brushBase}, .6)`\n    };\n  }, [settings.isCadSelectMode, appState.selectByContain]);\n  const isInSession = app.session !== void 0;\n  const hideBounds = isInSession && app.session?.constructor.name !== \"BrushSession\" || !isSelecting || isHideBoundsShape || !!pageState.editingId;\n  const hideHandles = isInSession || !isSelecting;\n  const hideIndicators = isInSession && state.appState.status !== \"brushing\" /* Brushing */ || !isSelecting;\n  const hideCloneHandles = isInSession || !isSelecting || pageState.camera.zoom < 0.2;\n  useCursor(rWrapper);\n  const onMouseEnter = React49.useCallback(() => {\n    app.setMouseInBound(true);\n  }, [app]);\n  const onMouseLeave = React49.useCallback(() => {\n    app.setMouseInBound(false);\n  }, [app]);\n  return /* @__PURE__ */ (0, import_jsx_runtime66.jsxs)(ContainerContext.Provider, { value: rWrapper, children: [\n    /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(AlertDialog, { container: dialogContainer }),\n    /* @__PURE__ */ (0, import_jsx_runtime66.jsxs)(StyledLayout, { ref: rWrapper, tabIndex: -1, onMouseEnter, onMouseLeave, children: [\n      /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(Loading, {}),\n      /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(OneOff, { focusableRef: rWrapper, autofocus }),\n      /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(ContextMenu, { children: /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(\n        ks,\n        {\n          id,\n          containerRef: rWrapper,\n          shapeUtils,\n          page,\n          pageState,\n          assets,\n          snapLines: appState.snapLines,\n          eraseLine: appState.eraseLine,\n          grid: GRID_SIZE,\n          theme,\n          components,\n          hideCursors,\n          hideBounds,\n          hideHandles,\n          hideResizeHandles: isHideResizeHandlesShape,\n          hideIndicators,\n          hideBindingHandles: !settings.showBindingHandles,\n          hideCloneHandles,\n          hideRotateHandles: !settings.showRotateHandles,\n          hideGrid: !settings.showGrid,\n          showDashedBrush,\n          performanceMode: app.session?.performanceMode,\n          onPinchStart: app.onPinchStart,\n          onPinchEnd: app.onPinchEnd,\n          onPinch: app.onPinch,\n          onPan: app.onPan,\n          onZoom: app.onZoom,\n          onPointerDown: app.onPointerDown,\n          onPointerMove: app.onPointerMove,\n          onPointerUp: app.onPointerUp,\n          onPointCanvas: app.onPointCanvas,\n          onDoubleClickCanvas: app.onDoubleClickCanvas,\n          onRightPointCanvas: app.onRightPointCanvas,\n          onDragCanvas: app.onDragCanvas,\n          onReleaseCanvas: app.onReleaseCanvas,\n          onPointShape: app.onPointShape,\n          onDoubleClickShape: app.onDoubleClickShape,\n          onRightPointShape: app.onRightPointShape,\n          onDragShape: app.onDragShape,\n          onHoverShape: app.onHoverShape,\n          onUnhoverShape: app.onUnhoverShape,\n          onReleaseShape: app.onReleaseShape,\n          onPointBounds: app.onPointBounds,\n          onDoubleClickBounds: app.onDoubleClickBounds,\n          onRightPointBounds: app.onRightPointBounds,\n          onDragBounds: app.onDragBounds,\n          onHoverBounds: app.onHoverBounds,\n          onUnhoverBounds: app.onUnhoverBounds,\n          onReleaseBounds: app.onReleaseBounds,\n          onPointBoundsHandle: app.onPointBoundsHandle,\n          onDoubleClickBoundsHandle: app.onDoubleClickBoundsHandle,\n          onRightPointBoundsHandle: app.onRightPointBoundsHandle,\n          onDragBoundsHandle: app.onDragBoundsHandle,\n          onHoverBoundsHandle: app.onHoverBoundsHandle,\n          onUnhoverBoundsHandle: app.onUnhoverBoundsHandle,\n          onReleaseBoundsHandle: app.onReleaseBoundsHandle,\n          onPointHandle: app.onPointHandle,\n          onDoubleClickHandle: app.onDoubleClickHandle,\n          onRightPointHandle: app.onRightPointHandle,\n          onDragHandle: app.onDragHandle,\n          onHoverHandle: app.onHoverHandle,\n          onUnhoverHandle: app.onUnhoverHandle,\n          onReleaseHandle: app.onReleaseHandle,\n          onError: app.onError,\n          onRenderCountChange: app.onRenderCountChange,\n          onShapeChange: app.onShapeChange,\n          onShapeBlur: app.onShapeBlur,\n          onShapeClone: app.onShapeClone,\n          onBoundsChange: app.updateBounds,\n          onKeyDown: app.onKeyDown,\n          onKeyUp: app.onKeyUp,\n          onDragOver: app.onDragOver,\n          onDrop: app.onDrop\n        }\n      ) }),\n      showUI && /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(StyledUI, { ref: setDialogContainer, children: settings.isFocusMode ? /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(FocusButton, { onSelect: app.toggleFocusMode }) : /* @__PURE__ */ (0, import_jsx_runtime66.jsxs)(import_jsx_runtime66.Fragment, { children: [\n        /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(TopPanel, { readOnly, showPages, showMenu, showStyles, showZoom }),\n        /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(StyledSpacer2, {}),\n        showTools && !readOnly && /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(ToolsPanel, {})\n      ] }) })\n    ] })\n  ] });\n});\nvar OneOff = React49.memo(function OneOff2({ focusableRef, autofocus }) {\n  useKeyboardShortcuts(focusableRef);\n  React49.useEffect(() => {\n    if (autofocus) {\n      focusableRef.current?.focus();\n    }\n  }, [autofocus]);\n  return null;\n});\nvar StyledLayout = styled(\"div\", {\n  position: \"absolute\",\n  height: \"100%\",\n  width: \"100%\",\n  minHeight: 0,\n  minWidth: 0,\n  maxHeight: \"100%\",\n  maxWidth: \"100%\",\n  overflow: \"hidden\",\n  boxSizing: \"border-box\",\n  outline: \"none\",\n  \"& .tl-container\": {\n    position: \"absolute\",\n    top: 0,\n    left: 0,\n    height: \"100%\",\n    width: \"100%\",\n    zIndex: 1\n  },\n  \"& input, textarea, button, select, label, button\": {\n    webkitTouchCallout: \"none\",\n    webkitUserSelect: \"none\",\n    \"-webkit-tap-highlight-color\": \"transparent\",\n    \"tap-highlight-color\": \"transparent\"\n  }\n});\nvar StyledUI = styled(\"div\", {\n  position: \"absolute\",\n  top: 0,\n  left: 0,\n  height: \"100%\",\n  width: \"100%\",\n  padding: \"8px 8px 0 8px\",\n  display: \"flex\",\n  alignItems: \"flex-start\",\n  justifyContent: \"flex-start\",\n  pointerEvents: \"none\",\n  zIndex: 2,\n  \"& > *\": {\n    pointerEvents: \"all\"\n  }\n});\nvar StyledSpacer2 = styled(\"div\", {\n  flexGrow: 2\n});\n\n// src/components/App.tsx\nvar import_tw_react2 = __toESM(require_tw_react());\nvar import_jsx_runtime67 = require(\"react/jsx-runtime\");\nvar debounceSaveTime = 500;\nfunction App(props) {\n  const {\n    height,\n    width,\n    currentTiddler,\n    initialTiddlerText,\n    isDraft,\n    readonly,\n    saver: { onSave, lock },\n    parentWidget\n  } = props;\n  const updatedCountReference = (0, import_react42.useRef)(0);\n  const getTiddlerJSONContent = (0, import_react42.useCallback)(() => {\n    if (initialTiddlerText) {\n      try {\n        const data = JSON.parse(initialTiddlerText);\n        updatedCountReference.current = data.updatedCount ?? 0;\n        return data.document;\n      } catch (error) {\n        console.error(`$:/plugins/linonetwo/tw-whiteboard load tiddler ${currentTiddler} failed, text:\n${initialTiddlerText}\n${error.message}`);\n      }\n    }\n  }, [initialTiddlerText, currentTiddler]);\n  const initialTiddlerJSONContent = (0, import_react42.useMemo)(getTiddlerJSONContent, []);\n  (0, import_react42.useEffect)(() => {\n    const latestUpdatedDocument = getTiddlerJSONContent();\n    if (latestUpdatedDocument !== void 0) {\n      tldrawDocumentSetter(latestUpdatedDocument);\n    }\n  }, [getTiddlerJSONContent]);\n  const [tldrawDocument, tldrawDocumentSetterRaw] = (0, import_react42.useState)(initialTiddlerJSONContent);\n  const tldrawDocumentReference = (0, import_react42.useRef)(tldrawDocument);\n  const tldrawDocumentSetter = (newDocument) => {\n    tldrawDocumentSetterRaw(newDocument);\n    tldrawDocumentReference.current = newDocument;\n  };\n  const deferSave = (0, import_react42.useCallback)(\n    (app) => {\n      const saveCallback = () => {\n        const exportedTldrJSON = { document: app.document, updatedCount: ++updatedCountReference.current };\n        const newTiddlerText = JSON.stringify(exportedTldrJSON);\n        lock();\n        onSave(newTiddlerText);\n      };\n      if (typeof requestIdleCallback !== \"undefined\") {\n        requestIdleCallback(saveCallback, { timeout: 60 });\n      } else if (typeof requestAnimationFrame === \"undefined\") {\n        setTimeout(saveCallback, 16.66);\n      } else {\n        requestAnimationFrame(saveCallback);\n      }\n    },\n    [onSave, lock]\n  );\n  const debouncedSaveOnChange = useDebouncedCallback_default(\n    (app) => {\n      deferSave(app);\n    },\n    [deferSave],\n    debounceSaveTime\n  );\n  const onChange = (app) => {\n    app.document.name = currentTiddler;\n    tldrawDocumentSetter(app.document);\n    if (!isDraft && !readonly) {\n      debouncedSaveOnChange(app);\n    }\n  };\n  (0, import_react42.useEffect)(() => {\n    return () => {\n      if (readonly)\n        return;\n      const exportedTldrJSON = { document: tldrawDocumentReference.current, updatedCount: ++updatedCountReference.current };\n      onSave(JSON.stringify(exportedTldrJSON));\n    };\n  }, []);\n  return /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(import_tw_react2.ParentWidgetContext.Provider, { value: parentWidget, children: /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(\"div\", { className: \"tw-whiteboard-tldraw-container\", style: { height, width }, children: /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(Tldraw, { onPersist: onChange, document: tldrawDocument, autofocus: false, readOnly: readonly }) }) });\n}\n\n// src/widget.ts\nvar Widget = require(\"$:/plugins/linonetwo/tw-react/widget.js\").widget;\nvar SAVE_DEBOUNCE_INTERVAL = 1e3;\nvar TldrawWhiteBoardWidget = class extends Widget {\n  reactComponent = App;\n  getProps = () => {\n    return {\n      currentTiddler: this.editTitle ?? this.getVariable(\"currentTiddler\"),\n      initialTiddlerText: this.editTitle === void 0 ? \"\" : $tw.wiki.getTiddlerText(this.editTitle),\n      height: this.getAttribute(\"height\"),\n      width: this.getAttribute(\"width\"),\n      readonly: this.getAttribute(\"readonly\") === \"yes\" || this.getAttribute(\"readonly\") === \"true\",\n      isDraft: this.editTitle === void 0 ? false : Boolean(this.getAttribute(\"draftTitle\")),\n      saver: {\n        lock: this.lock,\n        onSave: this.onSave,\n        interval: SAVE_DEBOUNCE_INTERVAL\n      }\n    };\n  };\n  refresh(changedTiddlers) {\n    if (this.editTitle === void 0)\n      return false;\n    if (changedTiddlers[this.editTitle]?.deleted === true) {\n      this.lock();\n      return false;\n    }\n    if (this.isUpdatingByUserInput) {\n      return false;\n    }\n    const changedAttributes = this.computeAttributes();\n    if ($tw.utils.count(changedAttributes) > 0 || changedTiddlers[this.editTitle]?.modified === true) {\n      this.refreshSelf();\n      return true;\n    }\n    return false;\n  }\n  editorOperations = {};\n  editTitle;\n  execute() {\n    this.editTitle = this.getAttribute(\"tiddler\");\n    this.makeChildWidgets();\n  }\n  onSave = (newText) => {\n    if (this.editTitle === \"\" || this.editTitle === void 0) {\n      return;\n    }\n    const previousText = $tw.wiki.getTiddlerText(this.editTitle, \"{}\") || \"{}\";\n    if (previousText !== newText) {\n      let isSavingNewVersion = false;\n      try {\n        const newTextVersion = JSON.parse(newText).updatedCount ?? 0;\n        const previousTextVersion = JSON.parse(previousText).updatedCount ?? 0;\n        if (newTextVersion > previousTextVersion) {\n          isSavingNewVersion = true;\n        }\n      } catch (error) {\n        console.error(error);\n      }\n      if (isSavingNewVersion) {\n        $tw.wiki.setText(this.editTitle, void 0, void 0, newText);\n        $tw.wiki.setText(this.editTitle, \"type\", void 0, \"application/tldr\");\n      }\n    }\n    this.unlock();\n  };\n  isUpdatingByUserInput = false;\n  updatingLockTimeoutHandle;\n  get editIconElement() {\n    const element = this.parentDomNode.closest(\".tc-tiddler-exists\")?.querySelector(\".tc-image-wysiwyg-edit-button\");\n    return element;\n  }\n  lock = () => {\n    this.isUpdatingByUserInput = true;\n    if (this.updatingLockTimeoutHandle !== void 0) {\n      clearTimeout(this.updatingLockTimeoutHandle);\n    }\n  };\n  unlock = () => {\n    this.updatingLockTimeoutHandle = setTimeout(() => {\n      this.isUpdatingByUserInput = false;\n    }, SAVE_DEBOUNCE_INTERVAL);\n  };\n};\nexports.whiteboard = TldrawWhiteBoardWidget;\n","type":"application/javascript","module-type":"library","hide-body":"yes"}}}