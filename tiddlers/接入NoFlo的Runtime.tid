created: 20230710074618294
creator: 林一二
modified: 20230711012730332
modifier: 林一二
tags: 任务 基于状态机的插件化的AI流程工具Memeloop NoFlo
title: 接入NoFlo的Runtime
tmo_taskState: New
type: text/vnd.tiddlywiki
wysiwyg: yes

!! 待解决的问题

# flowhub是如何列出可用组件的列表的
# 如何在图里加载自己这个图或者其它子图
# 有没有办法把依赖的组件打成一个包动态加载，还是说必须在运行时通过fs寻找和加载。前者对electric环境更友好

!! noflo-nodejs命令行的执行流程

# 从命令行参数读取文件路径，并用 `fbp-graph` 库加载为 Graph 对象
# 启动一个本地socket服务器，供本地自己连，或flowhub连
# 通过 `runtime.graph.registerGraph` 监听这个图的变化并广播，并设为当前的 `mainGraph` 在未来 `getRuntime` 时返回
## 谁会操作本地的图，它为何会变化？应该都是远端操作的吧，可能是为了某个远端操作后本地变了后同步给其它所有远端
## 看起来一个 runtime 只能有一个图？所以如果要在后台执行多个图就需要启动多个 runtime？不过或许这只是开发环境，生产环境可以直接用 noflo 包运行多个图


应该可以不用它这里的逻辑，因为主要是为远程连接 flowhub 开发用的，并支持广播给多端协作。我们自己嵌入了图编辑器且单用户的话，自己保存图和执行图就好了。

等需要做多人协作了再把 runtime 和 fbp protocol 这套东西加回来。 

# 通过 `./node_modules/.bin/noflo-nodejs --host localhost --auto-save --graph ./scripts/MyGraph.json` 启动后打开的 flowhub 页面里可以搜到本地安装的各种 `noflo-strings` 之类的包提供的组件
## 通过 devtool 看到是通过 `"protocol":"component","command":"list"` 触发返回一系列 `"protocol":"component","command":"component","payload":{"name":"core/Callback"` 协议在 socket 里，在页面加载时一个组件一个组件地读取的
## 实际上转发给了 `runtimeClient.protocol.component.list` 然后是 `noflo` 包里调 `fbp-manifest` 包的 `manifest.list.list(loader.baseDir, opts)` 
# noflo-component-loader 并没有让 `import { ComponentLoader } from 'noflo';` 取得的 loader 能列出组件列表，直接用 `fbpManifest.load.load` 却能看到 node_modules 里的组件
## 需要在 manifest 的设置里开启 `recursive: true,` 才会递归搜素 nodemodules 里的内容，不然默认搜素当前项目文件夹里的 conponents 文件夹和 graph 文件夹
# 没加载图标
## 首先得装 `@fortawesome/fontawesome-free` 包，用里面的 `@fortawesome/fontawesome-free/js/all.js` `/css/all.css` `/css/v4-font-face.css` 加载 fbp 那个年代用的 v4 版
## `TheGraph.library.libraryFromGraph` 只是通过图中节点反推伪造了一个组件库，都是假的，自然没有 icon 属性，可以通过 `component.icon = sample(Object.keys(TheGraph.FONT_AWESOME));` 手动放上去来测试效果
## 还是得正常拼装组件库 library 并传给 `TheGraph.App` 才是正途
